// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package model

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const AddMatchIDToTicket = `-- name: AddMatchIDToTicket :execresult
UPDATE matchmaking_ticket
SET matchmaking_match_id = ?
WHERE id = ?
    AND matchmaking_match_id IS NULL
`

type AddMatchIDToTicketParams struct {
	MatchmakingMatchID sql.NullInt64 `db:"matchmaking_match_id"`
	ID                 uint64        `db:"id"`
}

func (q *Queries) AddMatchIDToTicket(ctx context.Context, arg AddMatchIDToTicketParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, AddMatchIDToTicket, arg.MatchmakingMatchID, arg.ID)
}

const CreateMatch = `-- name: CreateMatch :execresult
INSERT INTO matchmaking_match (matchmaking_arena_id, data)
VALUES (?, "{}")
`

func (q *Queries) CreateMatch(ctx context.Context, matchmakingArenaID uint64) (sql.Result, error) {
	return q.db.ExecContext(ctx, CreateMatch, matchmakingArenaID)
}

const GetAgedMatchmakingTickets = `-- name: GetAgedMatchmakingTickets :many
SELECT id,
    matchmaking_match_id,
    elo_window,
    data,
    expires_at,
    created_at,
    updated_at
FROM matchmaking_ticket
WHERE expires_at < NOW()
    AND matchmaking_match_id IS NULL
    AND elo_window >= ?
LIMIT ? OFFSET ?
`

type GetAgedMatchmakingTicketsParams struct {
	EloWindowMax uint32 `db:"elo_window_max"`
	Limit        int32  `db:"limit"`
	Offset       int32  `db:"offset"`
}

func (q *Queries) GetAgedMatchmakingTickets(ctx context.Context, arg GetAgedMatchmakingTicketsParams) ([]MatchmakingTicket, error) {
	rows, err := q.db.QueryContext(ctx, GetAgedMatchmakingTickets, arg.EloWindowMax, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MatchmakingTicket
	for rows.Next() {
		var i MatchmakingTicket
		if err := rows.Scan(
			&i.ID,
			&i.MatchmakingMatchID,
			&i.EloWindow,
			&i.Data,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetClosestMatch = `-- name: GetClosestMatch :one
WITH ticket_elo AS (
    SELECT AVG(mu.elo) - mt.elo_window AS min_elo,
        AVG(mu.elo) + mt.elo_window AS max_elo,
        COUNT(mu.id) AS player_count
    FROM matchmaking_ticket mt
        JOIN matchmaking_ticket_user mtu ON mt.id = mtu.matchmaking_ticket_id
        JOIN matchmaking_user mu ON mtu.matchmaking_user_id = mu.id
    WHERE mt.id = ?
),
match_elo AS (
    SELECT mm.id AS match_id,
        mm.matchmaking_arena_id,
        AVG(mu.elo) AS avg_elo,
        COUNT(mu.id) AS current_player_count
    FROM matchmaking_match mm
        JOIN matchmaking_ticket mt ON mm.id = mt.matchmaking_match_id
        JOIN matchmaking_ticket_user mtu ON mt.id = mtu.matchmaking_ticket_id
        JOIN matchmaking_user mu ON mtu.matchmaking_user_id = mu.id
        JOIN ticket_elo te ON mm.matchmaking_arena_id = te.matchmaking_arena_id
    WHERE mm.locked_at < NOW()
    GROUP BY mm.id,
        mm.matchmaking_arena_id
    HAVING avg_elo BETWEEN MIN(te.min_elo) AND MAX(te.max_elo)
        AND te.player_count <= (
            SELECT max_players
            FROM matchmaking_arena
            WHERE id = mm.matchmaking_arena_id
        ) - current_player_count
)
SELECT mm.id,
    mm.matchmaking_arena_id,
    mm.data,
    mm.locked_at,
    mm.started_at,
    mm.ended_at,
    mm.created_at,
    mm.updated_at
FROM matchmaking_match mm
    JOIN match_elo me ON mm.id = me.match_id
ORDER BY ABS(
        me.avg_elo - (
            SELECT AVG(mu.elo)
            FROM matchmaking_ticket mt
                JOIN matchmaking_ticket_user mtu ON mt.id = mtu.matchmaking_ticket_id
                JOIN matchmaking_user mu ON mtu.matchmaking_user_id = mu.id
            WHERE mt.id = sqlc.arg(ticket_id)
        )
    )
LIMIT 1
`

type GetClosestMatchRow struct {
	ID                 uint64          `db:"id"`
	MatchmakingArenaID uint64          `db:"matchmaking_arena_id"`
	Data               json.RawMessage `db:"data"`
	LockedAt           sql.NullTime    `db:"locked_at"`
	StartedAt          sql.NullTime    `db:"started_at"`
	EndedAt            sql.NullTime    `db:"ended_at"`
	CreatedAt          time.Time       `db:"created_at"`
	UpdatedAt          time.Time       `db:"updated_at"`
}

func (q *Queries) GetClosestMatch(ctx context.Context, ticketID uint64) (GetClosestMatchRow, error) {
	row := q.db.QueryRowContext(ctx, GetClosestMatch, ticketID)
	var i GetClosestMatchRow
	err := row.Scan(
		&i.ID,
		&i.MatchmakingArenaID,
		&i.Data,
		&i.LockedAt,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetMostPopularArenaOnTicket = `-- name: GetMostPopularArenaOnTicket :one
SELECT ma.id,
    ma.name,
    ma.min_players,
    ma.max_players_per_ticket,
    ma.max_players,
    ma.data,
    ma.created_at,
    ma.updated_at,
    COUNT(mt.id) AS ticket_count
FROM matchmaking_ticket mt
    JOIN matchmaking_ticket_arena mta ON mt.id = mta.matchmaking_ticket_id
    JOIN matchmaking_arena ma ON mta.matchmaking_arena_id = ma.id
WHERE mt.id = ?
GROUP BY ma.id,
    ma.name
ORDER BY ticket_count DESC
LIMIT 1
`

type GetMostPopularArenaOnTicketRow struct {
	ID                  uint64          `db:"id"`
	Name                string          `db:"name"`
	MinPlayers          uint32          `db:"min_players"`
	MaxPlayersPerTicket uint32          `db:"max_players_per_ticket"`
	MaxPlayers          uint32          `db:"max_players"`
	Data                json.RawMessage `db:"data"`
	CreatedAt           time.Time       `db:"created_at"`
	UpdatedAt           time.Time       `db:"updated_at"`
	TicketCount         int64           `db:"ticket_count"`
}

func (q *Queries) GetMostPopularArenaOnTicket(ctx context.Context, id uint64) (GetMostPopularArenaOnTicketRow, error) {
	row := q.db.QueryRowContext(ctx, GetMostPopularArenaOnTicket, id)
	var i GetMostPopularArenaOnTicketRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MinPlayers,
		&i.MaxPlayersPerTicket,
		&i.MaxPlayers,
		&i.Data,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TicketCount,
	)
	return i, err
}

const GetNonAgedMatchmakingTickets = `-- name: GetNonAgedMatchmakingTickets :many
SELECT id,
    matchmaking_match_id,
    elo_window,
    data,
    expires_at,
    created_at,
    updated_at
FROM matchmaking_ticket
WHERE expires_at < NOW()
    AND matchmaking_match_id IS NULL
    AND elo_window < ?
LIMIT ? OFFSET ?
`

type GetNonAgedMatchmakingTicketsParams struct {
	EloWindowMax uint32 `db:"elo_window_max"`
	Limit        int32  `db:"limit"`
	Offset       int32  `db:"offset"`
}

func (q *Queries) GetNonAgedMatchmakingTickets(ctx context.Context, arg GetNonAgedMatchmakingTicketsParams) ([]MatchmakingTicket, error) {
	rows, err := q.db.QueryContext(ctx, GetNonAgedMatchmakingTickets, arg.EloWindowMax, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MatchmakingTicket
	for rows.Next() {
		var i MatchmakingTicket
		if err := rows.Scan(
			&i.ID,
			&i.MatchmakingMatchID,
			&i.EloWindow,
			&i.Data,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const IncrementEloWindow = `-- name: IncrementEloWindow :execresult
UPDATE matchmaking_ticket
SET elo_window = elo_window + ?
WHERE expires_at < NOW()
    AND matchmaking_match_id IS NULL
    AND elo_window < ?
`

type IncrementEloWindowParams struct {
	EloWindowIncrement uint32 `db:"elo_window_increment"`
	EloWindowMax       uint32 `db:"elo_window_max"`
}

func (q *Queries) IncrementEloWindow(ctx context.Context, arg IncrementEloWindowParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, IncrementEloWindow, arg.EloWindowIncrement, arg.EloWindowMax)
}
