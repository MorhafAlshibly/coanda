// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package model

import (
	"context"
	"database/sql"
)

const DeleteEndedEventRoundUsers = `-- name: DeleteEndedEventRoundUsers :execresult
DELETE FROM event_round_user eru
WHERE eru.event_round_id IN (
        SELECT er.id
        FROM event_round er
        WHERE er.ended_at < NOW()
    )
    AND eru.id >= ?
    AND eru.id <= ?
`

type DeleteEndedEventRoundUsersParams struct {
	MinID uint64 `db:"min_id"`
	MaxID uint64 `db:"max_id"`
}

func (q *Queries) DeleteEndedEventRoundUsers(ctx context.Context, arg DeleteEndedEventRoundUsersParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, DeleteEndedEventRoundUsers, arg.MinID, arg.MaxID)
}

const DeleteEndedEventRounds = `-- name: DeleteEndedEventRounds :execresult
DELETE FROM event_round
WHERE ended_at < NOW()
    AND id >= ?
    AND id <= ?
`

type DeleteEndedEventRoundsParams struct {
	MinID uint64 `db:"min_id"`
	MaxID uint64 `db:"max_id"`
}

func (q *Queries) DeleteEndedEventRounds(ctx context.Context, arg DeleteEndedEventRoundsParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, DeleteEndedEventRounds, arg.MinID, arg.MaxID)
}

const DeleteEndedEventUsers = `-- name: DeleteEndedEventUsers :execresult
DELETE FROM event_user eu
WHERE (
        SELECT er.ended_at
        FROM event_round er
        WHERE er.event_id = event_user.event_id
        ORDER BY er.ended_at DESC
        LIMIT 1
    ) < NOW()
    AND eu.id >= ?
    AND eu.id <= ?
`

type DeleteEndedEventUsersParams struct {
	MinID uint64 `db:"min_id"`
	MaxID uint64 `db:"max_id"`
}

func (q *Queries) DeleteEndedEventUsers(ctx context.Context, arg DeleteEndedEventUsersParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, DeleteEndedEventUsers, arg.MinID, arg.MaxID)
}

const DeleteEndedEvents = `-- name: DeleteEndedEvents :execresult
DELETE FROM event e
WHERE (
        SELECT er.ended_at
        FROM event_round er
        WHERE er.event_id = event.id
        ORDER BY er.ended_at DESC
        LIMIT 1
    ) < NOW()
    AND e.id >= ?
    AND e.id <= ?
`

type DeleteEndedEventsParams struct {
	MinID uint64 `db:"min_id"`
	MaxID uint64 `db:"max_id"`
}

func (q *Queries) DeleteEndedEvents(ctx context.Context, arg DeleteEndedEventsParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, DeleteEndedEvents, arg.MinID, arg.MaxID)
}

const GetEndedEventRoundUsers = `-- name: GetEndedEventRoundUsers :many
SELECT eru.id,
    eru.event_user_id,
    eru.event_round_id,
    eru.result,
    eru.data,
    eru.created_at,
    eru.updated_at
FROM event_round_user eru
WHERE (
        SELECT er.ended_at
        FROM event_round er
        WHERE er.id = eru.event_round_id
    ) < NOW()
ORDER BY eru.id ASC
LIMIT ? OFFSET ?
`

type GetEndedEventRoundUsersParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) GetEndedEventRoundUsers(ctx context.Context, arg GetEndedEventRoundUsersParams) ([]EventRoundUser, error) {
	rows, err := q.db.QueryContext(ctx, GetEndedEventRoundUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventRoundUser
	for rows.Next() {
		var i EventRoundUser
		if err := rows.Scan(
			&i.ID,
			&i.EventUserID,
			&i.EventRoundID,
			&i.Result,
			&i.Data,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEndedEventRounds = `-- name: GetEndedEventRounds :many
SELECT id,
    event_id,
    name,
    scoring,
    data,
    ended_at,
    created_at,
    updated_at
FROM event_round
WHERE ended_at < NOW()
ORDER BY id ASC
LIMIT ? OFFSET ?
`

type GetEndedEventRoundsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) GetEndedEventRounds(ctx context.Context, arg GetEndedEventRoundsParams) ([]EventRound, error) {
	rows, err := q.db.QueryContext(ctx, GetEndedEventRounds, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventRound
	for rows.Next() {
		var i EventRound
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Name,
			&i.Scoring,
			&i.Data,
			&i.EndedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEndedEventUsers = `-- name: GetEndedEventUsers :many
SELECT eu.id,
    eu.event_id,
    eu.user_id,
    eu.data,
    eu.created_at,
    eu.updated_at
FROM event_user eu
WHERE (
        SELECT er.ended_at
        FROM event_round er
        WHERE er.event_id = event_user.event_id
        ORDER BY er.ended_at DESC
        LIMIT 1
    ) < NOW()
ORDER BY eu.id ASC
LIMIT ? OFFSET ?
`

type GetEndedEventUsersParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) GetEndedEventUsers(ctx context.Context, arg GetEndedEventUsersParams) ([]EventUser, error) {
	rows, err := q.db.QueryContext(ctx, GetEndedEventUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventUser
	for rows.Next() {
		var i EventUser
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.UserID,
			&i.Data,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEndedEvents = `-- name: GetEndedEvents :many
SELECT e.id,
    e.name,
    e.data,
    e.started_at,
    e.created_at,
    e.updated_at
FROM event e
WHERE (
        SELECT er.ended_at
        FROM event_round er
        WHERE er.event_id = event.id
        ORDER BY er.ended_at DESC
        LIMIT 1
    ) < NOW()
ORDER BY e.id ASC
LIMIT ? OFFSET ?
`

type GetEndedEventsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) GetEndedEvents(ctx context.Context, arg GetEndedEventsParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, GetEndedEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Data,
			&i.StartedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
