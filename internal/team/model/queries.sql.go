// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: queries.sql

package model

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createTeam = `-- name: CreateTeam :execresult
INSERT INTO team (name, owner, score, data)
VALUES (?, ?, ?, ?)
`

type CreateTeamParams struct {
	Name  string
	Owner uint64
	Score int64
	Data  json.RawMessage
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTeam,
		arg.Name,
		arg.Owner,
		arg.Score,
		arg.Data,
	)
}

const createTeamMember = `-- name: CreateTeamMember :execresult
INSERT INTO team_member (team, user_id, data)
SELECT ?,
  ?,
  ?
FROM dual
WHERE (
    SELECT COUNT(*)
    FROM team_member tm
    WHERE tm.team = ?
  ) < CAST(? as unsigned)
`

type CreateTeamMemberParams struct {
	Team       string
	UserID     uint64
	Data       json.RawMessage
	MaxMembers int64
}

func (q *Queries) CreateTeamMember(ctx context.Context, arg CreateTeamMemberParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTeamMember,
		arg.Team,
		arg.UserID,
		arg.Data,
		arg.Team,
		arg.MaxMembers,
	)
}

const createTeamOwner = `-- name: CreateTeamOwner :execresult
INSERT INTO team_owner (team, user_id)
VALUES (?, ?)
`

type CreateTeamOwnerParams struct {
	Team   string
	UserID uint64
}

func (q *Queries) CreateTeamOwner(ctx context.Context, arg CreateTeamOwnerParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTeamOwner, arg.Team, arg.UserID)
}

const deleteTeam = `-- name: DeleteTeam :execresult
DELETE FROM team
WHERE name = ?
  OR owner = ?
LIMIT 1
`

type DeleteTeamParams struct {
	Name  sql.NullString
	Owner sql.NullInt64
}

func (q *Queries) DeleteTeam(ctx context.Context, arg DeleteTeamParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteTeam, arg.Name, arg.Owner)
}

const deleteTeamByMember = `-- name: DeleteTeamByMember :execresult
DELETE FROM team
WHERE name = (
    SELECT team
    FROM team_member
    WHERE user_id = ?
    LIMIT 1
  )
LIMIT 1
`

func (q *Queries) DeleteTeamByMember(ctx context.Context, userID uint64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteTeamByMember, userID)
}

const deleteTeamMember = `-- name: DeleteTeamMember :execresult
DELETE FROM team_member
WHERE user_id = ?
LIMIT 1
`

func (q *Queries) DeleteTeamMember(ctx context.Context, userID uint64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteTeamMember, userID)
}

const deleteTeamMembersByMember = `-- name: DeleteTeamMembersByMember :execresult
DELETE FROM team_member
WHERE team = (
    SELECT team
    FROM team_member tm
    WHERE tm.user_id = ?
    LIMIT 1
  )
`

func (q *Queries) DeleteTeamMembersByMember(ctx context.Context, userID uint64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteTeamMembersByMember, userID)
}

const deleteTeamMembersByOwner = `-- name: DeleteTeamMembersByOwner :execresult
DELETE FROM team_member
WHERE team = (
    SELECT name
    FROM team
    WHERE owner = ?
    LIMIT 1
  )
`

func (q *Queries) DeleteTeamMembersByOwner(ctx context.Context, owner uint64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteTeamMembersByOwner, owner)
}

const deleteTeamMembersByTeam = `-- name: DeleteTeamMembersByTeam :execresult
DELETE FROM team_member
WHERE team = ?
`

func (q *Queries) DeleteTeamMembersByTeam(ctx context.Context, team string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteTeamMembersByTeam, team)
}

const deleteTeamOwner = `-- name: DeleteTeamOwner :execresult
DELETE FROM team_owner
WHERE team = ?
  OR user_id = ?
LIMIT 1
`

type DeleteTeamOwnerParams struct {
	Team   string
	UserID uint64
}

func (q *Queries) DeleteTeamOwner(ctx context.Context, arg DeleteTeamOwnerParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteTeamOwner, arg.Team, arg.UserID)
}

const deleteTeamOwnerByMember = `-- name: DeleteTeamOwnerByMember :execresult
DELETE FROM team_owner
WHERE team = (
    SELECT team
    FROM team_member tm
    WHERE tm.user_id = ?
    LIMIT 1
  )
LIMIT 1
`

func (q *Queries) DeleteTeamOwnerByMember(ctx context.Context, userID uint64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteTeamOwnerByMember, userID)
}

const getTeam = `-- name: GetTeam :one
SELECT name,
  owner,
  score,
  ranking,
  data,
  created_at,
  updated_at
FROM ranked_team
WHERE name = ?
  OR owner = ?
LIMIT 1
`

type GetTeamParams struct {
	Name  sql.NullString
	Owner sql.NullInt64
}

func (q *Queries) GetTeam(ctx context.Context, arg GetTeamParams) (RankedTeam, error) {
	row := q.db.QueryRowContext(ctx, getTeam, arg.Name, arg.Owner)
	var i RankedTeam
	err := row.Scan(
		&i.Name,
		&i.Owner,
		&i.Score,
		&i.Ranking,
		&i.Data,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamByMember = `-- name: GetTeamByMember :one
SELECT t.name,
  t.owner,
  t.score,
  t.ranking,
  t.data,
  t.created_at,
  t.updated_at
FROM ranked_team t
  JOIN team_member tm ON t.name = tm.team
WHERE tm.user_id = ?
LIMIT 1
`

func (q *Queries) GetTeamByMember(ctx context.Context, userID uint64) (RankedTeam, error) {
	row := q.db.QueryRowContext(ctx, getTeamByMember, userID)
	var i RankedTeam
	err := row.Scan(
		&i.Name,
		&i.Owner,
		&i.Score,
		&i.Ranking,
		&i.Data,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamMember = `-- name: GetTeamMember :one
SELECT team,
  user_id,
  data,
  joined_at,
  updated_at
FROM team_member
WHERE user_id = ?
LIMIT 1
`

func (q *Queries) GetTeamMember(ctx context.Context, userID uint64) (TeamMember, error) {
	row := q.db.QueryRowContext(ctx, getTeamMember, userID)
	var i TeamMember
	err := row.Scan(
		&i.Team,
		&i.UserID,
		&i.Data,
		&i.JoinedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT team,
  user_id,
  data,
  joined_at,
  updated_at
FROM team_member
WHERE team = ?
ORDER BY joined_at ASC
LIMIT ? OFFSET ?
`

type GetTeamMembersParams struct {
	Team   string
	Limit  int32
	Offset int32
}

func (q *Queries) GetTeamMembers(ctx context.Context, arg GetTeamMembersParams) ([]TeamMember, error) {
	rows, err := q.db.QueryContext(ctx, getTeamMembers, arg.Team, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TeamMember
	for rows.Next() {
		var i TeamMember
		if err := rows.Scan(
			&i.Team,
			&i.UserID,
			&i.Data,
			&i.JoinedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMembersByMember = `-- name: GetTeamMembersByMember :many
SELECT tm.team,
  tm.user_id,
  tm.data,
  tm.joined_at,
  tm.updated_at
FROM team_member tm
  JOIN team_member tm2 ON tm.team = tm2.team
WHERE tm2.user_id = ?
ORDER BY tm.joined_at ASC
LIMIT ? OFFSET ?
`

type GetTeamMembersByMemberParams struct {
	UserID uint64
	Limit  int32
	Offset int32
}

func (q *Queries) GetTeamMembersByMember(ctx context.Context, arg GetTeamMembersByMemberParams) ([]TeamMember, error) {
	rows, err := q.db.QueryContext(ctx, getTeamMembersByMember, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TeamMember
	for rows.Next() {
		var i TeamMember
		if err := rows.Scan(
			&i.Team,
			&i.UserID,
			&i.Data,
			&i.JoinedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMembersByOwner = `-- name: GetTeamMembersByOwner :many
SELECT tm.team,
  tm.user_id,
  tm.data,
  tm.joined_at,
  tm.updated_at
FROM team_member tm
  JOIN team t ON tm.team = t.name
WHERE t.owner = ?
ORDER BY tm.joined_at ASC
LIMIT ? OFFSET ?
`

type GetTeamMembersByOwnerParams struct {
	Owner  uint64
	Limit  int32
	Offset int32
}

func (q *Queries) GetTeamMembersByOwner(ctx context.Context, arg GetTeamMembersByOwnerParams) ([]TeamMember, error) {
	rows, err := q.db.QueryContext(ctx, getTeamMembersByOwner, arg.Owner, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TeamMember
	for rows.Next() {
		var i TeamMember
		if err := rows.Scan(
			&i.Team,
			&i.UserID,
			&i.Data,
			&i.JoinedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeams = `-- name: GetTeams :many
SELECT name,
  owner,
  score,
  ranking,
  data,
  created_at,
  updated_at
FROM ranked_team
ORDER BY score DESC
LIMIT ? OFFSET ?
`

type GetTeamsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetTeams(ctx context.Context, arg GetTeamsParams) ([]RankedTeam, error) {
	rows, err := q.db.QueryContext(ctx, getTeams, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RankedTeam
	for rows.Next() {
		var i RankedTeam
		if err := rows.Scan(
			&i.Name,
			&i.Owner,
			&i.Score,
			&i.Ranking,
			&i.Data,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTeams = `-- name: SearchTeams :many
SELECT name,
  owner,
  score,
  ranking,
  data,
  created_at,
  updated_at
FROM ranked_team
WHERE name LIKE CONCAT('%', ?, '%')
ORDER BY score DESC
LIMIT ? OFFSET ?
`

type SearchTeamsParams struct {
	Query  interface{}
	Limit  int32
	Offset int32
}

func (q *Queries) SearchTeams(ctx context.Context, arg SearchTeamsParams) ([]RankedTeam, error) {
	rows, err := q.db.QueryContext(ctx, searchTeams, arg.Query, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RankedTeam
	for rows.Next() {
		var i RankedTeam
		if err := rows.Scan(
			&i.Name,
			&i.Owner,
			&i.Score,
			&i.Ranking,
			&i.Data,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTeam = `-- name: UpdateTeam :execresult
UPDATE team
SET score = CASE
    WHEN ? IS NOT NULL THEN ? + CASE
      WHEN ? IS NOT NULL THEN score
      ELSE 0
    END
    ELSE score
  END,
  data = CASE
    WHEN CAST(? as unsigned) != 0 THEN ?
    ELSE data
  END
WHERE name = ?
  or name = CASE
    WHEN CAST(? as unsigned) IS NOT NULL THEN (
      SELECT team
      FROM team_member
      WHERE user_id = ?
      LIMIT 1
    )
    ELSE NULL
  END
  or owner = ?
LIMIT 1
`

type UpdateTeamParams struct {
	Score          sql.NullInt64
	IncrementScore int64
	DataExists     int64
	Data           json.RawMessage
	Name           sql.NullString
	Member         sql.NullInt64
	Owner          sql.NullInt64
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTeam,
		arg.Score,
		arg.Score,
		arg.IncrementScore,
		arg.DataExists,
		arg.Data,
		arg.Name,
		arg.Member,
		arg.Member,
		arg.Owner,
	)
}

const updateTeamMember = `-- name: UpdateTeamMember :execresult
UPDATE team_member
SET data = ?
WHERE user_id = ?
LIMIT 1
`

type UpdateTeamMemberParams struct {
	Data   json.RawMessage
	UserID sql.NullInt64
}

func (q *Queries) UpdateTeamMember(ctx context.Context, arg UpdateTeamMemberParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTeamMember, arg.Data, arg.UserID)
}

const updateTeamMembers = `-- name: UpdateTeamMembers :execresult
UPDATE team_member tm
SET data = ?
WHERE tm.team = ?
  OR tm.team = CASE
    WHEN CAST(? as unsigned) IS NOT NULL THEN (
      SELECT name
      FROM team
      WHERE owner = ?
      LIMIT 1
    )
    ELSE NULL
  END
  OR tm.team = CASE
    WHEN CAST(? as unsigned) IS NOT NULL THEN (
      SELECT team
      FROM team_member tm_user_id
      WHERE tm_user_id.user_id = ?
      LIMIT 1
    )
    ELSE NULL
  END
`

type UpdateTeamMembersParams struct {
	Data   json.RawMessage
	Name   sql.NullString
	Owner  sql.NullInt64
	Member sql.NullInt64
}

func (q *Queries) UpdateTeamMembers(ctx context.Context, arg UpdateTeamMembersParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTeamMembers,
		arg.Data,
		arg.Name,
		arg.Owner,
		arg.Owner,
		arg.Member,
		arg.Member,
	)
}
