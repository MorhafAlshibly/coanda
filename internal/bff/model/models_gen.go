// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"

	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// Input type for adding an event result. The result field is the time, score, or other value that the user achieved in the event, ranked from low to high. The userData field is a Struct that can contain any additional data that should be stored with the event user object. The roundUserData field is a Struct that can contain any additional data that should be stored with the user result for the round. If the event user already exists the data field will be updated. If the user already has a result for the round, the result and data fields will be updated.
type AddEventResultRequest struct {
	Event         *EventRequest    `json:"event"`
	UserID        uint64           `json:"userId"`
	Result        uint64           `json:"result"`
	UserData      *structpb.Struct `json:"userData"`
	RoundUserData *structpb.Struct `json:"roundUserData"`
}

// Response type for adding an event result.
type AddEventResultResponse struct {
	Success bool                `json:"success"`
	Error   AddEventResultError `json:"error"`
}

// An arena.
type Arena struct {
	ID                  uint64                 `json:"id"`
	Name                string                 `json:"name"`
	MinPlayers          uint32                 `json:"minPlayers"`
	MaxPlayersPerTicket uint32                 `json:"maxPlayersPerTicket"`
	MaxPlayers          uint32                 `json:"maxPlayers"`
	Data                *structpb.Struct       `json:"data"`
	CreatedAt           *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt           *timestamppb.Timestamp `json:"updatedAt"`
}

// Input object for requesting an arena by ID, or name.
type ArenaRequest struct {
	ID   *uint64 `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// Response object for completing a task.
type CompleteTaskResponse struct {
	Success bool              `json:"success"`
	Error   CompleteTaskError `json:"error"`
}

// Input object for creating a new arena.
type CreateArenaRequest struct {
	Name                string           `json:"name"`
	MinPlayers          uint32           `json:"minPlayers"`
	MaxPlayersPerTicket uint32           `json:"maxPlayersPerTicket"`
	MaxPlayers          uint32           `json:"maxPlayers"`
	Data                *structpb.Struct `json:"data"`
}

// Response object for creating an arena.
type CreateArenaResponse struct {
	Success bool             `json:"success"`
	ID      *uint64          `json:"id,omitempty"`
	Error   CreateArenaError `json:"error"`
}

// Input type for creating an event. The rounds field is an array of CreateEventRound objects.
type CreateEventRequest struct {
	Name      string                 `json:"name"`
	Data      *structpb.Struct       `json:"data"`
	StartedAt *timestamppb.Timestamp `json:"startedAt"`
	Rounds    []*CreateEventRound    `json:"rounds"`
}

// Response type for creating an event.
type CreateEventResponse struct {
	Success bool             `json:"success"`
	ID      *uint64          `json:"id,omitempty"`
	Error   CreateEventError `json:"error"`
}

// Input type for creating an event round. The difference between the endedAt fields of the different rounds signifies the start and end of the round. The scoring field is an array of integers that represent the score for each rank. The first element is the score for the first rank, the second element is the score for the second rank, and so on.
type CreateEventRound struct {
	Name    string                 `json:"name"`
	Data    *structpb.Struct       `json:"data"`
	EndedAt *timestamppb.Timestamp `json:"endedAt"`
	Scoring []uint64               `json:"scoring"`
}

// Input type for creating an event round.
type CreateEventRoundRequest struct {
	Event *EventRequest     `json:"event"`
	Round *CreateEventRound `json:"round"`
}

// Response type for creating an event round.
type CreateEventRoundResponse struct {
	Success bool                  `json:"success"`
	ID      *uint64               `json:"id,omitempty"`
	Error   CreateEventRoundError `json:"error"`
}

// Input object for creating a new item. An expiration date can be specified, but it is optional. You are free to use any value as an ID, but an ID and Type combination must be unique in the system.
type CreateItemRequest struct {
	ID        string                 `json:"id"`
	Type      string                 `json:"type"`
	Data      *structpb.Struct       `json:"data"`
	ExpiresAt *timestamppb.Timestamp `json:"expiresAt,omitempty"`
}

// Response object for creating an item.
type CreateItemResponse struct {
	Success bool            `json:"success"`
	Error   CreateItemError `json:"error"`
}

// Input object for creating a new matchmaking ticket.
type CreateMatchmakingTicketRequest struct {
	MatchmakingUsers []*MatchmakingUserRequest `json:"matchmakingUsers"`
	Arenas           []*ArenaRequest           `json:"arenas"`
	Data             *structpb.Struct          `json:"data"`
}

// Response object for creating a matchmaking ticket.
type CreateMatchmakingTicketResponse struct {
	Success bool                         `json:"success"`
	ID      *uint64                      `json:"id,omitempty"`
	Error   CreateMatchmakingTicketError `json:"error"`
}

// Input object for creating a new matchmaking user. The elo that is set is the default elo for the user across all arenas.
type CreateMatchmakingUserRequest struct {
	ClientUserID uint64           `json:"clientUserId"`
	Elo          int64            `json:"elo"`
	Data         *structpb.Struct `json:"data"`
}

// Response object for creating a matchmaking user.
type CreateMatchmakingUserResponse struct {
	Success bool                       `json:"success"`
	ID      *uint64                    `json:"id,omitempty"`
	Error   CreateMatchmakingUserError `json:"error"`
}

// Input object for creating a new record.
type CreateRecordRequest struct {
	Name   string           `json:"name"`
	UserID uint64           `json:"userId"`
	Record uint64           `json:"record"`
	Data   *structpb.Struct `json:"data"`
}

// Response object for creating a record.
type CreateRecordResponse struct {
	Success bool              `json:"success"`
	ID      *uint64           `json:"id,omitempty"`
	Error   CreateRecordError `json:"error"`
}

// Input object for creating a new task. An expiration date can be specified, but it is optional. You are free to use any value as an ID, but an ID and Type combination must be unique in the system.
type CreateTaskRequest struct {
	ID        string                 `json:"id"`
	Type      string                 `json:"type"`
	Data      *structpb.Struct       `json:"data"`
	ExpiresAt *timestamppb.Timestamp `json:"expiresAt,omitempty"`
}

// Response object for creating an task.
type CreateTaskResponse struct {
	Success bool            `json:"success"`
	Error   CreateTaskError `json:"error"`
}

// Input object for creating a new team.
type CreateTeamRequest struct {
	Name              string           `json:"name"`
	Score             *int64           `json:"score,omitempty"`
	FirstMemberUserID uint64           `json:"firstMemberUserId"`
	Data              *structpb.Struct `json:"data"`
	FirstMemberData   *structpb.Struct `json:"firstMemberData"`
}

// Response object for creating a team.
type CreateTeamResponse struct {
	Success bool            `json:"success"`
	ID      *uint64         `json:"id,omitempty"`
	Error   CreateTeamError `json:"error"`
}

// Input object for creating a new tournament user.
type CreateTournamentUserRequest struct {
	Tournament string             `json:"tournament"`
	Interval   TournamentInterval `json:"interval"`
	UserID     uint64             `json:"userId"`
	Score      *int64             `json:"score,omitempty"`
	Data       *structpb.Struct   `json:"data"`
}

// Response object for creating a tournament user.
type CreateTournamentUserResponse struct {
	Success bool                      `json:"success"`
	ID      *uint64                   `json:"id,omitempty"`
	Error   CreateTournamentUserError `json:"error"`
}

// Response object for deleting all expired matchmaking tickets.
type DeleteAllExpiredMatchmakingTicketsResponse struct {
	Success bool `json:"success"`
}

// Response object for deleting a match.
type DeleteMatchResponse struct {
	Success bool             `json:"success"`
	Error   DeleteMatchError `json:"error"`
}

// Response object for deleting a matchmaking ticket.
type DeleteMatchmakingTicketResponse struct {
	Success bool                         `json:"success"`
	Error   DeleteMatchmakingTicketError `json:"error"`
}

// Response object for deleting a record.
type DeleteRecordResponse struct {
	Success bool              `json:"success"`
	Error   DeleteRecordError `json:"error"`
}

// Input object for ending a match.
type EndMatchRequest struct {
	Match   *MatchRequest          `json:"match"`
	EndTime *timestamppb.Timestamp `json:"endTime"`
}

// Response object for ending a match.
type EndMatchResponse struct {
	Success bool          `json:"success"`
	Error   EndMatchError `json:"error"`
}

// Type representing an event. The current round is the round that is currently active, it will be the first round if the event has not started yet, or if all rounds have ended it will be null.
type Event struct {
	ID               uint64                 `json:"id"`
	Name             string                 `json:"name"`
	CurrentRoundID   *uint64                `json:"currentRoundId,omitempty"`
	CurrentRoundName *string                `json:"currentRoundName,omitempty"`
	Data             *structpb.Struct       `json:"data"`
	Rounds           []*EventRound          `json:"rounds"`
	StartedAt        *timestamppb.Timestamp `json:"startedAt"`
	CreatedAt        *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt        *timestamppb.Timestamp `json:"updatedAt"`
}

// The event object is used to identify an event by ID or name.
type EventRequest struct {
	ID   *uint64 `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// Response type for deleting an event.
type EventResponse struct {
	Success bool       `json:"success"`
	Error   EventError `json:"error"`
}

// Type representing an event round.
type EventRound struct {
	ID        uint64                 `json:"id"`
	EventID   uint64                 `json:"eventId"`
	Name      string                 `json:"name"`
	Scoring   []uint64               `json:"scoring"`
	Data      *structpb.Struct       `json:"data"`
	EndedAt   *timestamppb.Timestamp `json:"endedAt"`
	CreatedAt *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

// Input type for getting an event round. If the round name is not provided, the current round is used.
type EventRoundRequest struct {
	ID        *uint64       `json:"id,omitempty"`
	Event     *EventRequest `json:"event,omitempty"`
	RoundName *string       `json:"roundName,omitempty"`
}

// Type representing an event round user.
type EventRoundUser struct {
	ID           uint64                 `json:"id"`
	EventUserID  uint64                 `json:"eventUserId"`
	EventRoundID uint64                 `json:"eventRoundId"`
	Result       uint64                 `json:"result"`
	Ranking      uint64                 `json:"ranking"`
	Data         *structpb.Struct       `json:"data"`
	CreatedAt    *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt    *timestamppb.Timestamp `json:"updatedAt"`
}

// Input type for removing an event result.
type EventRoundUserRequest struct {
	ID uint64 `json:"id"`
}

// Type representing an event user.
type EventUser struct {
	ID        uint64                 `json:"id"`
	EventID   uint64                 `json:"eventId"`
	UserID    uint64                 `json:"userId"`
	Score     uint64                 `json:"score"`
	Ranking   uint64                 `json:"ranking"`
	Data      *structpb.Struct       `json:"data"`
	CreatedAt *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

// Input type for getting an event user.
type EventUserRequest struct {
	ID     *uint64       `json:"id,omitempty"`
	Event  *EventRequest `json:"event,omitempty"`
	UserID *uint64       `json:"userId,omitempty"`
}

// Response type for deleting an event user.
type EventUserResponse struct {
	Success bool           `json:"success"`
	Error   EventUserError `json:"error"`
}

// Response object for expiring a matchmaking ticket.
type ExpireMatchmakingTicketResponse struct {
	Success bool                         `json:"success"`
	Error   ExpireMatchmakingTicketError `json:"error"`
}

// Response object for getting an arena.
type GetArenaResponse struct {
	Success bool          `json:"success"`
	Arena   *Arena        `json:"arena,omitempty"`
	Error   GetArenaError `json:"error"`
}

// Response object for getting a list of arenas.
type GetArenasResponse struct {
	Success bool     `json:"success"`
	Arenas  []*Arena `json:"arenas,omitempty"`
}

// Input type for getting an event. The pagination field is used to paginate the leaderboard.
type GetEventRequest struct {
	Event      *EventRequest `json:"event"`
	Pagination *Pagination   `json:"pagination,omitempty"`
}

// Response type for getting an event.
type GetEventResponse struct {
	Success     bool          `json:"success"`
	Event       *Event        `json:"event,omitempty"`
	Leaderboard []*EventUser  `json:"leaderboard"`
	Error       GetEventError `json:"error"`
}

// Input type for getting an event round. The pagination field is used to paginate the leaderboard.
type GetEventRoundRequest struct {
	Round      *EventRoundRequest `json:"round"`
	Pagination *Pagination        `json:"pagination,omitempty"`
}

// Response type for getting an event round.
type GetEventRoundResponse struct {
	Success bool               `json:"success"`
	Round   *EventRound        `json:"round,omitempty"`
	Results []*EventRoundUser  `json:"results"`
	Error   GetEventRoundError `json:"error"`
}

// Input type for getting an event user.
type GetEventUserRequest struct {
	User       *EventUserRequest `json:"user"`
	Pagination *Pagination       `json:"pagination,omitempty"`
}

// Response type for getting an event user.
type GetEventUserResponse struct {
	Success bool              `json:"success"`
	User    *EventUser        `json:"user,omitempty"`
	Results []*EventRoundUser `json:"results"`
	Error   GetEventUserError `json:"error"`
}

// Response object for getting an item.
type GetItemResponse struct {
	Success bool         `json:"success"`
	Item    *Item        `json:"item,omitempty"`
	Error   GetItemError `json:"error"`
}

// Input object for requesting a list of items based on type and pagination options.
type GetItemsRequest struct {
	Type       *string     `json:"type,omitempty"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

// Response object for getting a list of items.
type GetItemsResponse struct {
	Success bool    `json:"success"`
	Items   []*Item `json:"items"`
}

// Input object for requesting a match by ID, or matchmaking ticket. And pagination options for tickets and users.
type GetMatchRequest struct {
	Match            *MatchRequest `json:"match"`
	TicketPagination *Pagination   `json:"ticketPagination,omitempty"`
	UserPagination   *Pagination   `json:"userPagination,omitempty"`
	ArenaPagination  *Pagination   `json:"arenaPagination,omitempty"`
}

// Response object for getting a match.
type GetMatchResponse struct {
	Success bool          `json:"success"`
	Match   *Match        `json:"match,omitempty"`
	Error   GetMatchError `json:"error"`
}

// Input object for requesting a list of matches based on arena, matchmaking user, status, and pagination options.
type GetMatchesRequest struct {
	Arena            *ArenaRequest           `json:"arena,omitempty"`
	MatchmakingUser  *MatchmakingUserRequest `json:"matchmakingUser,omitempty"`
	Statuses         []*MatchStatus          `json:"statuses,omitempty"`
	Pagination       *Pagination             `json:"pagination,omitempty"`
	TicketPagination *Pagination             `json:"ticketPagination,omitempty"`
	UserPagination   *Pagination             `json:"userPagination,omitempty"`
	ArenaPagination  *Pagination             `json:"arenaPagination,omitempty"`
}

// Response object for getting a list of matches.
type GetMatchesResponse struct {
	Success bool     `json:"success"`
	Matches []*Match `json:"matches,omitempty"`
}

// Input object for requesting a matchmaking ticket by ID, or matchmaking user.
type GetMatchmakingTicketRequest struct {
	MatchmakingTicket *MatchmakingTicketRequest `json:"matchmakingTicket"`
	UserPagination    *Pagination               `json:"userPagination,omitempty"`
	ArenaPagination   *Pagination               `json:"arenaPagination,omitempty"`
}

// Response object for getting a matchmaking ticket.
type GetMatchmakingTicketResponse struct {
	Success           bool                      `json:"success"`
	MatchmakingTicket *MatchmakingTicket        `json:"matchmakingTicket,omitempty"`
	Error             GetMatchmakingTicketError `json:"error"`
}

// Input object for requesting a list of matchmaking tickets based on match ID, matchmaking user, status, and pagination options.
type GetMatchmakingTicketsRequest struct {
	MatchID         *uint64                    `json:"matchId,omitempty"`
	MatchmakingUser *MatchmakingUserRequest    `json:"matchmakingUser,omitempty"`
	Statuses        []*MatchmakingTicketStatus `json:"statuses,omitempty"`
	Pagination      *Pagination                `json:"pagination,omitempty"`
	UserPagination  *Pagination                `json:"userPagination,omitempty"`
	ArenaPagination *Pagination                `json:"arenaPagination,omitempty"`
}

// Response object for getting a list of matchmaking tickets.
type GetMatchmakingTicketsResponse struct {
	Success            bool                       `json:"success"`
	MatchmakingTickets []*MatchmakingTicket       `json:"matchmakingTickets,omitempty"`
	Error              GetMatchmakingTicketsError `json:"error"`
}

// Response object for getting a matchmaking user.
type GetMatchmakingUserResponse struct {
	Success         bool                    `json:"success"`
	MatchmakingUser *MatchmakingUser        `json:"matchmakingUser,omitempty"`
	Error           GetMatchmakingUserError `json:"error"`
}

// Response object for getting a list of matchmaking users.
type GetMatchmakingUsersResponse struct {
	Success          bool               `json:"success"`
	MatchmakingUsers []*MatchmakingUser `json:"matchmakingUsers,omitempty"`
}

// Response object for getting a record.
type GetRecordResponse struct {
	Success bool           `json:"success"`
	Record  *Record        `json:"record,omitempty"`
	Error   GetRecordError `json:"error"`
}

// Input object for requesting a list of records based on name, user ID, and pagination options.
type GetRecordsRequest struct {
	Name       *string     `json:"name,omitempty"`
	UserID     *uint64     `json:"userId,omitempty"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

// Response object for getting a list of records.
type GetRecordsResponse struct {
	Success bool            `json:"success"`
	Records []*Record       `json:"records"`
	Error   GetRecordsError `json:"error"`
}

// Response object for getting an task.
type GetTaskResponse struct {
	Success bool         `json:"success"`
	Task    *Task        `json:"task,omitempty"`
	Error   GetTaskError `json:"error"`
}

// Input object for requesting a list of tasks based on type and pagination options. Can also filter by completion status.
type GetTasksRequest struct {
	Type       *string     `json:"type,omitempty"`
	Completed  *bool       `json:"completed,omitempty"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

// Response object for getting a list of tasks.
type GetTasksResponse struct {
	Success bool    `json:"success"`
	Tasks   []*Task `json:"tasks"`
}

// Response object for getting a team member.
type GetTeamMemberResponse struct {
	Success bool               `json:"success"`
	Member  *TeamMember        `json:"member,omitempty"`
	Error   GetTeamMemberError `json:"error"`
}

// Input object for getting a team with pagination options for the team members.
type GetTeamRequest struct {
	Team       *TeamRequest `json:"team"`
	Pagination *Pagination  `json:"pagination,omitempty"`
}

// Response object for team-related operations.
type GetTeamResponse struct {
	Success bool         `json:"success"`
	Team    *Team        `json:"team,omitempty"`
	Error   GetTeamError `json:"error"`
}

// Input object for getting a list of teams and their members.
type GetTeamsRequest struct {
	Pagination       *Pagination `json:"pagination,omitempty"`
	MemberPagination *Pagination `json:"memberPagination,omitempty"`
}

// Response object for getting a list of teams and their members.
type GetTeamsResponse struct {
	Success bool    `json:"success"`
	Teams   []*Team `json:"teams"`
}

// Response object for getting a tournament user.
type GetTournamentUserResponse struct {
	Success        bool                   `json:"success"`
	TournamentUser *TournamentUser        `json:"tournamentUser,omitempty"`
	Error          GetTournamentUserError `json:"error"`
}

// Input object for requesting a list of tournament users based on tournament, interval, and user ID.
type GetTournamentUsersRequest struct {
	Tournament *string            `json:"tournament,omitempty"`
	Interval   TournamentInterval `json:"interval"`
	UserID     *uint64            `json:"userId,omitempty"`
	Pagination *Pagination        `json:"pagination,omitempty"`
}

// Response object for getting a list of tournament users.
type GetTournamentUsersResponse struct {
	Success         bool                    `json:"success"`
	TournamentUsers []*TournamentUser       `json:"tournamentUsers"`
	Error           GetTournamentUsersError `json:"error"`
}

// Represents an item.
type Item struct {
	ID        string                 `json:"id"`
	Type      string                 `json:"type"`
	Data      *structpb.Struct       `json:"data"`
	ExpiresAt *timestamppb.Timestamp `json:"expiresAt,omitempty"`
	CreatedAt *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

// Input object for requesting an item by ID and type.
type ItemRequest struct {
	ID   string `json:"id"`
	Type string `json:"type"`
}

// Response object for item-related operations.
type ItemResponse struct {
	Success bool      `json:"success"`
	Error   ItemError `json:"error"`
}

// Input object for deleting a team.
type JoinTeamRequest struct {
	Team   *TeamRequest     `json:"team"`
	UserID uint64           `json:"userId"`
	Data   *structpb.Struct `json:"data"`
}

// Response object for joining a team.
type JoinTeamResponse struct {
	Success bool          `json:"success"`
	Error   JoinTeamError `json:"error"`
}

// Response object for leaving a team.
type LeaveTeamResponse struct {
	Success bool           `json:"success"`
	Error   LeaveTeamError `json:"error"`
}

// A match. This is where tickets are matched together and played.
type Match struct {
	ID              uint64                 `json:"id"`
	Arena           *Arena                 `json:"arena"`
	Tickets         []*MatchmakingTicket   `json:"tickets"`
	PrivateServerID *string                `json:"privateServerId,omitempty"`
	Status          MatchStatus            `json:"status"`
	Data            *structpb.Struct       `json:"data"`
	LockedAt        *timestamppb.Timestamp `json:"lockedAt,omitempty"`
	StartedAt       *timestamppb.Timestamp `json:"startedAt,omitempty"`
	EndedAt         *timestamppb.Timestamp `json:"endedAt,omitempty"`
	CreatedAt       *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt       *timestamppb.Timestamp `json:"updatedAt"`
}

// Input object for requesting a match by ID, or matchmaking ticket.
type MatchRequest struct {
	ID                *uint64                   `json:"id,omitempty"`
	MatchmakingTicket *MatchmakingTicketRequest `json:"matchmakingTicket,omitempty"`
}

// A matchmaking ticket. This is where users are grouped together into parties, and then matched with other tickets.
type MatchmakingTicket struct {
	ID               uint64                  `json:"id"`
	MatchmakingUsers []*MatchmakingUser      `json:"matchmakingUsers"`
	Arenas           []*Arena                `json:"arenas"`
	MatchID          *uint64                 `json:"matchId,omitempty"`
	Status           MatchmakingTicketStatus `json:"status"`
	Data             *structpb.Struct        `json:"data"`
	ExpiresAt        *timestamppb.Timestamp  `json:"expiresAt"`
	CreatedAt        *timestamppb.Timestamp  `json:"createdAt"`
	UpdatedAt        *timestamppb.Timestamp  `json:"updatedAt"`
}

// Input object for requesting a matchmaking ticket by ID, or matchmaking user.
type MatchmakingTicketRequest struct {
	ID              *uint64                 `json:"id,omitempty"`
	MatchmakingUser *MatchmakingUserRequest `json:"matchmakingUser,omitempty"`
}

// A matchmaking user. Users do not expire or get deleted, unlike tickets.
type MatchmakingUser struct {
	ID           uint64                 `json:"id"`
	ClientUserID uint64                 `json:"clientUserId"`
	Data         *structpb.Struct       `json:"data"`
	Elo          int64                  `json:"elo"`
	CreatedAt    *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt    *timestamppb.Timestamp `json:"updatedAt"`
}

// Input object for requesting a matchmaking user by ID, or client user ID.
type MatchmakingUserRequest struct {
	ID           *uint64 `json:"id,omitempty"`
	ClientUserID *uint64 `json:"clientUserId,omitempty"`
}

// The root mutation type.
type Mutation struct {
}

// Input object for requesting a record by name and user ID.
type NameUserID struct {
	Name   string `json:"name"`
	UserID uint64 `json:"userId"`
}

// Input object for pagination. The max field is the maximum number of items to return, and the page field is the page number to return.
type Pagination struct {
	Max  *uint32 `json:"max,omitempty"`
	Page *uint64 `json:"page,omitempty"`
}

// The root query type.
type Query struct {
}

// The record object, ranked by record lowest to highest for each record name.
type Record struct {
	ID        uint64                 `json:"id"`
	Name      string                 `json:"name"`
	UserID    uint64                 `json:"userId"`
	Record    uint64                 `json:"record"`
	Ranking   uint64                 `json:"ranking"`
	Data      *structpb.Struct       `json:"data"`
	CreatedAt *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

// Input object for requesting a record by ID, or name and user ID.
type RecordRequest struct {
	ID         *uint64     `json:"id,omitempty"`
	NameUserID *NameUserID `json:"nameUserId,omitempty"`
}

// Response type for removing an event result.
type RemoveEventResultResponse struct {
	Success bool                   `json:"success"`
	Error   RemoveEventResultError `json:"error"`
}

// Input object for searching for teams based on a query string.
type SearchTeamsRequest struct {
	Query            string      `json:"query"`
	Pagination       *Pagination `json:"pagination,omitempty"`
	MemberPagination *Pagination `json:"memberPagination,omitempty"`
}

// Response object for searching for teams.
type SearchTeamsResponse struct {
	Success bool             `json:"success"`
	Teams   []*Team          `json:"teams"`
	Error   SearchTeamsError `json:"error"`
}

// Input object for setting the private server of the match.
type SetMatchPrivateServerRequest struct {
	Match           *MatchRequest `json:"match"`
	PrivateServerID string        `json:"privateServerId"`
}

// Response object for setting the private server of the match. If we receive a 'NONE' error or a 'PRIVATE_SERVER_ALREADY_SET' error, then a private server ID will be returned.
type SetMatchPrivateServerResponse struct {
	Success         bool                       `json:"success"`
	PrivateServerID *string                    `json:"privateServerId,omitempty"`
	Error           SetMatchPrivateServerError `json:"error"`
}

// Input object for starting a match.
type StartMatchRequest struct {
	Match     *MatchRequest          `json:"match"`
	StartTime *timestamppb.Timestamp `json:"startTime"`
}

// Response object for starting a match.
type StartMatchResponse struct {
	Success bool            `json:"success"`
	Error   StartMatchError `json:"error"`
}

// Represents an task.
type Task struct {
	ID          string                 `json:"id"`
	Type        string                 `json:"type"`
	Data        *structpb.Struct       `json:"data"`
	ExpiresAt   *timestamppb.Timestamp `json:"expiresAt,omitempty"`
	CompletedAt *timestamppb.Timestamp `json:"completedAt,omitempty"`
	CreatedAt   *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt   *timestamppb.Timestamp `json:"updatedAt"`
}

// Input object for requesting an task by ID and type.
type TaskRequest struct {
	ID   string `json:"id"`
	Type string `json:"type"`
}

// Response object for task-related operations.
type TaskResponse struct {
	Success bool      `json:"success"`
	Error   TaskError `json:"error"`
}

// A team in the system. The ranking is based on the score highest to lowest.
type Team struct {
	ID        uint64                 `json:"id"`
	Name      string                 `json:"name"`
	Score     int64                  `json:"score"`
	Ranking   uint64                 `json:"ranking"`
	Members   []*TeamMember          `json:"members"`
	Data      *structpb.Struct       `json:"data"`
	CreatedAt *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

// A member of a team.
type TeamMember struct {
	ID        uint64                 `json:"id"`
	UserID    uint64                 `json:"userId"`
	TeamID    uint64                 `json:"teamId"`
	Data      *structpb.Struct       `json:"data"`
	JoinedAt  *timestamppb.Timestamp `json:"joinedAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

// Input object for requesting a team member by id or user id.
type TeamMemberRequest struct {
	ID     *uint64 `json:"id,omitempty"`
	UserID *uint64 `json:"userId,omitempty"`
}

// Input object for requesting a team by id, name or member.
type TeamRequest struct {
	ID     *uint64            `json:"id,omitempty"`
	Name   *string            `json:"name,omitempty"`
	Member *TeamMemberRequest `json:"member,omitempty"`
}

// Response object for a team-related operation.
type TeamResponse struct {
	Success bool      `json:"success"`
	Error   TeamError `json:"error"`
}

// Input object for requesting a tournament user by tournament, interval, and user ID.
type TournamentIntervalUserID struct {
	Tournament string             `json:"tournament"`
	Interval   TournamentInterval `json:"interval"`
	UserID     uint64             `json:"userId"`
}

// Type representing a tournament user. Tournaments are created by creating a the first tournament user with a specific tournament, interval, and user ID.
type TournamentUser struct {
	ID                  uint64                 `json:"id"`
	Tournament          string                 `json:"tournament"`
	UserID              uint64                 `json:"userId"`
	Interval            TournamentInterval     `json:"interval"`
	Score               int64                  `json:"score"`
	Ranking             uint64                 `json:"ranking"`
	Data                *structpb.Struct       `json:"data"`
	TournamentStartedAt *timestamppb.Timestamp `json:"tournamentStartedAt"`
	CreatedAt           *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt           *timestamppb.Timestamp `json:"updatedAt"`
}

// Input object for requesting a tournament user by ID, or tournament, interval, and user ID.
type TournamentUserRequest struct {
	ID                       *uint64                   `json:"id,omitempty"`
	TournamentIntervalUserID *TournamentIntervalUserID `json:"tournamentIntervalUserId,omitempty"`
}

// Response object for requesting a tournament user without returning object.
type TournamentUserResponse struct {
	Success bool                `json:"success"`
	Error   TournamentUserError `json:"error"`
}

// Input object for updating an existing arena.
type UpdateArenaRequest struct {
	Arena               *ArenaRequest    `json:"arena"`
	MinPlayers          *uint32          `json:"minPlayers,omitempty"`
	MaxPlayersPerTicket *uint32          `json:"maxPlayersPerTicket,omitempty"`
	MaxPlayers          *uint32          `json:"maxPlayers,omitempty"`
	Data                *structpb.Struct `json:"data,omitempty"`
}

// Response object for updating an arena.
type UpdateArenaResponse struct {
	Success bool             `json:"success"`
	Error   UpdateArenaError `json:"error"`
}

// Input type for updating an event.
type UpdateEventRequest struct {
	Event *EventRequest    `json:"event"`
	Data  *structpb.Struct `json:"data"`
}

// Response type for updating an event.
type UpdateEventResponse struct {
	Success bool             `json:"success"`
	Error   UpdateEventError `json:"error"`
}

// Input type for updating an event round.
type UpdateEventRoundRequest struct {
	Round   *EventRoundRequest `json:"round"`
	Data    *structpb.Struct   `json:"data,omitempty"`
	Scoring []uint64           `json:"scoring,omitempty"`
}

// Response type for updating an event round.
type UpdateEventRoundResponse struct {
	Success bool                  `json:"success"`
	Error   UpdateEventRoundError `json:"error"`
}

// Input type for updating an event user.
type UpdateEventUserRequest struct {
	User *EventUserRequest `json:"user"`
	Data *structpb.Struct  `json:"data"`
}

// Response type for updating an event user.
type UpdateEventUserResponse struct {
	Success bool                 `json:"success"`
	Error   UpdateEventUserError `json:"error"`
}

// Input object for updating an item.
type UpdateItemRequest struct {
	Item *ItemRequest     `json:"item"`
	Data *structpb.Struct `json:"data"`
}

// Response object for updating an item.
type UpdateItemResponse struct {
	Success bool            `json:"success"`
	Error   UpdateItemError `json:"error"`
}

// Input object for updating an existing match.
type UpdateMatchRequest struct {
	Match *MatchRequest    `json:"match"`
	Data  *structpb.Struct `json:"data"`
}

// Response object for updating a match.
type UpdateMatchResponse struct {
	Success bool             `json:"success"`
	Error   UpdateMatchError `json:"error"`
}

// Input object for updating an existing matchmaking ticket.
type UpdateMatchmakingTicketRequest struct {
	MatchmakingTicket *MatchmakingTicketRequest `json:"matchmakingTicket"`
	Data              *structpb.Struct          `json:"data"`
}

// Response object for updating a matchmaking ticket.
type UpdateMatchmakingTicketResponse struct {
	Success bool                         `json:"success"`
	Error   UpdateMatchmakingTicketError `json:"error"`
}

// Input object for updating an existing matchmaking user.
type UpdateMatchmakingUserRequest struct {
	MatchmakingUser *MatchmakingUserRequest `json:"matchmakingUser"`
	Data            *structpb.Struct        `json:"data,omitempty"`
}

// Response object for updating a matchmaking user.
type UpdateMatchmakingUserResponse struct {
	Success bool                       `json:"success"`
	Error   UpdateMatchmakingUserError `json:"error"`
}

// Input object for updating an existing record.
type UpdateRecordRequest struct {
	Request *RecordRequest   `json:"request"`
	Record  *uint64          `json:"record,omitempty"`
	Data    *structpb.Struct `json:"data,omitempty"`
}

// Response object for updating a record.
type UpdateRecordResponse struct {
	Success bool              `json:"success"`
	Error   UpdateRecordError `json:"error"`
}

// Input object for updating an task.
type UpdateTaskRequest struct {
	Task *TaskRequest     `json:"task"`
	Data *structpb.Struct `json:"data"`
}

// Response object for updating an task.
type UpdateTaskResponse struct {
	Success bool            `json:"success"`
	Error   UpdateTaskError `json:"error"`
}

// Input object for updating a team member.
type UpdateTeamMemberRequest struct {
	Member *TeamMemberRequest `json:"member"`
	Data   *structpb.Struct   `json:"data"`
}

// Response object for updating a team member.
type UpdateTeamMemberResponse struct {
	Success bool                  `json:"success"`
	Error   UpdateTeamMemberError `json:"error"`
}

// Input object for deleting a team.
type UpdateTeamRequest struct {
	Team           *TeamRequest     `json:"team"`
	Data           *structpb.Struct `json:"data,omitempty"`
	Score          *int64           `json:"score,omitempty"`
	IncrementScore *bool            `json:"incrementScore,omitempty"`
}

// Response object for updating a team.
type UpdateTeamResponse struct {
	Success bool            `json:"success"`
	Error   UpdateTeamError `json:"error"`
}

// Input object for updating a tournament user. Increment score flag is used to determine if the score should be incremented by the specified score.
type UpdateTournamentUserRequest struct {
	Tournament     *TournamentUserRequest `json:"tournament"`
	Data           *structpb.Struct       `json:"data,omitempty"`
	Score          *int64                 `json:"score,omitempty"`
	IncrementScore *bool                  `json:"incrementScore,omitempty"`
}

// Response object for updating a tournament user.
type UpdateTournamentUserResponse struct {
	Success bool                      `json:"success"`
	Error   UpdateTournamentUserError `json:"error"`
}

// Input object for sending a webhook.
type WebhookRequest struct {
	URI     string           `json:"uri"`
	Method  string           `json:"method"`
	Headers *structpb.Struct `json:"headers"`
	Body    *structpb.Struct `json:"body"`
}

// Response object for sending a webhook.
type WebhookResponse struct {
	Status  uint32           `json:"status"`
	Headers *structpb.Struct `json:"headers"`
	Body    *structpb.Struct `json:"body"`
}

// Possible errors when adding an event result.
type AddEventResultError string

const (
	AddEventResultErrorNone                  AddEventResultError = "NONE"
	AddEventResultErrorNameTooShort          AddEventResultError = "NAME_TOO_SHORT"
	AddEventResultErrorNameTooLong           AddEventResultError = "NAME_TOO_LONG"
	AddEventResultErrorIDOrNameRequired      AddEventResultError = "ID_OR_NAME_REQUIRED"
	AddEventResultErrorUserIDRequired        AddEventResultError = "USER_ID_REQUIRED"
	AddEventResultErrorResultRequired        AddEventResultError = "RESULT_REQUIRED"
	AddEventResultErrorUserDataRequired      AddEventResultError = "USER_DATA_REQUIRED"
	AddEventResultErrorRoundUserDataRequired AddEventResultError = "ROUND_USER_DATA_REQUIRED"
	AddEventResultErrorNotFound              AddEventResultError = "NOT_FOUND"
	AddEventResultErrorEventEnded            AddEventResultError = "EVENT_ENDED"
)

var AllAddEventResultError = []AddEventResultError{
	AddEventResultErrorNone,
	AddEventResultErrorNameTooShort,
	AddEventResultErrorNameTooLong,
	AddEventResultErrorIDOrNameRequired,
	AddEventResultErrorUserIDRequired,
	AddEventResultErrorResultRequired,
	AddEventResultErrorUserDataRequired,
	AddEventResultErrorRoundUserDataRequired,
	AddEventResultErrorNotFound,
	AddEventResultErrorEventEnded,
}

func (e AddEventResultError) IsValid() bool {
	switch e {
	case AddEventResultErrorNone, AddEventResultErrorNameTooShort, AddEventResultErrorNameTooLong, AddEventResultErrorIDOrNameRequired, AddEventResultErrorUserIDRequired, AddEventResultErrorResultRequired, AddEventResultErrorUserDataRequired, AddEventResultErrorRoundUserDataRequired, AddEventResultErrorNotFound, AddEventResultErrorEventEnded:
		return true
	}
	return false
}

func (e AddEventResultError) String() string {
	return string(e)
}

func (e *AddEventResultError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddEventResultError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddEventResultError", str)
	}
	return nil
}

func (e AddEventResultError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when completing an task.
type CompleteTaskError string

const (
	CompleteTaskErrorNone             CompleteTaskError = "NONE"
	CompleteTaskErrorIDRequired       CompleteTaskError = "ID_REQUIRED"
	CompleteTaskErrorTypeRequired     CompleteTaskError = "TYPE_REQUIRED"
	CompleteTaskErrorNotFound         CompleteTaskError = "NOT_FOUND"
	CompleteTaskErrorAlreadyCompleted CompleteTaskError = "ALREADY_COMPLETED"
)

var AllCompleteTaskError = []CompleteTaskError{
	CompleteTaskErrorNone,
	CompleteTaskErrorIDRequired,
	CompleteTaskErrorTypeRequired,
	CompleteTaskErrorNotFound,
	CompleteTaskErrorAlreadyCompleted,
}

func (e CompleteTaskError) IsValid() bool {
	switch e {
	case CompleteTaskErrorNone, CompleteTaskErrorIDRequired, CompleteTaskErrorTypeRequired, CompleteTaskErrorNotFound, CompleteTaskErrorAlreadyCompleted:
		return true
	}
	return false
}

func (e CompleteTaskError) String() string {
	return string(e)
}

func (e *CompleteTaskError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompleteTaskError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompleteTaskError", str)
	}
	return nil
}

func (e CompleteTaskError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when creating an arena.
type CreateArenaError string

const (
	CreateArenaErrorNone                                             CreateArenaError = "NONE"
	CreateArenaErrorNameTooShort                                     CreateArenaError = "NAME_TOO_SHORT"
	CreateArenaErrorNameTooLong                                      CreateArenaError = "NAME_TOO_LONG"
	CreateArenaErrorMinPlayersRequired                               CreateArenaError = "MIN_PLAYERS_REQUIRED"
	CreateArenaErrorMaxPlayersPerTicketRequired                      CreateArenaError = "MAX_PLAYERS_PER_TICKET_REQUIRED"
	CreateArenaErrorMaxPlayersRequired                               CreateArenaError = "MAX_PLAYERS_REQUIRED"
	CreateArenaErrorMinPlayersCannotBeGreaterThanMaxPlayers          CreateArenaError = "MIN_PLAYERS_CANNOT_BE_GREATER_THAN_MAX_PLAYERS"
	CreateArenaErrorMaxPlayersPerTicketCannotBeLessThanMinPlayers    CreateArenaError = "MAX_PLAYERS_PER_TICKET_CANNOT_BE_LESS_THAN_MIN_PLAYERS"
	CreateArenaErrorMaxPlayersPerTicketCannotBeGreaterThanMaxPlayers CreateArenaError = "MAX_PLAYERS_PER_TICKET_CANNOT_BE_GREATER_THAN_MAX_PLAYERS"
	CreateArenaErrorDataRequired                                     CreateArenaError = "DATA_REQUIRED"
	CreateArenaErrorAlreadyExists                                    CreateArenaError = "ALREADY_EXISTS"
)

var AllCreateArenaError = []CreateArenaError{
	CreateArenaErrorNone,
	CreateArenaErrorNameTooShort,
	CreateArenaErrorNameTooLong,
	CreateArenaErrorMinPlayersRequired,
	CreateArenaErrorMaxPlayersPerTicketRequired,
	CreateArenaErrorMaxPlayersRequired,
	CreateArenaErrorMinPlayersCannotBeGreaterThanMaxPlayers,
	CreateArenaErrorMaxPlayersPerTicketCannotBeLessThanMinPlayers,
	CreateArenaErrorMaxPlayersPerTicketCannotBeGreaterThanMaxPlayers,
	CreateArenaErrorDataRequired,
	CreateArenaErrorAlreadyExists,
}

func (e CreateArenaError) IsValid() bool {
	switch e {
	case CreateArenaErrorNone, CreateArenaErrorNameTooShort, CreateArenaErrorNameTooLong, CreateArenaErrorMinPlayersRequired, CreateArenaErrorMaxPlayersPerTicketRequired, CreateArenaErrorMaxPlayersRequired, CreateArenaErrorMinPlayersCannotBeGreaterThanMaxPlayers, CreateArenaErrorMaxPlayersPerTicketCannotBeLessThanMinPlayers, CreateArenaErrorMaxPlayersPerTicketCannotBeGreaterThanMaxPlayers, CreateArenaErrorDataRequired, CreateArenaErrorAlreadyExists:
		return true
	}
	return false
}

func (e CreateArenaError) String() string {
	return string(e)
}

func (e *CreateArenaError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateArenaError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateArenaError", str)
	}
	return nil
}

func (e CreateArenaError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when creating an event.
type CreateEventError string

const (
	CreateEventErrorNone                        CreateEventError = "NONE"
	CreateEventErrorNameTooShort                CreateEventError = "NAME_TOO_SHORT"
	CreateEventErrorNameTooLong                 CreateEventError = "NAME_TOO_LONG"
	CreateEventErrorDataRequired                CreateEventError = "DATA_REQUIRED"
	CreateEventErrorStartedAtRequired           CreateEventError = "STARTED_AT_REQUIRED"
	CreateEventErrorStartedAtInThePast          CreateEventError = "STARTED_AT_IN_THE_PAST"
	CreateEventErrorRoundsRequired              CreateEventError = "ROUNDS_REQUIRED"
	CreateEventErrorTooManyRounds               CreateEventError = "TOO_MANY_ROUNDS"
	CreateEventErrorRoundNameTooShort           CreateEventError = "ROUND_NAME_TOO_SHORT"
	CreateEventErrorRoundNameTooLong            CreateEventError = "ROUND_NAME_TOO_LONG"
	CreateEventErrorRoundDataRequired           CreateEventError = "ROUND_DATA_REQUIRED"
	CreateEventErrorRoundEndedAtRequired        CreateEventError = "ROUND_ENDED_AT_REQUIRED"
	CreateEventErrorRoundEndedAtBeforeStartedAt CreateEventError = "ROUND_ENDED_AT_BEFORE_STARTED_AT"
	CreateEventErrorRoundScoringRequired        CreateEventError = "ROUND_SCORING_REQUIRED"
	CreateEventErrorAlreadyExists               CreateEventError = "ALREADY_EXISTS"
	CreateEventErrorDuplicateRoundName          CreateEventError = "DUPLICATE_ROUND_NAME"
	CreateEventErrorDuplicateRoundEndedAt       CreateEventError = "DUPLICATE_ROUND_ENDED_AT"
)

var AllCreateEventError = []CreateEventError{
	CreateEventErrorNone,
	CreateEventErrorNameTooShort,
	CreateEventErrorNameTooLong,
	CreateEventErrorDataRequired,
	CreateEventErrorStartedAtRequired,
	CreateEventErrorStartedAtInThePast,
	CreateEventErrorRoundsRequired,
	CreateEventErrorTooManyRounds,
	CreateEventErrorRoundNameTooShort,
	CreateEventErrorRoundNameTooLong,
	CreateEventErrorRoundDataRequired,
	CreateEventErrorRoundEndedAtRequired,
	CreateEventErrorRoundEndedAtBeforeStartedAt,
	CreateEventErrorRoundScoringRequired,
	CreateEventErrorAlreadyExists,
	CreateEventErrorDuplicateRoundName,
	CreateEventErrorDuplicateRoundEndedAt,
}

func (e CreateEventError) IsValid() bool {
	switch e {
	case CreateEventErrorNone, CreateEventErrorNameTooShort, CreateEventErrorNameTooLong, CreateEventErrorDataRequired, CreateEventErrorStartedAtRequired, CreateEventErrorStartedAtInThePast, CreateEventErrorRoundsRequired, CreateEventErrorTooManyRounds, CreateEventErrorRoundNameTooShort, CreateEventErrorRoundNameTooLong, CreateEventErrorRoundDataRequired, CreateEventErrorRoundEndedAtRequired, CreateEventErrorRoundEndedAtBeforeStartedAt, CreateEventErrorRoundScoringRequired, CreateEventErrorAlreadyExists, CreateEventErrorDuplicateRoundName, CreateEventErrorDuplicateRoundEndedAt:
		return true
	}
	return false
}

func (e CreateEventError) String() string {
	return string(e)
}

func (e *CreateEventError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateEventError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateEventError", str)
	}
	return nil
}

func (e CreateEventError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when creating an event round.
type CreateEventRoundError string

const (
	CreateEventRoundErrorNone                             CreateEventRoundError = "NONE"
	CreateEventRoundErrorNameTooShort                     CreateEventRoundError = "NAME_TOO_SHORT"
	CreateEventRoundErrorNameTooLong                      CreateEventRoundError = "NAME_TOO_LONG"
	CreateEventRoundErrorIDOrNameRequired                 CreateEventRoundError = "ID_OR_NAME_REQUIRED"
	CreateEventRoundErrorRoundRequired                    CreateEventRoundError = "ROUND_REQUIRED"
	CreateEventRoundErrorRoundNameTooShort                CreateEventRoundError = "ROUND_NAME_TOO_SHORT"
	CreateEventRoundErrorRoundNameTooLong                 CreateEventRoundError = "ROUND_NAME_TOO_LONG"
	CreateEventRoundErrorRoundDataRequired                CreateEventRoundError = "ROUND_DATA_REQUIRED"
	CreateEventRoundErrorRoundEndedAtRequired             CreateEventRoundError = "ROUND_ENDED_AT_REQUIRED"
	CreateEventRoundErrorRoundEndedAtInThePast            CreateEventRoundError = "ROUND_ENDED_AT_IN_THE_PAST"
	CreateEventRoundErrorRoundEndedAtBeforeEventStartedAt CreateEventRoundError = "ROUND_ENDED_AT_BEFORE_EVENT_STARTED_AT"
	CreateEventRoundErrorRoundScoringRequired             CreateEventRoundError = "ROUND_SCORING_REQUIRED"
	CreateEventRoundErrorNotFound                         CreateEventRoundError = "NOT_FOUND"
	CreateEventRoundErrorDuplicateRoundName               CreateEventRoundError = "DUPLICATE_ROUND_NAME"
	CreateEventRoundErrorDuplicateRoundEndedAt            CreateEventRoundError = "DUPLICATE_ROUND_ENDED_AT"
)

var AllCreateEventRoundError = []CreateEventRoundError{
	CreateEventRoundErrorNone,
	CreateEventRoundErrorNameTooShort,
	CreateEventRoundErrorNameTooLong,
	CreateEventRoundErrorIDOrNameRequired,
	CreateEventRoundErrorRoundRequired,
	CreateEventRoundErrorRoundNameTooShort,
	CreateEventRoundErrorRoundNameTooLong,
	CreateEventRoundErrorRoundDataRequired,
	CreateEventRoundErrorRoundEndedAtRequired,
	CreateEventRoundErrorRoundEndedAtInThePast,
	CreateEventRoundErrorRoundEndedAtBeforeEventStartedAt,
	CreateEventRoundErrorRoundScoringRequired,
	CreateEventRoundErrorNotFound,
	CreateEventRoundErrorDuplicateRoundName,
	CreateEventRoundErrorDuplicateRoundEndedAt,
}

func (e CreateEventRoundError) IsValid() bool {
	switch e {
	case CreateEventRoundErrorNone, CreateEventRoundErrorNameTooShort, CreateEventRoundErrorNameTooLong, CreateEventRoundErrorIDOrNameRequired, CreateEventRoundErrorRoundRequired, CreateEventRoundErrorRoundNameTooShort, CreateEventRoundErrorRoundNameTooLong, CreateEventRoundErrorRoundDataRequired, CreateEventRoundErrorRoundEndedAtRequired, CreateEventRoundErrorRoundEndedAtInThePast, CreateEventRoundErrorRoundEndedAtBeforeEventStartedAt, CreateEventRoundErrorRoundScoringRequired, CreateEventRoundErrorNotFound, CreateEventRoundErrorDuplicateRoundName, CreateEventRoundErrorDuplicateRoundEndedAt:
		return true
	}
	return false
}

func (e CreateEventRoundError) String() string {
	return string(e)
}

func (e *CreateEventRoundError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateEventRoundError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateEventRoundError", str)
	}
	return nil
}

func (e CreateEventRoundError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when creating an item.
type CreateItemError string

const (
	CreateItemErrorNone          CreateItemError = "NONE"
	CreateItemErrorIDRequired    CreateItemError = "ID_REQUIRED"
	CreateItemErrorTypeRequired  CreateItemError = "TYPE_REQUIRED"
	CreateItemErrorDataRequired  CreateItemError = "DATA_REQUIRED"
	CreateItemErrorAlreadyExists CreateItemError = "ALREADY_EXISTS"
)

var AllCreateItemError = []CreateItemError{
	CreateItemErrorNone,
	CreateItemErrorIDRequired,
	CreateItemErrorTypeRequired,
	CreateItemErrorDataRequired,
	CreateItemErrorAlreadyExists,
}

func (e CreateItemError) IsValid() bool {
	switch e {
	case CreateItemErrorNone, CreateItemErrorIDRequired, CreateItemErrorTypeRequired, CreateItemErrorDataRequired, CreateItemErrorAlreadyExists:
		return true
	}
	return false
}

func (e CreateItemError) String() string {
	return string(e)
}

func (e *CreateItemError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateItemError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateItemError", str)
	}
	return nil
}

func (e CreateItemError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when creating a matchmaking ticket.
type CreateMatchmakingTicketError string

const (
	CreateMatchmakingTicketErrorNone                     CreateMatchmakingTicketError = "NONE"
	CreateMatchmakingTicketErrorMatchmakingUsersRequired CreateMatchmakingTicketError = "MATCHMAKING_USERS_REQUIRED"
	CreateMatchmakingTicketErrorArenasRequired           CreateMatchmakingTicketError = "ARENAS_REQUIRED"
	CreateMatchmakingTicketErrorDataRequired             CreateMatchmakingTicketError = "DATA_REQUIRED"
	CreateMatchmakingTicketErrorTooManyPlayers           CreateMatchmakingTicketError = "TOO_MANY_PLAYERS"
	CreateMatchmakingTicketErrorUserNotFound             CreateMatchmakingTicketError = "USER_NOT_FOUND"
	CreateMatchmakingTicketErrorArenaNotFound            CreateMatchmakingTicketError = "ARENA_NOT_FOUND"
	CreateMatchmakingTicketErrorUserAlreadyInTicket      CreateMatchmakingTicketError = "USER_ALREADY_IN_TICKET"
)

var AllCreateMatchmakingTicketError = []CreateMatchmakingTicketError{
	CreateMatchmakingTicketErrorNone,
	CreateMatchmakingTicketErrorMatchmakingUsersRequired,
	CreateMatchmakingTicketErrorArenasRequired,
	CreateMatchmakingTicketErrorDataRequired,
	CreateMatchmakingTicketErrorTooManyPlayers,
	CreateMatchmakingTicketErrorUserNotFound,
	CreateMatchmakingTicketErrorArenaNotFound,
	CreateMatchmakingTicketErrorUserAlreadyInTicket,
}

func (e CreateMatchmakingTicketError) IsValid() bool {
	switch e {
	case CreateMatchmakingTicketErrorNone, CreateMatchmakingTicketErrorMatchmakingUsersRequired, CreateMatchmakingTicketErrorArenasRequired, CreateMatchmakingTicketErrorDataRequired, CreateMatchmakingTicketErrorTooManyPlayers, CreateMatchmakingTicketErrorUserNotFound, CreateMatchmakingTicketErrorArenaNotFound, CreateMatchmakingTicketErrorUserAlreadyInTicket:
		return true
	}
	return false
}

func (e CreateMatchmakingTicketError) String() string {
	return string(e)
}

func (e *CreateMatchmakingTicketError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateMatchmakingTicketError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateMatchmakingTicketError", str)
	}
	return nil
}

func (e CreateMatchmakingTicketError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when creating a matchmaking user.
type CreateMatchmakingUserError string

const (
	CreateMatchmakingUserErrorNone                 CreateMatchmakingUserError = "NONE"
	CreateMatchmakingUserErrorClientUserIDRequired CreateMatchmakingUserError = "CLIENT_USER_ID_REQUIRED"
	CreateMatchmakingUserErrorDataRequired         CreateMatchmakingUserError = "DATA_REQUIRED"
	CreateMatchmakingUserErrorAlreadyExists        CreateMatchmakingUserError = "ALREADY_EXISTS"
)

var AllCreateMatchmakingUserError = []CreateMatchmakingUserError{
	CreateMatchmakingUserErrorNone,
	CreateMatchmakingUserErrorClientUserIDRequired,
	CreateMatchmakingUserErrorDataRequired,
	CreateMatchmakingUserErrorAlreadyExists,
}

func (e CreateMatchmakingUserError) IsValid() bool {
	switch e {
	case CreateMatchmakingUserErrorNone, CreateMatchmakingUserErrorClientUserIDRequired, CreateMatchmakingUserErrorDataRequired, CreateMatchmakingUserErrorAlreadyExists:
		return true
	}
	return false
}

func (e CreateMatchmakingUserError) String() string {
	return string(e)
}

func (e *CreateMatchmakingUserError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateMatchmakingUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateMatchmakingUserError", str)
	}
	return nil
}

func (e CreateMatchmakingUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when creating a record.
type CreateRecordError string

const (
	CreateRecordErrorNone           CreateRecordError = "NONE"
	CreateRecordErrorNameTooShort   CreateRecordError = "NAME_TOO_SHORT"
	CreateRecordErrorNameTooLong    CreateRecordError = "NAME_TOO_LONG"
	CreateRecordErrorUserIDRequired CreateRecordError = "USER_ID_REQUIRED"
	CreateRecordErrorRecordRequired CreateRecordError = "RECORD_REQUIRED"
	CreateRecordErrorDataRequired   CreateRecordError = "DATA_REQUIRED"
	CreateRecordErrorRecordExists   CreateRecordError = "RECORD_EXISTS"
)

var AllCreateRecordError = []CreateRecordError{
	CreateRecordErrorNone,
	CreateRecordErrorNameTooShort,
	CreateRecordErrorNameTooLong,
	CreateRecordErrorUserIDRequired,
	CreateRecordErrorRecordRequired,
	CreateRecordErrorDataRequired,
	CreateRecordErrorRecordExists,
}

func (e CreateRecordError) IsValid() bool {
	switch e {
	case CreateRecordErrorNone, CreateRecordErrorNameTooShort, CreateRecordErrorNameTooLong, CreateRecordErrorUserIDRequired, CreateRecordErrorRecordRequired, CreateRecordErrorDataRequired, CreateRecordErrorRecordExists:
		return true
	}
	return false
}

func (e CreateRecordError) String() string {
	return string(e)
}

func (e *CreateRecordError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateRecordError", str)
	}
	return nil
}

func (e CreateRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when creating an task.
type CreateTaskError string

const (
	CreateTaskErrorNone          CreateTaskError = "NONE"
	CreateTaskErrorIDRequired    CreateTaskError = "ID_REQUIRED"
	CreateTaskErrorTypeRequired  CreateTaskError = "TYPE_REQUIRED"
	CreateTaskErrorDataRequired  CreateTaskError = "DATA_REQUIRED"
	CreateTaskErrorAlreadyExists CreateTaskError = "ALREADY_EXISTS"
)

var AllCreateTaskError = []CreateTaskError{
	CreateTaskErrorNone,
	CreateTaskErrorIDRequired,
	CreateTaskErrorTypeRequired,
	CreateTaskErrorDataRequired,
	CreateTaskErrorAlreadyExists,
}

func (e CreateTaskError) IsValid() bool {
	switch e {
	case CreateTaskErrorNone, CreateTaskErrorIDRequired, CreateTaskErrorTypeRequired, CreateTaskErrorDataRequired, CreateTaskErrorAlreadyExists:
		return true
	}
	return false
}

func (e CreateTaskError) String() string {
	return string(e)
}

func (e *CreateTaskError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateTaskError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateTaskError", str)
	}
	return nil
}

func (e CreateTaskError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when creating a team.
type CreateTeamError string

const (
	CreateTeamErrorNone                      CreateTeamError = "NONE"
	CreateTeamErrorNameTooShort              CreateTeamError = "NAME_TOO_SHORT"
	CreateTeamErrorNameTooLong               CreateTeamError = "NAME_TOO_LONG"
	CreateTeamErrorFirstMemberUserIDRequired CreateTeamError = "FIRST_MEMBER_USER_ID_REQUIRED"
	CreateTeamErrorDataRequired              CreateTeamError = "DATA_REQUIRED"
	CreateTeamErrorFirstMemberDataRequired   CreateTeamError = "FIRST_MEMBER_DATA_REQUIRED"
	CreateTeamErrorNameTaken                 CreateTeamError = "NAME_TAKEN"
	CreateTeamErrorFirstMemberAlreadyInATeam CreateTeamError = "FIRST_MEMBER_ALREADY_IN_A_TEAM"
)

var AllCreateTeamError = []CreateTeamError{
	CreateTeamErrorNone,
	CreateTeamErrorNameTooShort,
	CreateTeamErrorNameTooLong,
	CreateTeamErrorFirstMemberUserIDRequired,
	CreateTeamErrorDataRequired,
	CreateTeamErrorFirstMemberDataRequired,
	CreateTeamErrorNameTaken,
	CreateTeamErrorFirstMemberAlreadyInATeam,
}

func (e CreateTeamError) IsValid() bool {
	switch e {
	case CreateTeamErrorNone, CreateTeamErrorNameTooShort, CreateTeamErrorNameTooLong, CreateTeamErrorFirstMemberUserIDRequired, CreateTeamErrorDataRequired, CreateTeamErrorFirstMemberDataRequired, CreateTeamErrorNameTaken, CreateTeamErrorFirstMemberAlreadyInATeam:
		return true
	}
	return false
}

func (e CreateTeamError) String() string {
	return string(e)
}

func (e *CreateTeamError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateTeamError", str)
	}
	return nil
}

func (e CreateTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when creating a tournament user.
type CreateTournamentUserError string

const (
	CreateTournamentUserErrorNone                   CreateTournamentUserError = "NONE"
	CreateTournamentUserErrorTournamentNameTooShort CreateTournamentUserError = "TOURNAMENT_NAME_TOO_SHORT"
	CreateTournamentUserErrorTournamentNameTooLong  CreateTournamentUserError = "TOURNAMENT_NAME_TOO_LONG"
	CreateTournamentUserErrorUserIDRequired         CreateTournamentUserError = "USER_ID_REQUIRED"
	CreateTournamentUserErrorDataRequired           CreateTournamentUserError = "DATA_REQUIRED"
	CreateTournamentUserErrorAlreadyExists          CreateTournamentUserError = "ALREADY_EXISTS"
)

var AllCreateTournamentUserError = []CreateTournamentUserError{
	CreateTournamentUserErrorNone,
	CreateTournamentUserErrorTournamentNameTooShort,
	CreateTournamentUserErrorTournamentNameTooLong,
	CreateTournamentUserErrorUserIDRequired,
	CreateTournamentUserErrorDataRequired,
	CreateTournamentUserErrorAlreadyExists,
}

func (e CreateTournamentUserError) IsValid() bool {
	switch e {
	case CreateTournamentUserErrorNone, CreateTournamentUserErrorTournamentNameTooShort, CreateTournamentUserErrorTournamentNameTooLong, CreateTournamentUserErrorUserIDRequired, CreateTournamentUserErrorDataRequired, CreateTournamentUserErrorAlreadyExists:
		return true
	}
	return false
}

func (e CreateTournamentUserError) String() string {
	return string(e)
}

func (e *CreateTournamentUserError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateTournamentUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateTournamentUserError", str)
	}
	return nil
}

func (e CreateTournamentUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when deleting a match.
type DeleteMatchError string

const (
	DeleteMatchErrorNone                                    DeleteMatchError = "NONE"
	DeleteMatchErrorIDOrMatchmakingTicketRequired           DeleteMatchError = "ID_OR_MATCHMAKING_TICKET_REQUIRED"
	DeleteMatchErrorMatchmakingTicketIDOrUserRequired       DeleteMatchError = "MATCHMAKING_TICKET_ID_OR_USER_REQUIRED"
	DeleteMatchErrorMatchmakingUserIDOrClientUserIDRequired DeleteMatchError = "MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED"
	DeleteMatchErrorNotFound                                DeleteMatchError = "NOT_FOUND"
)

var AllDeleteMatchError = []DeleteMatchError{
	DeleteMatchErrorNone,
	DeleteMatchErrorIDOrMatchmakingTicketRequired,
	DeleteMatchErrorMatchmakingTicketIDOrUserRequired,
	DeleteMatchErrorMatchmakingUserIDOrClientUserIDRequired,
	DeleteMatchErrorNotFound,
}

func (e DeleteMatchError) IsValid() bool {
	switch e {
	case DeleteMatchErrorNone, DeleteMatchErrorIDOrMatchmakingTicketRequired, DeleteMatchErrorMatchmakingTicketIDOrUserRequired, DeleteMatchErrorMatchmakingUserIDOrClientUserIDRequired, DeleteMatchErrorNotFound:
		return true
	}
	return false
}

func (e DeleteMatchError) String() string {
	return string(e)
}

func (e *DeleteMatchError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteMatchError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteMatchError", str)
	}
	return nil
}

func (e DeleteMatchError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when deleting a matchmaking ticket.
type DeleteMatchmakingTicketError string

const (
	DeleteMatchmakingTicketErrorNone                                    DeleteMatchmakingTicketError = "NONE"
	DeleteMatchmakingTicketErrorTicketIDOrMatchmakingUserRequired       DeleteMatchmakingTicketError = "TICKET_ID_OR_MATCHMAKING_USER_REQUIRED"
	DeleteMatchmakingTicketErrorMatchmakingUserIDOrClientUserIDRequired DeleteMatchmakingTicketError = "MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED"
	DeleteMatchmakingTicketErrorNotFound                                DeleteMatchmakingTicketError = "NOT_FOUND"
)

var AllDeleteMatchmakingTicketError = []DeleteMatchmakingTicketError{
	DeleteMatchmakingTicketErrorNone,
	DeleteMatchmakingTicketErrorTicketIDOrMatchmakingUserRequired,
	DeleteMatchmakingTicketErrorMatchmakingUserIDOrClientUserIDRequired,
	DeleteMatchmakingTicketErrorNotFound,
}

func (e DeleteMatchmakingTicketError) IsValid() bool {
	switch e {
	case DeleteMatchmakingTicketErrorNone, DeleteMatchmakingTicketErrorTicketIDOrMatchmakingUserRequired, DeleteMatchmakingTicketErrorMatchmakingUserIDOrClientUserIDRequired, DeleteMatchmakingTicketErrorNotFound:
		return true
	}
	return false
}

func (e DeleteMatchmakingTicketError) String() string {
	return string(e)
}

func (e *DeleteMatchmakingTicketError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteMatchmakingTicketError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteMatchmakingTicketError", str)
	}
	return nil
}

func (e DeleteMatchmakingTicketError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when deleting a record.
type DeleteRecordError string

const (
	DeleteRecordErrorNone                   DeleteRecordError = "NONE"
	DeleteRecordErrorIDOrNameUserIDRequired DeleteRecordError = "ID_OR_NAME_USER_ID_REQUIRED"
	DeleteRecordErrorNotFound               DeleteRecordError = "NOT_FOUND"
	DeleteRecordErrorNameTooShort           DeleteRecordError = "NAME_TOO_SHORT"
	DeleteRecordErrorNameTooLong            DeleteRecordError = "NAME_TOO_LONG"
	DeleteRecordErrorUserIDRequired         DeleteRecordError = "USER_ID_REQUIRED"
)

var AllDeleteRecordError = []DeleteRecordError{
	DeleteRecordErrorNone,
	DeleteRecordErrorIDOrNameUserIDRequired,
	DeleteRecordErrorNotFound,
	DeleteRecordErrorNameTooShort,
	DeleteRecordErrorNameTooLong,
	DeleteRecordErrorUserIDRequired,
}

func (e DeleteRecordError) IsValid() bool {
	switch e {
	case DeleteRecordErrorNone, DeleteRecordErrorIDOrNameUserIDRequired, DeleteRecordErrorNotFound, DeleteRecordErrorNameTooShort, DeleteRecordErrorNameTooLong, DeleteRecordErrorUserIDRequired:
		return true
	}
	return false
}

func (e DeleteRecordError) String() string {
	return string(e)
}

func (e *DeleteRecordError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteRecordError", str)
	}
	return nil
}

func (e DeleteRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when ending a match.
type EndMatchError string

const (
	EndMatchErrorNone                                    EndMatchError = "NONE"
	EndMatchErrorIDOrMatchmakingTicketRequired           EndMatchError = "ID_OR_MATCHMAKING_TICKET_REQUIRED"
	EndMatchErrorMatchmakingTicketIDOrUserRequired       EndMatchError = "MATCHMAKING_TICKET_ID_OR_USER_REQUIRED"
	EndMatchErrorMatchmakingUserIDOrClientUserIDRequired EndMatchError = "MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED"
	EndMatchErrorEndTimeRequired                         EndMatchError = "END_TIME_REQUIRED"
	EndMatchErrorInvalidEndTime                          EndMatchError = "INVALID_END_TIME"
	EndMatchErrorNotFound                                EndMatchError = "NOT_FOUND"
	EndMatchErrorAlreadyEnded                            EndMatchError = "ALREADY_ENDED"
	EndMatchErrorEndTimeBeforeStartTime                  EndMatchError = "END_TIME_BEFORE_START_TIME"
	EndMatchErrorHasNotStarted                           EndMatchError = "HAS_NOT_STARTED"
)

var AllEndMatchError = []EndMatchError{
	EndMatchErrorNone,
	EndMatchErrorIDOrMatchmakingTicketRequired,
	EndMatchErrorMatchmakingTicketIDOrUserRequired,
	EndMatchErrorMatchmakingUserIDOrClientUserIDRequired,
	EndMatchErrorEndTimeRequired,
	EndMatchErrorInvalidEndTime,
	EndMatchErrorNotFound,
	EndMatchErrorAlreadyEnded,
	EndMatchErrorEndTimeBeforeStartTime,
	EndMatchErrorHasNotStarted,
}

func (e EndMatchError) IsValid() bool {
	switch e {
	case EndMatchErrorNone, EndMatchErrorIDOrMatchmakingTicketRequired, EndMatchErrorMatchmakingTicketIDOrUserRequired, EndMatchErrorMatchmakingUserIDOrClientUserIDRequired, EndMatchErrorEndTimeRequired, EndMatchErrorInvalidEndTime, EndMatchErrorNotFound, EndMatchErrorAlreadyEnded, EndMatchErrorEndTimeBeforeStartTime, EndMatchErrorHasNotStarted:
		return true
	}
	return false
}

func (e EndMatchError) String() string {
	return string(e)
}

func (e *EndMatchError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EndMatchError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EndMatchError", str)
	}
	return nil
}

func (e EndMatchError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when deleting an event.
type EventError string

const (
	EventErrorNone             EventError = "NONE"
	EventErrorNameTooShort     EventError = "NAME_TOO_SHORT"
	EventErrorNameTooLong      EventError = "NAME_TOO_LONG"
	EventErrorIDOrNameRequired EventError = "ID_OR_NAME_REQUIRED"
	EventErrorNotFound         EventError = "NOT_FOUND"
)

var AllEventError = []EventError{
	EventErrorNone,
	EventErrorNameTooShort,
	EventErrorNameTooLong,
	EventErrorIDOrNameRequired,
	EventErrorNotFound,
}

func (e EventError) IsValid() bool {
	switch e {
	case EventErrorNone, EventErrorNameTooShort, EventErrorNameTooLong, EventErrorIDOrNameRequired, EventErrorNotFound:
		return true
	}
	return false
}

func (e EventError) String() string {
	return string(e)
}

func (e *EventError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventError", str)
	}
	return nil
}

func (e EventError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when deleting an event user.
type EventUserError string

const (
	EventUserErrorNone             EventUserError = "NONE"
	EventUserErrorNameTooShort     EventUserError = "NAME_TOO_SHORT"
	EventUserErrorNameTooLong      EventUserError = "NAME_TOO_LONG"
	EventUserErrorIDOrNameRequired EventUserError = "ID_OR_NAME_REQUIRED"
	EventUserErrorUserIDRequired   EventUserError = "USER_ID_REQUIRED"
	EventUserErrorNotFound         EventUserError = "NOT_FOUND"
)

var AllEventUserError = []EventUserError{
	EventUserErrorNone,
	EventUserErrorNameTooShort,
	EventUserErrorNameTooLong,
	EventUserErrorIDOrNameRequired,
	EventUserErrorUserIDRequired,
	EventUserErrorNotFound,
}

func (e EventUserError) IsValid() bool {
	switch e {
	case EventUserErrorNone, EventUserErrorNameTooShort, EventUserErrorNameTooLong, EventUserErrorIDOrNameRequired, EventUserErrorUserIDRequired, EventUserErrorNotFound:
		return true
	}
	return false
}

func (e EventUserError) String() string {
	return string(e)
}

func (e *EventUserError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventUserError", str)
	}
	return nil
}

func (e EventUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when expiring a matchmaking ticket.
type ExpireMatchmakingTicketError string

const (
	ExpireMatchmakingTicketErrorNone                                    ExpireMatchmakingTicketError = "NONE"
	ExpireMatchmakingTicketErrorTicketIDOrMatchmakingUserRequired       ExpireMatchmakingTicketError = "TICKET_ID_OR_MATCHMAKING_USER_REQUIRED"
	ExpireMatchmakingTicketErrorMatchmakingUserIDOrClientUserIDRequired ExpireMatchmakingTicketError = "MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED"
	ExpireMatchmakingTicketErrorNotFound                                ExpireMatchmakingTicketError = "NOT_FOUND"
	ExpireMatchmakingTicketErrorAlreadyExpired                          ExpireMatchmakingTicketError = "ALREADY_EXPIRED"
	ExpireMatchmakingTicketErrorAlreadyMatched                          ExpireMatchmakingTicketError = "ALREADY_MATCHED"
	ExpireMatchmakingTicketErrorAlreadyEnded                            ExpireMatchmakingTicketError = "ALREADY_ENDED"
)

var AllExpireMatchmakingTicketError = []ExpireMatchmakingTicketError{
	ExpireMatchmakingTicketErrorNone,
	ExpireMatchmakingTicketErrorTicketIDOrMatchmakingUserRequired,
	ExpireMatchmakingTicketErrorMatchmakingUserIDOrClientUserIDRequired,
	ExpireMatchmakingTicketErrorNotFound,
	ExpireMatchmakingTicketErrorAlreadyExpired,
	ExpireMatchmakingTicketErrorAlreadyMatched,
	ExpireMatchmakingTicketErrorAlreadyEnded,
}

func (e ExpireMatchmakingTicketError) IsValid() bool {
	switch e {
	case ExpireMatchmakingTicketErrorNone, ExpireMatchmakingTicketErrorTicketIDOrMatchmakingUserRequired, ExpireMatchmakingTicketErrorMatchmakingUserIDOrClientUserIDRequired, ExpireMatchmakingTicketErrorNotFound, ExpireMatchmakingTicketErrorAlreadyExpired, ExpireMatchmakingTicketErrorAlreadyMatched, ExpireMatchmakingTicketErrorAlreadyEnded:
		return true
	}
	return false
}

func (e ExpireMatchmakingTicketError) String() string {
	return string(e)
}

func (e *ExpireMatchmakingTicketError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExpireMatchmakingTicketError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExpireMatchmakingTicketError", str)
	}
	return nil
}

func (e ExpireMatchmakingTicketError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting an arena.
type GetArenaError string

const (
	GetArenaErrorNone             GetArenaError = "NONE"
	GetArenaErrorNameTooShort     GetArenaError = "NAME_TOO_SHORT"
	GetArenaErrorNameTooLong      GetArenaError = "NAME_TOO_LONG"
	GetArenaErrorIDOrNameRequired GetArenaError = "ID_OR_NAME_REQUIRED"
	GetArenaErrorNotFound         GetArenaError = "NOT_FOUND"
)

var AllGetArenaError = []GetArenaError{
	GetArenaErrorNone,
	GetArenaErrorNameTooShort,
	GetArenaErrorNameTooLong,
	GetArenaErrorIDOrNameRequired,
	GetArenaErrorNotFound,
}

func (e GetArenaError) IsValid() bool {
	switch e {
	case GetArenaErrorNone, GetArenaErrorNameTooShort, GetArenaErrorNameTooLong, GetArenaErrorIDOrNameRequired, GetArenaErrorNotFound:
		return true
	}
	return false
}

func (e GetArenaError) String() string {
	return string(e)
}

func (e *GetArenaError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetArenaError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetArenaError", str)
	}
	return nil
}

func (e GetArenaError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting an event.
type GetEventError string

const (
	GetEventErrorNone             GetEventError = "NONE"
	GetEventErrorNameTooShort     GetEventError = "NAME_TOO_SHORT"
	GetEventErrorNameTooLong      GetEventError = "NAME_TOO_LONG"
	GetEventErrorIDOrNameRequired GetEventError = "ID_OR_NAME_REQUIRED"
	GetEventErrorNotFound         GetEventError = "NOT_FOUND"
)

var AllGetEventError = []GetEventError{
	GetEventErrorNone,
	GetEventErrorNameTooShort,
	GetEventErrorNameTooLong,
	GetEventErrorIDOrNameRequired,
	GetEventErrorNotFound,
}

func (e GetEventError) IsValid() bool {
	switch e {
	case GetEventErrorNone, GetEventErrorNameTooShort, GetEventErrorNameTooLong, GetEventErrorIDOrNameRequired, GetEventErrorNotFound:
		return true
	}
	return false
}

func (e GetEventError) String() string {
	return string(e)
}

func (e *GetEventError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetEventError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetEventError", str)
	}
	return nil
}

func (e GetEventError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting an event round.
type GetEventRoundError string

const (
	GetEventRoundErrorNone                   GetEventRoundError = "NONE"
	GetEventRoundErrorNameTooShort           GetEventRoundError = "NAME_TOO_SHORT"
	GetEventRoundErrorNameTooLong            GetEventRoundError = "NAME_TOO_LONG"
	GetEventRoundErrorIDOrNameRequired       GetEventRoundError = "ID_OR_NAME_REQUIRED"
	GetEventRoundErrorEventRoundOrIDRequired GetEventRoundError = "EVENT_ROUND_OR_ID_REQUIRED"
	GetEventRoundErrorNotFound               GetEventRoundError = "NOT_FOUND"
)

var AllGetEventRoundError = []GetEventRoundError{
	GetEventRoundErrorNone,
	GetEventRoundErrorNameTooShort,
	GetEventRoundErrorNameTooLong,
	GetEventRoundErrorIDOrNameRequired,
	GetEventRoundErrorEventRoundOrIDRequired,
	GetEventRoundErrorNotFound,
}

func (e GetEventRoundError) IsValid() bool {
	switch e {
	case GetEventRoundErrorNone, GetEventRoundErrorNameTooShort, GetEventRoundErrorNameTooLong, GetEventRoundErrorIDOrNameRequired, GetEventRoundErrorEventRoundOrIDRequired, GetEventRoundErrorNotFound:
		return true
	}
	return false
}

func (e GetEventRoundError) String() string {
	return string(e)
}

func (e *GetEventRoundError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetEventRoundError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetEventRoundError", str)
	}
	return nil
}

func (e GetEventRoundError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting an event user.
type GetEventUserError string

const (
	GetEventUserErrorNone                  GetEventUserError = "NONE"
	GetEventUserErrorNameTooShort          GetEventUserError = "NAME_TOO_SHORT"
	GetEventUserErrorNameTooLong           GetEventUserError = "NAME_TOO_LONG"
	GetEventUserErrorIDOrNameRequired      GetEventUserError = "ID_OR_NAME_REQUIRED"
	GetEventUserErrorUserIDRequired        GetEventUserError = "USER_ID_REQUIRED"
	GetEventUserErrorEventUserOrIDRequired GetEventUserError = "EVENT_USER_OR_ID_REQUIRED"
	GetEventUserErrorNotFound              GetEventUserError = "NOT_FOUND"
)

var AllGetEventUserError = []GetEventUserError{
	GetEventUserErrorNone,
	GetEventUserErrorNameTooShort,
	GetEventUserErrorNameTooLong,
	GetEventUserErrorIDOrNameRequired,
	GetEventUserErrorUserIDRequired,
	GetEventUserErrorEventUserOrIDRequired,
	GetEventUserErrorNotFound,
}

func (e GetEventUserError) IsValid() bool {
	switch e {
	case GetEventUserErrorNone, GetEventUserErrorNameTooShort, GetEventUserErrorNameTooLong, GetEventUserErrorIDOrNameRequired, GetEventUserErrorUserIDRequired, GetEventUserErrorEventUserOrIDRequired, GetEventUserErrorNotFound:
		return true
	}
	return false
}

func (e GetEventUserError) String() string {
	return string(e)
}

func (e *GetEventUserError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetEventUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetEventUserError", str)
	}
	return nil
}

func (e GetEventUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting an item.
type GetItemError string

const (
	GetItemErrorNone         GetItemError = "NONE"
	GetItemErrorIDRequired   GetItemError = "ID_REQUIRED"
	GetItemErrorTypeRequired GetItemError = "TYPE_REQUIRED"
	GetItemErrorNotFound     GetItemError = "NOT_FOUND"
)

var AllGetItemError = []GetItemError{
	GetItemErrorNone,
	GetItemErrorIDRequired,
	GetItemErrorTypeRequired,
	GetItemErrorNotFound,
}

func (e GetItemError) IsValid() bool {
	switch e {
	case GetItemErrorNone, GetItemErrorIDRequired, GetItemErrorTypeRequired, GetItemErrorNotFound:
		return true
	}
	return false
}

func (e GetItemError) String() string {
	return string(e)
}

func (e *GetItemError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetItemError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetItemError", str)
	}
	return nil
}

func (e GetItemError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting a match.
type GetMatchError string

const (
	GetMatchErrorNone                                    GetMatchError = "NONE"
	GetMatchErrorIDOrMatchmakingTicketRequired           GetMatchError = "ID_OR_MATCHMAKING_TICKET_REQUIRED"
	GetMatchErrorMatchmakingTicketIDOrUserRequired       GetMatchError = "MATCHMAKING_TICKET_ID_OR_USER_REQUIRED"
	GetMatchErrorMatchmakingUserIDOrClientUserIDRequired GetMatchError = "MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED"
	GetMatchErrorNotFound                                GetMatchError = "NOT_FOUND"
)

var AllGetMatchError = []GetMatchError{
	GetMatchErrorNone,
	GetMatchErrorIDOrMatchmakingTicketRequired,
	GetMatchErrorMatchmakingTicketIDOrUserRequired,
	GetMatchErrorMatchmakingUserIDOrClientUserIDRequired,
	GetMatchErrorNotFound,
}

func (e GetMatchError) IsValid() bool {
	switch e {
	case GetMatchErrorNone, GetMatchErrorIDOrMatchmakingTicketRequired, GetMatchErrorMatchmakingTicketIDOrUserRequired, GetMatchErrorMatchmakingUserIDOrClientUserIDRequired, GetMatchErrorNotFound:
		return true
	}
	return false
}

func (e GetMatchError) String() string {
	return string(e)
}

func (e *GetMatchError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetMatchError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetMatchError", str)
	}
	return nil
}

func (e GetMatchError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting a matchmaking ticket.
type GetMatchmakingTicketError string

const (
	GetMatchmakingTicketErrorNone                                    GetMatchmakingTicketError = "NONE"
	GetMatchmakingTicketErrorTicketIDOrMatchmakingUserRequired       GetMatchmakingTicketError = "TICKET_ID_OR_MATCHMAKING_USER_REQUIRED"
	GetMatchmakingTicketErrorMatchmakingUserIDOrClientUserIDRequired GetMatchmakingTicketError = "MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED"
	GetMatchmakingTicketErrorNotFound                                GetMatchmakingTicketError = "NOT_FOUND"
)

var AllGetMatchmakingTicketError = []GetMatchmakingTicketError{
	GetMatchmakingTicketErrorNone,
	GetMatchmakingTicketErrorTicketIDOrMatchmakingUserRequired,
	GetMatchmakingTicketErrorMatchmakingUserIDOrClientUserIDRequired,
	GetMatchmakingTicketErrorNotFound,
}

func (e GetMatchmakingTicketError) IsValid() bool {
	switch e {
	case GetMatchmakingTicketErrorNone, GetMatchmakingTicketErrorTicketIDOrMatchmakingUserRequired, GetMatchmakingTicketErrorMatchmakingUserIDOrClientUserIDRequired, GetMatchmakingTicketErrorNotFound:
		return true
	}
	return false
}

func (e GetMatchmakingTicketError) String() string {
	return string(e)
}

func (e *GetMatchmakingTicketError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetMatchmakingTicketError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetMatchmakingTicketError", str)
	}
	return nil
}

func (e GetMatchmakingTicketError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting a list of matchmaking tickets.
type GetMatchmakingTicketsError string

const (
	GetMatchmakingTicketsErrorNone          GetMatchmakingTicketsError = "NONE"
	GetMatchmakingTicketsErrorMatchNotFound GetMatchmakingTicketsError = "MATCH_NOT_FOUND"
	GetMatchmakingTicketsErrorUserNotFound  GetMatchmakingTicketsError = "USER_NOT_FOUND"
)

var AllGetMatchmakingTicketsError = []GetMatchmakingTicketsError{
	GetMatchmakingTicketsErrorNone,
	GetMatchmakingTicketsErrorMatchNotFound,
	GetMatchmakingTicketsErrorUserNotFound,
}

func (e GetMatchmakingTicketsError) IsValid() bool {
	switch e {
	case GetMatchmakingTicketsErrorNone, GetMatchmakingTicketsErrorMatchNotFound, GetMatchmakingTicketsErrorUserNotFound:
		return true
	}
	return false
}

func (e GetMatchmakingTicketsError) String() string {
	return string(e)
}

func (e *GetMatchmakingTicketsError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetMatchmakingTicketsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetMatchmakingTicketsError", str)
	}
	return nil
}

func (e GetMatchmakingTicketsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting a matchmaking user.
type GetMatchmakingUserError string

const (
	GetMatchmakingUserErrorNone                                    GetMatchmakingUserError = "NONE"
	GetMatchmakingUserErrorMatchmakingUserIDOrClientUserIDRequired GetMatchmakingUserError = "MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED"
	GetMatchmakingUserErrorNotFound                                GetMatchmakingUserError = "NOT_FOUND"
)

var AllGetMatchmakingUserError = []GetMatchmakingUserError{
	GetMatchmakingUserErrorNone,
	GetMatchmakingUserErrorMatchmakingUserIDOrClientUserIDRequired,
	GetMatchmakingUserErrorNotFound,
}

func (e GetMatchmakingUserError) IsValid() bool {
	switch e {
	case GetMatchmakingUserErrorNone, GetMatchmakingUserErrorMatchmakingUserIDOrClientUserIDRequired, GetMatchmakingUserErrorNotFound:
		return true
	}
	return false
}

func (e GetMatchmakingUserError) String() string {
	return string(e)
}

func (e *GetMatchmakingUserError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetMatchmakingUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetMatchmakingUserError", str)
	}
	return nil
}

func (e GetMatchmakingUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting a record.
type GetRecordError string

const (
	GetRecordErrorNone                   GetRecordError = "NONE"
	GetRecordErrorIDOrNameUserIDRequired GetRecordError = "ID_OR_NAME_USER_ID_REQUIRED"
	GetRecordErrorNotFound               GetRecordError = "NOT_FOUND"
	GetRecordErrorNameTooShort           GetRecordError = "NAME_TOO_SHORT"
	GetRecordErrorNameTooLong            GetRecordError = "NAME_TOO_LONG"
	GetRecordErrorUserIDRequired         GetRecordError = "USER_ID_REQUIRED"
)

var AllGetRecordError = []GetRecordError{
	GetRecordErrorNone,
	GetRecordErrorIDOrNameUserIDRequired,
	GetRecordErrorNotFound,
	GetRecordErrorNameTooShort,
	GetRecordErrorNameTooLong,
	GetRecordErrorUserIDRequired,
}

func (e GetRecordError) IsValid() bool {
	switch e {
	case GetRecordErrorNone, GetRecordErrorIDOrNameUserIDRequired, GetRecordErrorNotFound, GetRecordErrorNameTooShort, GetRecordErrorNameTooLong, GetRecordErrorUserIDRequired:
		return true
	}
	return false
}

func (e GetRecordError) String() string {
	return string(e)
}

func (e *GetRecordError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetRecordError", str)
	}
	return nil
}

func (e GetRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting a list of records.
type GetRecordsError string

const (
	GetRecordsErrorNone         GetRecordsError = "NONE"
	GetRecordsErrorNameTooShort GetRecordsError = "NAME_TOO_SHORT"
	GetRecordsErrorNameTooLong  GetRecordsError = "NAME_TOO_LONG"
)

var AllGetRecordsError = []GetRecordsError{
	GetRecordsErrorNone,
	GetRecordsErrorNameTooShort,
	GetRecordsErrorNameTooLong,
}

func (e GetRecordsError) IsValid() bool {
	switch e {
	case GetRecordsErrorNone, GetRecordsErrorNameTooShort, GetRecordsErrorNameTooLong:
		return true
	}
	return false
}

func (e GetRecordsError) String() string {
	return string(e)
}

func (e *GetRecordsError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetRecordsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetRecordsError", str)
	}
	return nil
}

func (e GetRecordsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting an task.
type GetTaskError string

const (
	GetTaskErrorNone         GetTaskError = "NONE"
	GetTaskErrorIDRequired   GetTaskError = "ID_REQUIRED"
	GetTaskErrorTypeRequired GetTaskError = "TYPE_REQUIRED"
	GetTaskErrorNotFound     GetTaskError = "NOT_FOUND"
)

var AllGetTaskError = []GetTaskError{
	GetTaskErrorNone,
	GetTaskErrorIDRequired,
	GetTaskErrorTypeRequired,
	GetTaskErrorNotFound,
}

func (e GetTaskError) IsValid() bool {
	switch e {
	case GetTaskErrorNone, GetTaskErrorIDRequired, GetTaskErrorTypeRequired, GetTaskErrorNotFound:
		return true
	}
	return false
}

func (e GetTaskError) String() string {
	return string(e)
}

func (e *GetTaskError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTaskError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTaskError", str)
	}
	return nil
}

func (e GetTaskError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting a team.
type GetTeamError string

const (
	GetTeamErrorNone             GetTeamError = "NONE"
	GetTeamErrorNoFieldSpecified GetTeamError = "NO_FIELD_SPECIFIED"
	GetTeamErrorNameTooShort     GetTeamError = "NAME_TOO_SHORT"
	GetTeamErrorNameTooLong      GetTeamError = "NAME_TOO_LONG"
	GetTeamErrorNotFound         GetTeamError = "NOT_FOUND"
)

var AllGetTeamError = []GetTeamError{
	GetTeamErrorNone,
	GetTeamErrorNoFieldSpecified,
	GetTeamErrorNameTooShort,
	GetTeamErrorNameTooLong,
	GetTeamErrorNotFound,
}

func (e GetTeamError) IsValid() bool {
	switch e {
	case GetTeamErrorNone, GetTeamErrorNoFieldSpecified, GetTeamErrorNameTooShort, GetTeamErrorNameTooLong, GetTeamErrorNotFound:
		return true
	}
	return false
}

func (e GetTeamError) String() string {
	return string(e)
}

func (e *GetTeamError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTeamError", str)
	}
	return nil
}

func (e GetTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting a team member.
type GetTeamMemberError string

const (
	GetTeamMemberErrorNone             GetTeamMemberError = "NONE"
	GetTeamMemberErrorNoFieldSpecified GetTeamMemberError = "NO_FIELD_SPECIFIED"
	GetTeamMemberErrorNotFound         GetTeamMemberError = "NOT_FOUND"
)

var AllGetTeamMemberError = []GetTeamMemberError{
	GetTeamMemberErrorNone,
	GetTeamMemberErrorNoFieldSpecified,
	GetTeamMemberErrorNotFound,
}

func (e GetTeamMemberError) IsValid() bool {
	switch e {
	case GetTeamMemberErrorNone, GetTeamMemberErrorNoFieldSpecified, GetTeamMemberErrorNotFound:
		return true
	}
	return false
}

func (e GetTeamMemberError) String() string {
	return string(e)
}

func (e *GetTeamMemberError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTeamMemberError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTeamMemberError", str)
	}
	return nil
}

func (e GetTeamMemberError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting a tournament user.
type GetTournamentUserError string

const (
	GetTournamentUserErrorNone                                 GetTournamentUserError = "NONE"
	GetTournamentUserErrorIDOrTournamentIntervalUserIDRequired GetTournamentUserError = "ID_OR_TOURNAMENT_INTERVAL_USER_ID_REQUIRED"
	GetTournamentUserErrorTournamentNameTooShort               GetTournamentUserError = "TOURNAMENT_NAME_TOO_SHORT"
	GetTournamentUserErrorTournamentNameTooLong                GetTournamentUserError = "TOURNAMENT_NAME_TOO_LONG"
	GetTournamentUserErrorUserIDRequired                       GetTournamentUserError = "USER_ID_REQUIRED"
	GetTournamentUserErrorNotFound                             GetTournamentUserError = "NOT_FOUND"
)

var AllGetTournamentUserError = []GetTournamentUserError{
	GetTournamentUserErrorNone,
	GetTournamentUserErrorIDOrTournamentIntervalUserIDRequired,
	GetTournamentUserErrorTournamentNameTooShort,
	GetTournamentUserErrorTournamentNameTooLong,
	GetTournamentUserErrorUserIDRequired,
	GetTournamentUserErrorNotFound,
}

func (e GetTournamentUserError) IsValid() bool {
	switch e {
	case GetTournamentUserErrorNone, GetTournamentUserErrorIDOrTournamentIntervalUserIDRequired, GetTournamentUserErrorTournamentNameTooShort, GetTournamentUserErrorTournamentNameTooLong, GetTournamentUserErrorUserIDRequired, GetTournamentUserErrorNotFound:
		return true
	}
	return false
}

func (e GetTournamentUserError) String() string {
	return string(e)
}

func (e *GetTournamentUserError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTournamentUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTournamentUserError", str)
	}
	return nil
}

func (e GetTournamentUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when getting a list of tournament users.
type GetTournamentUsersError string

const (
	GetTournamentUsersErrorNone                   GetTournamentUsersError = "NONE"
	GetTournamentUsersErrorTournamentNameTooShort GetTournamentUsersError = "TOURNAMENT_NAME_TOO_SHORT"
	GetTournamentUsersErrorTournamentNameTooLong  GetTournamentUsersError = "TOURNAMENT_NAME_TOO_LONG"
)

var AllGetTournamentUsersError = []GetTournamentUsersError{
	GetTournamentUsersErrorNone,
	GetTournamentUsersErrorTournamentNameTooShort,
	GetTournamentUsersErrorTournamentNameTooLong,
}

func (e GetTournamentUsersError) IsValid() bool {
	switch e {
	case GetTournamentUsersErrorNone, GetTournamentUsersErrorTournamentNameTooShort, GetTournamentUsersErrorTournamentNameTooLong:
		return true
	}
	return false
}

func (e GetTournamentUsersError) String() string {
	return string(e)
}

func (e *GetTournamentUsersError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTournamentUsersError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTournamentUsersError", str)
	}
	return nil
}

func (e GetTournamentUsersError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors related to items.
type ItemError string

const (
	ItemErrorNone         ItemError = "NONE"
	ItemErrorIDRequired   ItemError = "ID_REQUIRED"
	ItemErrorTypeRequired ItemError = "TYPE_REQUIRED"
	ItemErrorNotFound     ItemError = "NOT_FOUND"
)

var AllItemError = []ItemError{
	ItemErrorNone,
	ItemErrorIDRequired,
	ItemErrorTypeRequired,
	ItemErrorNotFound,
}

func (e ItemError) IsValid() bool {
	switch e {
	case ItemErrorNone, ItemErrorIDRequired, ItemErrorTypeRequired, ItemErrorNotFound:
		return true
	}
	return false
}

func (e ItemError) String() string {
	return string(e)
}

func (e *ItemError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemError", str)
	}
	return nil
}

func (e ItemError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when joining a team.
type JoinTeamError string

const (
	JoinTeamErrorNone             JoinTeamError = "NONE"
	JoinTeamErrorNoFieldSpecified JoinTeamError = "NO_FIELD_SPECIFIED"
	JoinTeamErrorNameTooShort     JoinTeamError = "NAME_TOO_SHORT"
	JoinTeamErrorNameTooLong      JoinTeamError = "NAME_TOO_LONG"
	JoinTeamErrorUserIDRequired   JoinTeamError = "USER_ID_REQUIRED"
	JoinTeamErrorDataRequired     JoinTeamError = "DATA_REQUIRED"
	JoinTeamErrorNotFound         JoinTeamError = "NOT_FOUND"
	JoinTeamErrorTeamFull         JoinTeamError = "TEAM_FULL"
	JoinTeamErrorAlreadyInATeam   JoinTeamError = "ALREADY_IN_A_TEAM"
)

var AllJoinTeamError = []JoinTeamError{
	JoinTeamErrorNone,
	JoinTeamErrorNoFieldSpecified,
	JoinTeamErrorNameTooShort,
	JoinTeamErrorNameTooLong,
	JoinTeamErrorUserIDRequired,
	JoinTeamErrorDataRequired,
	JoinTeamErrorNotFound,
	JoinTeamErrorTeamFull,
	JoinTeamErrorAlreadyInATeam,
}

func (e JoinTeamError) IsValid() bool {
	switch e {
	case JoinTeamErrorNone, JoinTeamErrorNoFieldSpecified, JoinTeamErrorNameTooShort, JoinTeamErrorNameTooLong, JoinTeamErrorUserIDRequired, JoinTeamErrorDataRequired, JoinTeamErrorNotFound, JoinTeamErrorTeamFull, JoinTeamErrorAlreadyInATeam:
		return true
	}
	return false
}

func (e JoinTeamError) String() string {
	return string(e)
}

func (e *JoinTeamError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JoinTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JoinTeamError", str)
	}
	return nil
}

func (e JoinTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when leaving a team.
type LeaveTeamError string

const (
	LeaveTeamErrorNone             LeaveTeamError = "NONE"
	LeaveTeamErrorNoFieldSpecified LeaveTeamError = "NO_FIELD_SPECIFIED"
	LeaveTeamErrorNotFound         LeaveTeamError = "NOT_FOUND"
)

var AllLeaveTeamError = []LeaveTeamError{
	LeaveTeamErrorNone,
	LeaveTeamErrorNoFieldSpecified,
	LeaveTeamErrorNotFound,
}

func (e LeaveTeamError) IsValid() bool {
	switch e {
	case LeaveTeamErrorNone, LeaveTeamErrorNoFieldSpecified, LeaveTeamErrorNotFound:
		return true
	}
	return false
}

func (e LeaveTeamError) String() string {
	return string(e)
}

func (e *LeaveTeamError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LeaveTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LeaveTeamError", str)
	}
	return nil
}

func (e LeaveTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible statuses for a match. Pending means it's waiting to be started. Started means it's currently being played. Ended means the match has ended.
type MatchStatus string

const (
	MatchStatusPending MatchStatus = "PENDING"
	MatchStatusStarted MatchStatus = "STARTED"
	MatchStatusEnded   MatchStatus = "ENDED"
)

var AllMatchStatus = []MatchStatus{
	MatchStatusPending,
	MatchStatusStarted,
	MatchStatusEnded,
}

func (e MatchStatus) IsValid() bool {
	switch e {
	case MatchStatusPending, MatchStatusStarted, MatchStatusEnded:
		return true
	}
	return false
}

func (e MatchStatus) String() string {
	return string(e)
}

func (e *MatchStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchStatus", str)
	}
	return nil
}

func (e MatchStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible statuses for a matchmaking ticket. Pending means it's waiting to be matched. Matched means it's matched with other tickets, the match may have started or may not have. Expired means it's no longer valid. Ended means the match has ended.
type MatchmakingTicketStatus string

const (
	MatchmakingTicketStatusPending MatchmakingTicketStatus = "PENDING"
	MatchmakingTicketStatusMatched MatchmakingTicketStatus = "MATCHED"
	MatchmakingTicketStatusExpired MatchmakingTicketStatus = "EXPIRED"
	MatchmakingTicketStatusEnded   MatchmakingTicketStatus = "ENDED"
)

var AllMatchmakingTicketStatus = []MatchmakingTicketStatus{
	MatchmakingTicketStatusPending,
	MatchmakingTicketStatusMatched,
	MatchmakingTicketStatusExpired,
	MatchmakingTicketStatusEnded,
}

func (e MatchmakingTicketStatus) IsValid() bool {
	switch e {
	case MatchmakingTicketStatusPending, MatchmakingTicketStatusMatched, MatchmakingTicketStatusExpired, MatchmakingTicketStatusEnded:
		return true
	}
	return false
}

func (e MatchmakingTicketStatus) String() string {
	return string(e)
}

func (e *MatchmakingTicketStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchmakingTicketStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchmakingTicketStatus", str)
	}
	return nil
}

func (e MatchmakingTicketStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when removing an event result.
type RemoveEventResultError string

const (
	RemoveEventResultErrorNone       RemoveEventResultError = "NONE"
	RemoveEventResultErrorIDRequired RemoveEventResultError = "ID_REQUIRED"
	RemoveEventResultErrorNotFound   RemoveEventResultError = "NOT_FOUND"
	RemoveEventResultErrorEventEnded RemoveEventResultError = "EVENT_ENDED"
)

var AllRemoveEventResultError = []RemoveEventResultError{
	RemoveEventResultErrorNone,
	RemoveEventResultErrorIDRequired,
	RemoveEventResultErrorNotFound,
	RemoveEventResultErrorEventEnded,
}

func (e RemoveEventResultError) IsValid() bool {
	switch e {
	case RemoveEventResultErrorNone, RemoveEventResultErrorIDRequired, RemoveEventResultErrorNotFound, RemoveEventResultErrorEventEnded:
		return true
	}
	return false
}

func (e RemoveEventResultError) String() string {
	return string(e)
}

func (e *RemoveEventResultError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemoveEventResultError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemoveEventResultError", str)
	}
	return nil
}

func (e RemoveEventResultError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when searching for teams.
type SearchTeamsError string

const (
	SearchTeamsErrorNone          SearchTeamsError = "NONE"
	SearchTeamsErrorQueryTooShort SearchTeamsError = "QUERY_TOO_SHORT"
	SearchTeamsErrorQueryTooLong  SearchTeamsError = "QUERY_TOO_LONG"
)

var AllSearchTeamsError = []SearchTeamsError{
	SearchTeamsErrorNone,
	SearchTeamsErrorQueryTooShort,
	SearchTeamsErrorQueryTooLong,
}

func (e SearchTeamsError) IsValid() bool {
	switch e {
	case SearchTeamsErrorNone, SearchTeamsErrorQueryTooShort, SearchTeamsErrorQueryTooLong:
		return true
	}
	return false
}

func (e SearchTeamsError) String() string {
	return string(e)
}

func (e *SearchTeamsError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchTeamsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchTeamsError", str)
	}
	return nil
}

func (e SearchTeamsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when setting the private server of the match.
type SetMatchPrivateServerError string

const (
	SetMatchPrivateServerErrorNone                                    SetMatchPrivateServerError = "NONE"
	SetMatchPrivateServerErrorIDOrMatchmakingTicketRequired           SetMatchPrivateServerError = "ID_OR_MATCHMAKING_TICKET_REQUIRED"
	SetMatchPrivateServerErrorMatchmakingTicketIDOrUserRequired       SetMatchPrivateServerError = "MATCHMAKING_TICKET_ID_OR_USER_REQUIRED"
	SetMatchPrivateServerErrorMatchmakingUserIDOrClientUserIDRequired SetMatchPrivateServerError = "MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED"
	SetMatchPrivateServerErrorPrivateServerIDRequired                 SetMatchPrivateServerError = "PRIVATE_SERVER_ID_REQUIRED"
	SetMatchPrivateServerErrorPrivateServerAlreadySet                 SetMatchPrivateServerError = "PRIVATE_SERVER_ALREADY_SET"
	SetMatchPrivateServerErrorNotFound                                SetMatchPrivateServerError = "NOT_FOUND"
)

var AllSetMatchPrivateServerError = []SetMatchPrivateServerError{
	SetMatchPrivateServerErrorNone,
	SetMatchPrivateServerErrorIDOrMatchmakingTicketRequired,
	SetMatchPrivateServerErrorMatchmakingTicketIDOrUserRequired,
	SetMatchPrivateServerErrorMatchmakingUserIDOrClientUserIDRequired,
	SetMatchPrivateServerErrorPrivateServerIDRequired,
	SetMatchPrivateServerErrorPrivateServerAlreadySet,
	SetMatchPrivateServerErrorNotFound,
}

func (e SetMatchPrivateServerError) IsValid() bool {
	switch e {
	case SetMatchPrivateServerErrorNone, SetMatchPrivateServerErrorIDOrMatchmakingTicketRequired, SetMatchPrivateServerErrorMatchmakingTicketIDOrUserRequired, SetMatchPrivateServerErrorMatchmakingUserIDOrClientUserIDRequired, SetMatchPrivateServerErrorPrivateServerIDRequired, SetMatchPrivateServerErrorPrivateServerAlreadySet, SetMatchPrivateServerErrorNotFound:
		return true
	}
	return false
}

func (e SetMatchPrivateServerError) String() string {
	return string(e)
}

func (e *SetMatchPrivateServerError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetMatchPrivateServerError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetMatchPrivateServerError", str)
	}
	return nil
}

func (e SetMatchPrivateServerError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when starting a match.
type StartMatchError string

const (
	StartMatchErrorNone                                    StartMatchError = "NONE"
	StartMatchErrorIDOrMatchmakingTicketRequired           StartMatchError = "ID_OR_MATCHMAKING_TICKET_REQUIRED"
	StartMatchErrorMatchmakingTicketIDOrUserRequired       StartMatchError = "MATCHMAKING_TICKET_ID_OR_USER_REQUIRED"
	StartMatchErrorMatchmakingUserIDOrClientUserIDRequired StartMatchError = "MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED"
	StartMatchErrorStartTimeRequired                       StartMatchError = "START_TIME_REQUIRED"
	StartMatchErrorInvalidStartTime                        StartMatchError = "INVALID_START_TIME"
	StartMatchErrorStartTimeTooSoon                        StartMatchError = "START_TIME_TOO_SOON"
	StartMatchErrorNotFound                                StartMatchError = "NOT_FOUND"
	StartMatchErrorMatchDoesNotHaveArena                   StartMatchError = "MATCH_DOES_NOT_HAVE_ARENA"
	StartMatchErrorNotEnoughPlayersToStart                 StartMatchError = "NOT_ENOUGH_PLAYERS_TO_START"
	StartMatchErrorAlreadyStarted                          StartMatchError = "ALREADY_STARTED"
)

var AllStartMatchError = []StartMatchError{
	StartMatchErrorNone,
	StartMatchErrorIDOrMatchmakingTicketRequired,
	StartMatchErrorMatchmakingTicketIDOrUserRequired,
	StartMatchErrorMatchmakingUserIDOrClientUserIDRequired,
	StartMatchErrorStartTimeRequired,
	StartMatchErrorInvalidStartTime,
	StartMatchErrorStartTimeTooSoon,
	StartMatchErrorNotFound,
	StartMatchErrorMatchDoesNotHaveArena,
	StartMatchErrorNotEnoughPlayersToStart,
	StartMatchErrorAlreadyStarted,
}

func (e StartMatchError) IsValid() bool {
	switch e {
	case StartMatchErrorNone, StartMatchErrorIDOrMatchmakingTicketRequired, StartMatchErrorMatchmakingTicketIDOrUserRequired, StartMatchErrorMatchmakingUserIDOrClientUserIDRequired, StartMatchErrorStartTimeRequired, StartMatchErrorInvalidStartTime, StartMatchErrorStartTimeTooSoon, StartMatchErrorNotFound, StartMatchErrorMatchDoesNotHaveArena, StartMatchErrorNotEnoughPlayersToStart, StartMatchErrorAlreadyStarted:
		return true
	}
	return false
}

func (e StartMatchError) String() string {
	return string(e)
}

func (e *StartMatchError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StartMatchError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StartMatchError", str)
	}
	return nil
}

func (e StartMatchError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors related to tasks.
type TaskError string

const (
	TaskErrorNone         TaskError = "NONE"
	TaskErrorIDRequired   TaskError = "ID_REQUIRED"
	TaskErrorTypeRequired TaskError = "TYPE_REQUIRED"
	TaskErrorNotFound     TaskError = "NOT_FOUND"
)

var AllTaskError = []TaskError{
	TaskErrorNone,
	TaskErrorIDRequired,
	TaskErrorTypeRequired,
	TaskErrorNotFound,
}

func (e TaskError) IsValid() bool {
	switch e {
	case TaskErrorNone, TaskErrorIDRequired, TaskErrorTypeRequired, TaskErrorNotFound:
		return true
	}
	return false
}

func (e TaskError) String() string {
	return string(e)
}

func (e *TaskError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskError", str)
	}
	return nil
}

func (e TaskError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when deleting a team.
type TeamError string

const (
	TeamErrorNone             TeamError = "NONE"
	TeamErrorNoFieldSpecified TeamError = "NO_FIELD_SPECIFIED"
	TeamErrorNameTooShort     TeamError = "NAME_TOO_SHORT"
	TeamErrorNameTooLong      TeamError = "NAME_TOO_LONG"
	TeamErrorNotFound         TeamError = "NOT_FOUND"
)

var AllTeamError = []TeamError{
	TeamErrorNone,
	TeamErrorNoFieldSpecified,
	TeamErrorNameTooShort,
	TeamErrorNameTooLong,
	TeamErrorNotFound,
}

func (e TeamError) IsValid() bool {
	switch e {
	case TeamErrorNone, TeamErrorNoFieldSpecified, TeamErrorNameTooShort, TeamErrorNameTooLong, TeamErrorNotFound:
		return true
	}
	return false
}

func (e TeamError) String() string {
	return string(e)
}

func (e *TeamError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamError", str)
	}
	return nil
}

func (e TeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Different intervals for tournaments. The tournament interval is used to determine how often a tournament is reset.
type TournamentInterval string

const (
	TournamentIntervalDaily     TournamentInterval = "DAILY"
	TournamentIntervalWeekly    TournamentInterval = "WEEKLY"
	TournamentIntervalMonthly   TournamentInterval = "MONTHLY"
	TournamentIntervalUnlimited TournamentInterval = "UNLIMITED"
)

var AllTournamentInterval = []TournamentInterval{
	TournamentIntervalDaily,
	TournamentIntervalWeekly,
	TournamentIntervalMonthly,
	TournamentIntervalUnlimited,
}

func (e TournamentInterval) IsValid() bool {
	switch e {
	case TournamentIntervalDaily, TournamentIntervalWeekly, TournamentIntervalMonthly, TournamentIntervalUnlimited:
		return true
	}
	return false
}

func (e TournamentInterval) String() string {
	return string(e)
}

func (e *TournamentInterval) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TournamentInterval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TournamentInterval", str)
	}
	return nil
}

func (e TournamentInterval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when requesting a tournament user without returning object.
type TournamentUserError string

const (
	TournamentUserErrorNone                                 TournamentUserError = "NONE"
	TournamentUserErrorIDOrTournamentIntervalUserIDRequired TournamentUserError = "ID_OR_TOURNAMENT_INTERVAL_USER_ID_REQUIRED"
	TournamentUserErrorTournamentNameTooShort               TournamentUserError = "TOURNAMENT_NAME_TOO_SHORT"
	TournamentUserErrorTournamentNameTooLong                TournamentUserError = "TOURNAMENT_NAME_TOO_LONG"
	TournamentUserErrorUserIDRequired                       TournamentUserError = "USER_ID_REQUIRED"
	TournamentUserErrorNotFound                             TournamentUserError = "NOT_FOUND"
)

var AllTournamentUserError = []TournamentUserError{
	TournamentUserErrorNone,
	TournamentUserErrorIDOrTournamentIntervalUserIDRequired,
	TournamentUserErrorTournamentNameTooShort,
	TournamentUserErrorTournamentNameTooLong,
	TournamentUserErrorUserIDRequired,
	TournamentUserErrorNotFound,
}

func (e TournamentUserError) IsValid() bool {
	switch e {
	case TournamentUserErrorNone, TournamentUserErrorIDOrTournamentIntervalUserIDRequired, TournamentUserErrorTournamentNameTooShort, TournamentUserErrorTournamentNameTooLong, TournamentUserErrorUserIDRequired, TournamentUserErrorNotFound:
		return true
	}
	return false
}

func (e TournamentUserError) String() string {
	return string(e)
}

func (e *TournamentUserError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TournamentUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TournamentUserError", str)
	}
	return nil
}

func (e TournamentUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating an arena.
type UpdateArenaError string

const (
	UpdateArenaErrorNone                                             UpdateArenaError = "NONE"
	UpdateArenaErrorNameTooShort                                     UpdateArenaError = "NAME_TOO_SHORT"
	UpdateArenaErrorNameTooLong                                      UpdateArenaError = "NAME_TOO_LONG"
	UpdateArenaErrorIDOrNameRequired                                 UpdateArenaError = "ID_OR_NAME_REQUIRED"
	UpdateArenaErrorNoUpdateSpecified                                UpdateArenaError = "NO_UPDATE_SPECIFIED"
	UpdateArenaErrorIfCapacityChangedMustChangeAllPlayers            UpdateArenaError = "IF_CAPACITY_CHANGED_MUST_CHANGE_ALL_PLAYERS"
	UpdateArenaErrorMinPlayersCannotBeGreaterThanMaxPlayers          UpdateArenaError = "MIN_PLAYERS_CANNOT_BE_GREATER_THAN_MAX_PLAYERS"
	UpdateArenaErrorMaxPlayersPerTicketCannotBeLessThanMinPlayers    UpdateArenaError = "MAX_PLAYERS_PER_TICKET_CANNOT_BE_LESS_THAN_MIN_PLAYERS"
	UpdateArenaErrorMaxPlayersPerTicketCannotBeGreaterThanMaxPlayers UpdateArenaError = "MAX_PLAYERS_PER_TICKET_CANNOT_BE_GREATER_THAN_MAX_PLAYERS"
	UpdateArenaErrorArenaCurrentlyInUse                              UpdateArenaError = "ARENA_CURRENTLY_IN_USE"
	UpdateArenaErrorNotFound                                         UpdateArenaError = "NOT_FOUND"
)

var AllUpdateArenaError = []UpdateArenaError{
	UpdateArenaErrorNone,
	UpdateArenaErrorNameTooShort,
	UpdateArenaErrorNameTooLong,
	UpdateArenaErrorIDOrNameRequired,
	UpdateArenaErrorNoUpdateSpecified,
	UpdateArenaErrorIfCapacityChangedMustChangeAllPlayers,
	UpdateArenaErrorMinPlayersCannotBeGreaterThanMaxPlayers,
	UpdateArenaErrorMaxPlayersPerTicketCannotBeLessThanMinPlayers,
	UpdateArenaErrorMaxPlayersPerTicketCannotBeGreaterThanMaxPlayers,
	UpdateArenaErrorArenaCurrentlyInUse,
	UpdateArenaErrorNotFound,
}

func (e UpdateArenaError) IsValid() bool {
	switch e {
	case UpdateArenaErrorNone, UpdateArenaErrorNameTooShort, UpdateArenaErrorNameTooLong, UpdateArenaErrorIDOrNameRequired, UpdateArenaErrorNoUpdateSpecified, UpdateArenaErrorIfCapacityChangedMustChangeAllPlayers, UpdateArenaErrorMinPlayersCannotBeGreaterThanMaxPlayers, UpdateArenaErrorMaxPlayersPerTicketCannotBeLessThanMinPlayers, UpdateArenaErrorMaxPlayersPerTicketCannotBeGreaterThanMaxPlayers, UpdateArenaErrorArenaCurrentlyInUse, UpdateArenaErrorNotFound:
		return true
	}
	return false
}

func (e UpdateArenaError) String() string {
	return string(e)
}

func (e *UpdateArenaError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateArenaError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateArenaError", str)
	}
	return nil
}

func (e UpdateArenaError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating an event.
type UpdateEventError string

const (
	UpdateEventErrorNone             UpdateEventError = "NONE"
	UpdateEventErrorNameTooShort     UpdateEventError = "NAME_TOO_SHORT"
	UpdateEventErrorNameTooLong      UpdateEventError = "NAME_TOO_LONG"
	UpdateEventErrorIDOrNameRequired UpdateEventError = "ID_OR_NAME_REQUIRED"
	UpdateEventErrorDataRequired     UpdateEventError = "DATA_REQUIRED"
	UpdateEventErrorNotFound         UpdateEventError = "NOT_FOUND"
)

var AllUpdateEventError = []UpdateEventError{
	UpdateEventErrorNone,
	UpdateEventErrorNameTooShort,
	UpdateEventErrorNameTooLong,
	UpdateEventErrorIDOrNameRequired,
	UpdateEventErrorDataRequired,
	UpdateEventErrorNotFound,
}

func (e UpdateEventError) IsValid() bool {
	switch e {
	case UpdateEventErrorNone, UpdateEventErrorNameTooShort, UpdateEventErrorNameTooLong, UpdateEventErrorIDOrNameRequired, UpdateEventErrorDataRequired, UpdateEventErrorNotFound:
		return true
	}
	return false
}

func (e UpdateEventError) String() string {
	return string(e)
}

func (e *UpdateEventError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateEventError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateEventError", str)
	}
	return nil
}

func (e UpdateEventError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating an event round.
type UpdateEventRoundError string

const (
	UpdateEventRoundErrorNone                   UpdateEventRoundError = "NONE"
	UpdateEventRoundErrorNameTooShort           UpdateEventRoundError = "NAME_TOO_SHORT"
	UpdateEventRoundErrorNameTooLong            UpdateEventRoundError = "NAME_TOO_LONG"
	UpdateEventRoundErrorIDOrNameRequired       UpdateEventRoundError = "ID_OR_NAME_REQUIRED"
	UpdateEventRoundErrorEventRoundOrIDRequired UpdateEventRoundError = "EVENT_ROUND_OR_ID_REQUIRED"
	UpdateEventRoundErrorNoUpdateSpecified      UpdateEventRoundError = "NO_UPDATE_SPECIFIED"
	UpdateEventRoundErrorNotFound               UpdateEventRoundError = "NOT_FOUND"
)

var AllUpdateEventRoundError = []UpdateEventRoundError{
	UpdateEventRoundErrorNone,
	UpdateEventRoundErrorNameTooShort,
	UpdateEventRoundErrorNameTooLong,
	UpdateEventRoundErrorIDOrNameRequired,
	UpdateEventRoundErrorEventRoundOrIDRequired,
	UpdateEventRoundErrorNoUpdateSpecified,
	UpdateEventRoundErrorNotFound,
}

func (e UpdateEventRoundError) IsValid() bool {
	switch e {
	case UpdateEventRoundErrorNone, UpdateEventRoundErrorNameTooShort, UpdateEventRoundErrorNameTooLong, UpdateEventRoundErrorIDOrNameRequired, UpdateEventRoundErrorEventRoundOrIDRequired, UpdateEventRoundErrorNoUpdateSpecified, UpdateEventRoundErrorNotFound:
		return true
	}
	return false
}

func (e UpdateEventRoundError) String() string {
	return string(e)
}

func (e *UpdateEventRoundError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateEventRoundError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateEventRoundError", str)
	}
	return nil
}

func (e UpdateEventRoundError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating an event user.
type UpdateEventUserError string

const (
	UpdateEventUserErrorNone                  UpdateEventUserError = "NONE"
	UpdateEventUserErrorNameTooShort          UpdateEventUserError = "NAME_TOO_SHORT"
	UpdateEventUserErrorNameTooLong           UpdateEventUserError = "NAME_TOO_LONG"
	UpdateEventUserErrorIDOrNameRequired      UpdateEventUserError = "ID_OR_NAME_REQUIRED"
	UpdateEventUserErrorUserIDRequired        UpdateEventUserError = "USER_ID_REQUIRED"
	UpdateEventUserErrorEventUserOrIDRequired UpdateEventUserError = "EVENT_USER_OR_ID_REQUIRED"
	UpdateEventUserErrorDataRequired          UpdateEventUserError = "DATA_REQUIRED"
	UpdateEventUserErrorNotFound              UpdateEventUserError = "NOT_FOUND"
)

var AllUpdateEventUserError = []UpdateEventUserError{
	UpdateEventUserErrorNone,
	UpdateEventUserErrorNameTooShort,
	UpdateEventUserErrorNameTooLong,
	UpdateEventUserErrorIDOrNameRequired,
	UpdateEventUserErrorUserIDRequired,
	UpdateEventUserErrorEventUserOrIDRequired,
	UpdateEventUserErrorDataRequired,
	UpdateEventUserErrorNotFound,
}

func (e UpdateEventUserError) IsValid() bool {
	switch e {
	case UpdateEventUserErrorNone, UpdateEventUserErrorNameTooShort, UpdateEventUserErrorNameTooLong, UpdateEventUserErrorIDOrNameRequired, UpdateEventUserErrorUserIDRequired, UpdateEventUserErrorEventUserOrIDRequired, UpdateEventUserErrorDataRequired, UpdateEventUserErrorNotFound:
		return true
	}
	return false
}

func (e UpdateEventUserError) String() string {
	return string(e)
}

func (e *UpdateEventUserError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateEventUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateEventUserError", str)
	}
	return nil
}

func (e UpdateEventUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating an item.
type UpdateItemError string

const (
	UpdateItemErrorNone         UpdateItemError = "NONE"
	UpdateItemErrorIDRequired   UpdateItemError = "ID_REQUIRED"
	UpdateItemErrorTypeRequired UpdateItemError = "TYPE_REQUIRED"
	UpdateItemErrorNotFound     UpdateItemError = "NOT_FOUND"
	UpdateItemErrorDataRequired UpdateItemError = "DATA_REQUIRED"
)

var AllUpdateItemError = []UpdateItemError{
	UpdateItemErrorNone,
	UpdateItemErrorIDRequired,
	UpdateItemErrorTypeRequired,
	UpdateItemErrorNotFound,
	UpdateItemErrorDataRequired,
}

func (e UpdateItemError) IsValid() bool {
	switch e {
	case UpdateItemErrorNone, UpdateItemErrorIDRequired, UpdateItemErrorTypeRequired, UpdateItemErrorNotFound, UpdateItemErrorDataRequired:
		return true
	}
	return false
}

func (e UpdateItemError) String() string {
	return string(e)
}

func (e *UpdateItemError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateItemError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateItemError", str)
	}
	return nil
}

func (e UpdateItemError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating a match.
type UpdateMatchError string

const (
	UpdateMatchErrorNone                                    UpdateMatchError = "NONE"
	UpdateMatchErrorIDOrMatchmakingTicketRequired           UpdateMatchError = "ID_OR_MATCHMAKING_TICKET_REQUIRED"
	UpdateMatchErrorMatchmakingTicketIDOrUserRequired       UpdateMatchError = "MATCHMAKING_TICKET_ID_OR_USER_REQUIRED"
	UpdateMatchErrorMatchmakingUserIDOrClientUserIDRequired UpdateMatchError = "MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED"
	UpdateMatchErrorDataRequired                            UpdateMatchError = "DATA_REQUIRED"
	UpdateMatchErrorNotFound                                UpdateMatchError = "NOT_FOUND"
)

var AllUpdateMatchError = []UpdateMatchError{
	UpdateMatchErrorNone,
	UpdateMatchErrorIDOrMatchmakingTicketRequired,
	UpdateMatchErrorMatchmakingTicketIDOrUserRequired,
	UpdateMatchErrorMatchmakingUserIDOrClientUserIDRequired,
	UpdateMatchErrorDataRequired,
	UpdateMatchErrorNotFound,
}

func (e UpdateMatchError) IsValid() bool {
	switch e {
	case UpdateMatchErrorNone, UpdateMatchErrorIDOrMatchmakingTicketRequired, UpdateMatchErrorMatchmakingTicketIDOrUserRequired, UpdateMatchErrorMatchmakingUserIDOrClientUserIDRequired, UpdateMatchErrorDataRequired, UpdateMatchErrorNotFound:
		return true
	}
	return false
}

func (e UpdateMatchError) String() string {
	return string(e)
}

func (e *UpdateMatchError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateMatchError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateMatchError", str)
	}
	return nil
}

func (e UpdateMatchError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating a matchmaking ticket.
type UpdateMatchmakingTicketError string

const (
	UpdateMatchmakingTicketErrorNone                                    UpdateMatchmakingTicketError = "NONE"
	UpdateMatchmakingTicketErrorTicketIDOrMatchmakingUserRequired       UpdateMatchmakingTicketError = "TICKET_ID_OR_MATCHMAKING_USER_REQUIRED"
	UpdateMatchmakingTicketErrorMatchmakingUserIDOrClientUserIDRequired UpdateMatchmakingTicketError = "MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED"
	UpdateMatchmakingTicketErrorDataRequired                            UpdateMatchmakingTicketError = "DATA_REQUIRED"
	UpdateMatchmakingTicketErrorNotFound                                UpdateMatchmakingTicketError = "NOT_FOUND"
)

var AllUpdateMatchmakingTicketError = []UpdateMatchmakingTicketError{
	UpdateMatchmakingTicketErrorNone,
	UpdateMatchmakingTicketErrorTicketIDOrMatchmakingUserRequired,
	UpdateMatchmakingTicketErrorMatchmakingUserIDOrClientUserIDRequired,
	UpdateMatchmakingTicketErrorDataRequired,
	UpdateMatchmakingTicketErrorNotFound,
}

func (e UpdateMatchmakingTicketError) IsValid() bool {
	switch e {
	case UpdateMatchmakingTicketErrorNone, UpdateMatchmakingTicketErrorTicketIDOrMatchmakingUserRequired, UpdateMatchmakingTicketErrorMatchmakingUserIDOrClientUserIDRequired, UpdateMatchmakingTicketErrorDataRequired, UpdateMatchmakingTicketErrorNotFound:
		return true
	}
	return false
}

func (e UpdateMatchmakingTicketError) String() string {
	return string(e)
}

func (e *UpdateMatchmakingTicketError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateMatchmakingTicketError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateMatchmakingTicketError", str)
	}
	return nil
}

func (e UpdateMatchmakingTicketError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating a matchmaking user.
type UpdateMatchmakingUserError string

const (
	UpdateMatchmakingUserErrorNone                                    UpdateMatchmakingUserError = "NONE"
	UpdateMatchmakingUserErrorMatchmakingUserIDOrClientUserIDRequired UpdateMatchmakingUserError = "MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED"
	UpdateMatchmakingUserErrorDataRequired                            UpdateMatchmakingUserError = "DATA_REQUIRED"
	UpdateMatchmakingUserErrorNotFound                                UpdateMatchmakingUserError = "NOT_FOUND"
)

var AllUpdateMatchmakingUserError = []UpdateMatchmakingUserError{
	UpdateMatchmakingUserErrorNone,
	UpdateMatchmakingUserErrorMatchmakingUserIDOrClientUserIDRequired,
	UpdateMatchmakingUserErrorDataRequired,
	UpdateMatchmakingUserErrorNotFound,
}

func (e UpdateMatchmakingUserError) IsValid() bool {
	switch e {
	case UpdateMatchmakingUserErrorNone, UpdateMatchmakingUserErrorMatchmakingUserIDOrClientUserIDRequired, UpdateMatchmakingUserErrorDataRequired, UpdateMatchmakingUserErrorNotFound:
		return true
	}
	return false
}

func (e UpdateMatchmakingUserError) String() string {
	return string(e)
}

func (e *UpdateMatchmakingUserError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateMatchmakingUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateMatchmakingUserError", str)
	}
	return nil
}

func (e UpdateMatchmakingUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating a record.
type UpdateRecordError string

const (
	UpdateRecordErrorNone                   UpdateRecordError = "NONE"
	UpdateRecordErrorIDOrNameUserIDRequired UpdateRecordError = "ID_OR_NAME_USER_ID_REQUIRED"
	UpdateRecordErrorNotFound               UpdateRecordError = "NOT_FOUND"
	UpdateRecordErrorNameTooShort           UpdateRecordError = "NAME_TOO_SHORT"
	UpdateRecordErrorNameTooLong            UpdateRecordError = "NAME_TOO_LONG"
	UpdateRecordErrorUserIDRequired         UpdateRecordError = "USER_ID_REQUIRED"
	UpdateRecordErrorNoUpdateSpecified      UpdateRecordError = "NO_UPDATE_SPECIFIED"
)

var AllUpdateRecordError = []UpdateRecordError{
	UpdateRecordErrorNone,
	UpdateRecordErrorIDOrNameUserIDRequired,
	UpdateRecordErrorNotFound,
	UpdateRecordErrorNameTooShort,
	UpdateRecordErrorNameTooLong,
	UpdateRecordErrorUserIDRequired,
	UpdateRecordErrorNoUpdateSpecified,
}

func (e UpdateRecordError) IsValid() bool {
	switch e {
	case UpdateRecordErrorNone, UpdateRecordErrorIDOrNameUserIDRequired, UpdateRecordErrorNotFound, UpdateRecordErrorNameTooShort, UpdateRecordErrorNameTooLong, UpdateRecordErrorUserIDRequired, UpdateRecordErrorNoUpdateSpecified:
		return true
	}
	return false
}

func (e UpdateRecordError) String() string {
	return string(e)
}

func (e *UpdateRecordError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateRecordError", str)
	}
	return nil
}

func (e UpdateRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating an task.
type UpdateTaskError string

const (
	UpdateTaskErrorNone         UpdateTaskError = "NONE"
	UpdateTaskErrorIDRequired   UpdateTaskError = "ID_REQUIRED"
	UpdateTaskErrorTypeRequired UpdateTaskError = "TYPE_REQUIRED"
	UpdateTaskErrorNotFound     UpdateTaskError = "NOT_FOUND"
	UpdateTaskErrorDataRequired UpdateTaskError = "DATA_REQUIRED"
)

var AllUpdateTaskError = []UpdateTaskError{
	UpdateTaskErrorNone,
	UpdateTaskErrorIDRequired,
	UpdateTaskErrorTypeRequired,
	UpdateTaskErrorNotFound,
	UpdateTaskErrorDataRequired,
}

func (e UpdateTaskError) IsValid() bool {
	switch e {
	case UpdateTaskErrorNone, UpdateTaskErrorIDRequired, UpdateTaskErrorTypeRequired, UpdateTaskErrorNotFound, UpdateTaskErrorDataRequired:
		return true
	}
	return false
}

func (e UpdateTaskError) String() string {
	return string(e)
}

func (e *UpdateTaskError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateTaskError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateTaskError", str)
	}
	return nil
}

func (e UpdateTaskError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating a team.
type UpdateTeamError string

const (
	UpdateTeamErrorNone                       UpdateTeamError = "NONE"
	UpdateTeamErrorNoFieldSpecified           UpdateTeamError = "NO_FIELD_SPECIFIED"
	UpdateTeamErrorNameTooShort               UpdateTeamError = "NAME_TOO_SHORT"
	UpdateTeamErrorNameTooLong                UpdateTeamError = "NAME_TOO_LONG"
	UpdateTeamErrorNoUpdateSpecified          UpdateTeamError = "NO_UPDATE_SPECIFIED"
	UpdateTeamErrorIncrementScoreNotSpecified UpdateTeamError = "INCREMENT_SCORE_NOT_SPECIFIED"
	UpdateTeamErrorNotFound                   UpdateTeamError = "NOT_FOUND"
)

var AllUpdateTeamError = []UpdateTeamError{
	UpdateTeamErrorNone,
	UpdateTeamErrorNoFieldSpecified,
	UpdateTeamErrorNameTooShort,
	UpdateTeamErrorNameTooLong,
	UpdateTeamErrorNoUpdateSpecified,
	UpdateTeamErrorIncrementScoreNotSpecified,
	UpdateTeamErrorNotFound,
}

func (e UpdateTeamError) IsValid() bool {
	switch e {
	case UpdateTeamErrorNone, UpdateTeamErrorNoFieldSpecified, UpdateTeamErrorNameTooShort, UpdateTeamErrorNameTooLong, UpdateTeamErrorNoUpdateSpecified, UpdateTeamErrorIncrementScoreNotSpecified, UpdateTeamErrorNotFound:
		return true
	}
	return false
}

func (e UpdateTeamError) String() string {
	return string(e)
}

func (e *UpdateTeamError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateTeamError", str)
	}
	return nil
}

func (e UpdateTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating a team member.
type UpdateTeamMemberError string

const (
	UpdateTeamMemberErrorNone             UpdateTeamMemberError = "NONE"
	UpdateTeamMemberErrorNoFieldSpecified UpdateTeamMemberError = "NO_FIELD_SPECIFIED"
	UpdateTeamMemberErrorDataRequired     UpdateTeamMemberError = "DATA_REQUIRED"
	UpdateTeamMemberErrorNotFound         UpdateTeamMemberError = "NOT_FOUND"
)

var AllUpdateTeamMemberError = []UpdateTeamMemberError{
	UpdateTeamMemberErrorNone,
	UpdateTeamMemberErrorNoFieldSpecified,
	UpdateTeamMemberErrorDataRequired,
	UpdateTeamMemberErrorNotFound,
}

func (e UpdateTeamMemberError) IsValid() bool {
	switch e {
	case UpdateTeamMemberErrorNone, UpdateTeamMemberErrorNoFieldSpecified, UpdateTeamMemberErrorDataRequired, UpdateTeamMemberErrorNotFound:
		return true
	}
	return false
}

func (e UpdateTeamMemberError) String() string {
	return string(e)
}

func (e *UpdateTeamMemberError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateTeamMemberError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateTeamMemberError", str)
	}
	return nil
}

func (e UpdateTeamMemberError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when updating a tournament user.
type UpdateTournamentUserError string

const (
	UpdateTournamentUserErrorNone                                 UpdateTournamentUserError = "NONE"
	UpdateTournamentUserErrorIDOrTournamentIntervalUserIDRequired UpdateTournamentUserError = "ID_OR_TOURNAMENT_INTERVAL_USER_ID_REQUIRED"
	UpdateTournamentUserErrorTournamentNameTooShort               UpdateTournamentUserError = "TOURNAMENT_NAME_TOO_SHORT"
	UpdateTournamentUserErrorTournamentNameTooLong                UpdateTournamentUserError = "TOURNAMENT_NAME_TOO_LONG"
	UpdateTournamentUserErrorUserIDRequired                       UpdateTournamentUserError = "USER_ID_REQUIRED"
	UpdateTournamentUserErrorNotFound                             UpdateTournamentUserError = "NOT_FOUND"
	UpdateTournamentUserErrorNoUpdateSpecified                    UpdateTournamentUserError = "NO_UPDATE_SPECIFIED"
	UpdateTournamentUserErrorIncrementScoreNotSpecified           UpdateTournamentUserError = "INCREMENT_SCORE_NOT_SPECIFIED"
)

var AllUpdateTournamentUserError = []UpdateTournamentUserError{
	UpdateTournamentUserErrorNone,
	UpdateTournamentUserErrorIDOrTournamentIntervalUserIDRequired,
	UpdateTournamentUserErrorTournamentNameTooShort,
	UpdateTournamentUserErrorTournamentNameTooLong,
	UpdateTournamentUserErrorUserIDRequired,
	UpdateTournamentUserErrorNotFound,
	UpdateTournamentUserErrorNoUpdateSpecified,
	UpdateTournamentUserErrorIncrementScoreNotSpecified,
}

func (e UpdateTournamentUserError) IsValid() bool {
	switch e {
	case UpdateTournamentUserErrorNone, UpdateTournamentUserErrorIDOrTournamentIntervalUserIDRequired, UpdateTournamentUserErrorTournamentNameTooShort, UpdateTournamentUserErrorTournamentNameTooLong, UpdateTournamentUserErrorUserIDRequired, UpdateTournamentUserErrorNotFound, UpdateTournamentUserErrorNoUpdateSpecified, UpdateTournamentUserErrorIncrementScoreNotSpecified:
		return true
	}
	return false
}

func (e UpdateTournamentUserError) String() string {
	return string(e)
}

func (e *UpdateTournamentUserError) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateTournamentUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateTournamentUserError", str)
	}
	return nil
}

func (e UpdateTournamentUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
