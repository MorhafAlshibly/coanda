// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"

	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

type CreateItemRequest struct {
	Type     string                 `json:"type"`
	Data     *structpb.Struct       `json:"data"`
	ExpireAt *timestamppb.Timestamp `json:"expireAt,omitempty"`
}

type CreateItemResponse struct {
	Success bool            `json:"success"`
	Item    *Item           `json:"item"`
	Error   CreateItemError `json:"error"`
}

type CreateRecordRequest struct {
	Name   string           `json:"name"`
	UserID uint64           `json:"userId"`
	Record uint64           `json:"record"`
	Data   *structpb.Struct `json:"data"`
}

type CreateRecordResponse struct {
	Success bool              `json:"success"`
	Error   CreateRecordError `json:"error"`
}

type CreateTeamRequest struct {
	Name      string           `json:"name"`
	Owner     uint64           `json:"owner"`
	Score     *int64           `json:"score,omitempty"`
	Data      *structpb.Struct `json:"data"`
	OwnerData *structpb.Struct `json:"ownerData"`
}

type CreateTeamResponse struct {
	Success bool            `json:"success"`
	Error   CreateTeamError `json:"error"`
}

type DeleteRecordResponse struct {
	Success bool              `json:"success"`
	Error   DeleteRecordError `json:"error"`
}

type GetItemRequest struct {
	ID   string `json:"id"`
	Type string `json:"type"`
}

type GetItemResponse struct {
	Success bool         `json:"success"`
	Item    *Item        `json:"item"`
	Error   GetItemError `json:"error"`
}

type GetItemsRequest struct {
	Type            *string `json:"type,omitempty"`
	Max             *uint32 `json:"max,omitempty"`
	LastEvaluatedID *string `json:"lastEvaluatedId,omitempty"`
}

type GetItemsResponse struct {
	Success bool          `json:"success"`
	Items   []*Item       `json:"items"`
	Error   GetItemsError `json:"error"`
}

type GetRecordResponse struct {
	Success bool           `json:"success"`
	Record  *Record        `json:"record"`
	Error   GetRecordError `json:"error"`
}

type GetRecordsRequest struct {
	Name       *string     `json:"name,omitempty"`
	Max        *uint32     `json:"max,omitempty"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

type GetRecordsResponse struct {
	Success bool            `json:"success"`
	Records []*Record       `json:"records"`
	Error   GetRecordsError `json:"error"`
}

type GetTeamMemberRequest struct {
	UserID uint64 `json:"userId"`
}

type GetTeamMemberResponse struct {
	Success    bool               `json:"success"`
	TeamMember *TeamMember        `json:"teamMember"`
	Error      GetTeamMemberError `json:"error"`
}

type GetTeamMembersRequest struct {
	Team       *TeamRequest `json:"team"`
	Pagination *Pagination  `json:"pagination,omitempty"`
}

type GetTeamMembersResponse struct {
	Success     bool                `json:"success"`
	TeamMembers []*TeamMember       `json:"teamMembers"`
	Error       GetTeamMembersError `json:"error"`
}

type GetTeamResponse struct {
	Success bool         `json:"success"`
	Team    *Team        `json:"team"`
	Error   GetTeamError `json:"error"`
}

type GetTeamsResponse struct {
	Success bool    `json:"success"`
	Teams   []*Team `json:"teams"`
}

type Item struct {
	ID       string                 `json:"id"`
	Type     string                 `json:"type"`
	Data     *structpb.Struct       `json:"data"`
	ExpireAt *timestamppb.Timestamp `json:"expireAt"`
}

type JoinTeamRequest struct {
	Team   *TeamRequest     `json:"team"`
	UserID uint64           `json:"userId"`
	Data   *structpb.Struct `json:"data"`
}

type JoinTeamResponse struct {
	Success bool          `json:"success"`
	Error   JoinTeamError `json:"error"`
}

type LeaveTeamRequest struct {
	UserID uint64 `json:"userId"`
}

type LeaveTeamResponse struct {
	Success bool           `json:"success"`
	Error   LeaveTeamError `json:"error"`
}

type Mutation struct {
}

type Pagination struct {
	Max  *uint32 `json:"max,omitempty"`
	Page *uint64 `json:"page,omitempty"`
}

type Query struct {
}

type Record struct {
	Name      string                 `json:"name"`
	UserID    uint64                 `json:"userId"`
	Record    uint64                 `json:"record"`
	Ranking   uint64                 `json:"ranking"`
	Data      *structpb.Struct       `json:"data"`
	CreatedAt *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

type RecordRequest struct {
	Name   string `json:"name"`
	UserID uint64 `json:"userId"`
}

type SearchTeamsRequest struct {
	Query      string      `json:"query"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

type SearchTeamsResponse struct {
	Success bool             `json:"success"`
	Teams   []*Team          `json:"teams"`
	Error   SearchTeamsError `json:"error"`
}

type Team struct {
	Name      string                 `json:"name"`
	Owner     uint64                 `json:"owner"`
	Score     int64                  `json:"score"`
	Ranking   uint64                 `json:"ranking"`
	Data      *structpb.Struct       `json:"data"`
	CreatedAt *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

type TeamMember struct {
	Team      string                 `json:"team"`
	UserID    uint64                 `json:"userId"`
	Data      *structpb.Struct       `json:"data"`
	JoinedAt  *timestamppb.Timestamp `json:"joinedAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

type TeamRequest struct {
	Name   *string `json:"name,omitempty"`
	Owner  *uint64 `json:"owner,omitempty"`
	Member *uint64 `json:"member,omitempty"`
}

type TeamResponse struct {
	Success bool      `json:"success"`
	Error   TeamError `json:"error"`
}

type UpdateRecordRequest struct {
	Request *RecordRequest   `json:"request"`
	Record  *uint64          `json:"record,omitempty"`
	Data    *structpb.Struct `json:"data,omitempty"`
}

type UpdateRecordResponse struct {
	Success bool              `json:"success"`
	Error   UpdateRecordError `json:"error"`
}

type UpdateTeamMemberRequest struct {
	UserID uint64           `json:"userId"`
	Data   *structpb.Struct `json:"data"`
}

type UpdateTeamMemberResponse struct {
	Success bool                  `json:"success"`
	Error   UpdateTeamMemberError `json:"error"`
}

type UpdateTeamRequest struct {
	Team           *TeamRequest     `json:"team"`
	Data           *structpb.Struct `json:"data,omitempty"`
	Score          *int64           `json:"score,omitempty"`
	IncrementScore *bool            `json:"incrementScore,omitempty"`
}

type UpdateTeamResponse struct {
	Success bool            `json:"success"`
	Error   UpdateTeamError `json:"error"`
}

type CreateItemError string

const (
	CreateItemErrorNone         CreateItemError = "NONE"
	CreateItemErrorTypeTooShort CreateItemError = "TYPE_TOO_SHORT"
	CreateItemErrorTypeTooLong  CreateItemError = "TYPE_TOO_LONG"
	CreateItemErrorDataRequired CreateItemError = "DATA_REQUIRED"
)

var AllCreateItemError = []CreateItemError{
	CreateItemErrorNone,
	CreateItemErrorTypeTooShort,
	CreateItemErrorTypeTooLong,
	CreateItemErrorDataRequired,
}

func (e CreateItemError) IsValid() bool {
	switch e {
	case CreateItemErrorNone, CreateItemErrorTypeTooShort, CreateItemErrorTypeTooLong, CreateItemErrorDataRequired:
		return true
	}
	return false
}

func (e CreateItemError) String() string {
	return string(e)
}

func (e *CreateItemError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateItemError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateItemError", str)
	}
	return nil
}

func (e CreateItemError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CreateRecordError string

const (
	CreateRecordErrorNone           CreateRecordError = "NONE"
	CreateRecordErrorNameTooShort   CreateRecordError = "NAME_TOO_SHORT"
	CreateRecordErrorNameTooLong    CreateRecordError = "NAME_TOO_LONG"
	CreateRecordErrorUserIDRequired CreateRecordError = "USER_ID_REQUIRED"
	CreateRecordErrorRecordRequired CreateRecordError = "RECORD_REQUIRED"
	CreateRecordErrorDataRequired   CreateRecordError = "DATA_REQUIRED"
	CreateRecordErrorRecordExists   CreateRecordError = "RECORD_EXISTS"
)

var AllCreateRecordError = []CreateRecordError{
	CreateRecordErrorNone,
	CreateRecordErrorNameTooShort,
	CreateRecordErrorNameTooLong,
	CreateRecordErrorUserIDRequired,
	CreateRecordErrorRecordRequired,
	CreateRecordErrorDataRequired,
	CreateRecordErrorRecordExists,
}

func (e CreateRecordError) IsValid() bool {
	switch e {
	case CreateRecordErrorNone, CreateRecordErrorNameTooShort, CreateRecordErrorNameTooLong, CreateRecordErrorUserIDRequired, CreateRecordErrorRecordRequired, CreateRecordErrorDataRequired, CreateRecordErrorRecordExists:
		return true
	}
	return false
}

func (e CreateRecordError) String() string {
	return string(e)
}

func (e *CreateRecordError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateRecordError", str)
	}
	return nil
}

func (e CreateRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CreateTeamError string

const (
	CreateTeamErrorNone                 CreateTeamError = "NONE"
	CreateTeamErrorOwnerRequired        CreateTeamError = "OWNER_REQUIRED"
	CreateTeamErrorNameTooShort         CreateTeamError = "NAME_TOO_SHORT"
	CreateTeamErrorNameTooLong          CreateTeamError = "NAME_TOO_LONG"
	CreateTeamErrorDataRequired         CreateTeamError = "DATA_REQUIRED"
	CreateTeamErrorOwnerDataRequired    CreateTeamError = "OWNER_DATA_REQUIRED"
	CreateTeamErrorNameTaken            CreateTeamError = "NAME_TAKEN"
	CreateTeamErrorOwnerOwnsAnotherTeam CreateTeamError = "OWNER_OWNS_ANOTHER_TEAM"
	CreateTeamErrorOwnerAlreadyInTeam   CreateTeamError = "OWNER_ALREADY_IN_TEAM"
)

var AllCreateTeamError = []CreateTeamError{
	CreateTeamErrorNone,
	CreateTeamErrorOwnerRequired,
	CreateTeamErrorNameTooShort,
	CreateTeamErrorNameTooLong,
	CreateTeamErrorDataRequired,
	CreateTeamErrorOwnerDataRequired,
	CreateTeamErrorNameTaken,
	CreateTeamErrorOwnerOwnsAnotherTeam,
	CreateTeamErrorOwnerAlreadyInTeam,
}

func (e CreateTeamError) IsValid() bool {
	switch e {
	case CreateTeamErrorNone, CreateTeamErrorOwnerRequired, CreateTeamErrorNameTooShort, CreateTeamErrorNameTooLong, CreateTeamErrorDataRequired, CreateTeamErrorOwnerDataRequired, CreateTeamErrorNameTaken, CreateTeamErrorOwnerOwnsAnotherTeam, CreateTeamErrorOwnerAlreadyInTeam:
		return true
	}
	return false
}

func (e CreateTeamError) String() string {
	return string(e)
}

func (e *CreateTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateTeamError", str)
	}
	return nil
}

func (e CreateTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeleteRecordError string

const (
	DeleteRecordErrorNone           DeleteRecordError = "NONE"
	DeleteRecordErrorNotFound       DeleteRecordError = "NOT_FOUND"
	DeleteRecordErrorNameTooShort   DeleteRecordError = "NAME_TOO_SHORT"
	DeleteRecordErrorNameTooLong    DeleteRecordError = "NAME_TOO_LONG"
	DeleteRecordErrorUserIDRequired DeleteRecordError = "USER_ID_REQUIRED"
)

var AllDeleteRecordError = []DeleteRecordError{
	DeleteRecordErrorNone,
	DeleteRecordErrorNotFound,
	DeleteRecordErrorNameTooShort,
	DeleteRecordErrorNameTooLong,
	DeleteRecordErrorUserIDRequired,
}

func (e DeleteRecordError) IsValid() bool {
	switch e {
	case DeleteRecordErrorNone, DeleteRecordErrorNotFound, DeleteRecordErrorNameTooShort, DeleteRecordErrorNameTooLong, DeleteRecordErrorUserIDRequired:
		return true
	}
	return false
}

func (e DeleteRecordError) String() string {
	return string(e)
}

func (e *DeleteRecordError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteRecordError", str)
	}
	return nil
}

func (e DeleteRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetItemError string

const (
	GetItemErrorNone         GetItemError = "NONE"
	GetItemErrorIDRequired   GetItemError = "ID_REQUIRED"
	GetItemErrorNotFound     GetItemError = "NOT_FOUND"
	GetItemErrorTypeTooShort GetItemError = "TYPE_TOO_SHORT"
	GetItemErrorTypeTooLong  GetItemError = "TYPE_TOO_LONG"
)

var AllGetItemError = []GetItemError{
	GetItemErrorNone,
	GetItemErrorIDRequired,
	GetItemErrorNotFound,
	GetItemErrorTypeTooShort,
	GetItemErrorTypeTooLong,
}

func (e GetItemError) IsValid() bool {
	switch e {
	case GetItemErrorNone, GetItemErrorIDRequired, GetItemErrorNotFound, GetItemErrorTypeTooShort, GetItemErrorTypeTooLong:
		return true
	}
	return false
}

func (e GetItemError) String() string {
	return string(e)
}

func (e *GetItemError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetItemError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetItemError", str)
	}
	return nil
}

func (e GetItemError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetItemsError string

const (
	GetItemsErrorNone         GetItemsError = "NONE"
	GetItemsErrorTypeTooShort GetItemsError = "TYPE_TOO_SHORT"
	GetItemsErrorTypeTooLong  GetItemsError = "TYPE_TOO_LONG"
)

var AllGetItemsError = []GetItemsError{
	GetItemsErrorNone,
	GetItemsErrorTypeTooShort,
	GetItemsErrorTypeTooLong,
}

func (e GetItemsError) IsValid() bool {
	switch e {
	case GetItemsErrorNone, GetItemsErrorTypeTooShort, GetItemsErrorTypeTooLong:
		return true
	}
	return false
}

func (e GetItemsError) String() string {
	return string(e)
}

func (e *GetItemsError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetItemsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetItemsError", str)
	}
	return nil
}

func (e GetItemsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetRecordError string

const (
	GetRecordErrorNone           GetRecordError = "NONE"
	GetRecordErrorNotFound       GetRecordError = "NOT_FOUND"
	GetRecordErrorNameTooShort   GetRecordError = "NAME_TOO_SHORT"
	GetRecordErrorNameTooLong    GetRecordError = "NAME_TOO_LONG"
	GetRecordErrorUserIDRequired GetRecordError = "USER_ID_REQUIRED"
)

var AllGetRecordError = []GetRecordError{
	GetRecordErrorNone,
	GetRecordErrorNotFound,
	GetRecordErrorNameTooShort,
	GetRecordErrorNameTooLong,
	GetRecordErrorUserIDRequired,
}

func (e GetRecordError) IsValid() bool {
	switch e {
	case GetRecordErrorNone, GetRecordErrorNotFound, GetRecordErrorNameTooShort, GetRecordErrorNameTooLong, GetRecordErrorUserIDRequired:
		return true
	}
	return false
}

func (e GetRecordError) String() string {
	return string(e)
}

func (e *GetRecordError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetRecordError", str)
	}
	return nil
}

func (e GetRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetRecordsError string

const (
	GetRecordsErrorNone         GetRecordsError = "NONE"
	GetRecordsErrorNameTooShort GetRecordsError = "NAME_TOO_SHORT"
	GetRecordsErrorNameTooLong  GetRecordsError = "NAME_TOO_LONG"
)

var AllGetRecordsError = []GetRecordsError{
	GetRecordsErrorNone,
	GetRecordsErrorNameTooShort,
	GetRecordsErrorNameTooLong,
}

func (e GetRecordsError) IsValid() bool {
	switch e {
	case GetRecordsErrorNone, GetRecordsErrorNameTooShort, GetRecordsErrorNameTooLong:
		return true
	}
	return false
}

func (e GetRecordsError) String() string {
	return string(e)
}

func (e *GetRecordsError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetRecordsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetRecordsError", str)
	}
	return nil
}

func (e GetRecordsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetTeamError string

const (
	GetTeamErrorNone             GetTeamError = "NONE"
	GetTeamErrorNoFieldSpecified GetTeamError = "NO_FIELD_SPECIFIED"
	GetTeamErrorNotFound         GetTeamError = "NOT_FOUND"
	GetTeamErrorNameTooShort     GetTeamError = "NAME_TOO_SHORT"
	GetTeamErrorNameTooLong      GetTeamError = "NAME_TOO_LONG"
)

var AllGetTeamError = []GetTeamError{
	GetTeamErrorNone,
	GetTeamErrorNoFieldSpecified,
	GetTeamErrorNotFound,
	GetTeamErrorNameTooShort,
	GetTeamErrorNameTooLong,
}

func (e GetTeamError) IsValid() bool {
	switch e {
	case GetTeamErrorNone, GetTeamErrorNoFieldSpecified, GetTeamErrorNotFound, GetTeamErrorNameTooShort, GetTeamErrorNameTooLong:
		return true
	}
	return false
}

func (e GetTeamError) String() string {
	return string(e)
}

func (e *GetTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTeamError", str)
	}
	return nil
}

func (e GetTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetTeamMemberError string

const (
	GetTeamMemberErrorNone           GetTeamMemberError = "NONE"
	GetTeamMemberErrorUserIDRequired GetTeamMemberError = "USER_ID_REQUIRED"
	GetTeamMemberErrorNotFound       GetTeamMemberError = "NOT_FOUND"
)

var AllGetTeamMemberError = []GetTeamMemberError{
	GetTeamMemberErrorNone,
	GetTeamMemberErrorUserIDRequired,
	GetTeamMemberErrorNotFound,
}

func (e GetTeamMemberError) IsValid() bool {
	switch e {
	case GetTeamMemberErrorNone, GetTeamMemberErrorUserIDRequired, GetTeamMemberErrorNotFound:
		return true
	}
	return false
}

func (e GetTeamMemberError) String() string {
	return string(e)
}

func (e *GetTeamMemberError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTeamMemberError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTeamMemberError", str)
	}
	return nil
}

func (e GetTeamMemberError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetTeamMembersError string

const (
	GetTeamMembersErrorNone             GetTeamMembersError = "NONE"
	GetTeamMembersErrorNoFieldSpecified GetTeamMembersError = "NO_FIELD_SPECIFIED"
	GetTeamMembersErrorNotFound         GetTeamMembersError = "NOT_FOUND"
	GetTeamMembersErrorNameTooShort     GetTeamMembersError = "NAME_TOO_SHORT"
	GetTeamMembersErrorNameTooLong      GetTeamMembersError = "NAME_TOO_LONG"
)

var AllGetTeamMembersError = []GetTeamMembersError{
	GetTeamMembersErrorNone,
	GetTeamMembersErrorNoFieldSpecified,
	GetTeamMembersErrorNotFound,
	GetTeamMembersErrorNameTooShort,
	GetTeamMembersErrorNameTooLong,
}

func (e GetTeamMembersError) IsValid() bool {
	switch e {
	case GetTeamMembersErrorNone, GetTeamMembersErrorNoFieldSpecified, GetTeamMembersErrorNotFound, GetTeamMembersErrorNameTooShort, GetTeamMembersErrorNameTooLong:
		return true
	}
	return false
}

func (e GetTeamMembersError) String() string {
	return string(e)
}

func (e *GetTeamMembersError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTeamMembersError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTeamMembersError", str)
	}
	return nil
}

func (e GetTeamMembersError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type JoinTeamError string

const (
	JoinTeamErrorNone             JoinTeamError = "NONE"
	JoinTeamErrorNoFieldSpecified JoinTeamError = "NO_FIELD_SPECIFIED"
	JoinTeamErrorUserIDRequired   JoinTeamError = "USER_ID_REQUIRED"
	JoinTeamErrorDataRequired     JoinTeamError = "DATA_REQUIRED"
	JoinTeamErrorNameTooShort     JoinTeamError = "NAME_TOO_SHORT"
	JoinTeamErrorNameTooLong      JoinTeamError = "NAME_TOO_LONG"
	JoinTeamErrorNotFound         JoinTeamError = "NOT_FOUND"
	JoinTeamErrorTeamFull         JoinTeamError = "TEAM_FULL"
	JoinTeamErrorAlreadyInATeam   JoinTeamError = "ALREADY_IN_A_TEAM"
)

var AllJoinTeamError = []JoinTeamError{
	JoinTeamErrorNone,
	JoinTeamErrorNoFieldSpecified,
	JoinTeamErrorUserIDRequired,
	JoinTeamErrorDataRequired,
	JoinTeamErrorNameTooShort,
	JoinTeamErrorNameTooLong,
	JoinTeamErrorNotFound,
	JoinTeamErrorTeamFull,
	JoinTeamErrorAlreadyInATeam,
}

func (e JoinTeamError) IsValid() bool {
	switch e {
	case JoinTeamErrorNone, JoinTeamErrorNoFieldSpecified, JoinTeamErrorUserIDRequired, JoinTeamErrorDataRequired, JoinTeamErrorNameTooShort, JoinTeamErrorNameTooLong, JoinTeamErrorNotFound, JoinTeamErrorTeamFull, JoinTeamErrorAlreadyInATeam:
		return true
	}
	return false
}

func (e JoinTeamError) String() string {
	return string(e)
}

func (e *JoinTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JoinTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JoinTeamError", str)
	}
	return nil
}

func (e JoinTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LeaveTeamError string

const (
	LeaveTeamErrorNone           LeaveTeamError = "NONE"
	LeaveTeamErrorUserIDRequired LeaveTeamError = "USER_ID_REQUIRED"
	LeaveTeamErrorNotInTeam      LeaveTeamError = "NOT_IN_TEAM"
	LeaveTeamErrorMemberIsOwner  LeaveTeamError = "MEMBER_IS_OWNER"
)

var AllLeaveTeamError = []LeaveTeamError{
	LeaveTeamErrorNone,
	LeaveTeamErrorUserIDRequired,
	LeaveTeamErrorNotInTeam,
	LeaveTeamErrorMemberIsOwner,
}

func (e LeaveTeamError) IsValid() bool {
	switch e {
	case LeaveTeamErrorNone, LeaveTeamErrorUserIDRequired, LeaveTeamErrorNotInTeam, LeaveTeamErrorMemberIsOwner:
		return true
	}
	return false
}

func (e LeaveTeamError) String() string {
	return string(e)
}

func (e *LeaveTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LeaveTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LeaveTeamError", str)
	}
	return nil
}

func (e LeaveTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SearchTeamsError string

const (
	SearchTeamsErrorNone          SearchTeamsError = "NONE"
	SearchTeamsErrorQueryTooShort SearchTeamsError = "QUERY_TOO_SHORT"
	SearchTeamsErrorQueryTooLong  SearchTeamsError = "QUERY_TOO_LONG"
)

var AllSearchTeamsError = []SearchTeamsError{
	SearchTeamsErrorNone,
	SearchTeamsErrorQueryTooShort,
	SearchTeamsErrorQueryTooLong,
}

func (e SearchTeamsError) IsValid() bool {
	switch e {
	case SearchTeamsErrorNone, SearchTeamsErrorQueryTooShort, SearchTeamsErrorQueryTooLong:
		return true
	}
	return false
}

func (e SearchTeamsError) String() string {
	return string(e)
}

func (e *SearchTeamsError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchTeamsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchTeamsError", str)
	}
	return nil
}

func (e SearchTeamsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TeamError string

const (
	TeamErrorNone             TeamError = "NONE"
	TeamErrorNoFieldSpecified TeamError = "NO_FIELD_SPECIFIED"
	TeamErrorNotFound         TeamError = "NOT_FOUND"
	TeamErrorNameTooShort     TeamError = "NAME_TOO_SHORT"
	TeamErrorNameTooLong      TeamError = "NAME_TOO_LONG"
)

var AllTeamError = []TeamError{
	TeamErrorNone,
	TeamErrorNoFieldSpecified,
	TeamErrorNotFound,
	TeamErrorNameTooShort,
	TeamErrorNameTooLong,
}

func (e TeamError) IsValid() bool {
	switch e {
	case TeamErrorNone, TeamErrorNoFieldSpecified, TeamErrorNotFound, TeamErrorNameTooShort, TeamErrorNameTooLong:
		return true
	}
	return false
}

func (e TeamError) String() string {
	return string(e)
}

func (e *TeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamError", str)
	}
	return nil
}

func (e TeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpdateRecordError string

const (
	UpdateRecordErrorNone              UpdateRecordError = "NONE"
	UpdateRecordErrorNotFound          UpdateRecordError = "NOT_FOUND"
	UpdateRecordErrorNameTooShort      UpdateRecordError = "NAME_TOO_SHORT"
	UpdateRecordErrorNameTooLong       UpdateRecordError = "NAME_TOO_LONG"
	UpdateRecordErrorUserIDRequired    UpdateRecordError = "USER_ID_REQUIRED"
	UpdateRecordErrorNoUpdateSpecified UpdateRecordError = "NO_UPDATE_SPECIFIED"
)

var AllUpdateRecordError = []UpdateRecordError{
	UpdateRecordErrorNone,
	UpdateRecordErrorNotFound,
	UpdateRecordErrorNameTooShort,
	UpdateRecordErrorNameTooLong,
	UpdateRecordErrorUserIDRequired,
	UpdateRecordErrorNoUpdateSpecified,
}

func (e UpdateRecordError) IsValid() bool {
	switch e {
	case UpdateRecordErrorNone, UpdateRecordErrorNotFound, UpdateRecordErrorNameTooShort, UpdateRecordErrorNameTooLong, UpdateRecordErrorUserIDRequired, UpdateRecordErrorNoUpdateSpecified:
		return true
	}
	return false
}

func (e UpdateRecordError) String() string {
	return string(e)
}

func (e *UpdateRecordError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateRecordError", str)
	}
	return nil
}

func (e UpdateRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpdateTeamError string

const (
	UpdateTeamErrorNone                       UpdateTeamError = "NONE"
	UpdateTeamErrorNoFieldSpecified           UpdateTeamError = "NO_FIELD_SPECIFIED"
	UpdateTeamErrorNotFound                   UpdateTeamError = "NOT_FOUND"
	UpdateTeamErrorNameTooShort               UpdateTeamError = "NAME_TOO_SHORT"
	UpdateTeamErrorNameTooLong                UpdateTeamError = "NAME_TOO_LONG"
	UpdateTeamErrorNoUpdateSpecified          UpdateTeamError = "NO_UPDATE_SPECIFIED"
	UpdateTeamErrorIncrementScoreNotSpecified UpdateTeamError = "INCREMENT_SCORE_NOT_SPECIFIED"
)

var AllUpdateTeamError = []UpdateTeamError{
	UpdateTeamErrorNone,
	UpdateTeamErrorNoFieldSpecified,
	UpdateTeamErrorNotFound,
	UpdateTeamErrorNameTooShort,
	UpdateTeamErrorNameTooLong,
	UpdateTeamErrorNoUpdateSpecified,
	UpdateTeamErrorIncrementScoreNotSpecified,
}

func (e UpdateTeamError) IsValid() bool {
	switch e {
	case UpdateTeamErrorNone, UpdateTeamErrorNoFieldSpecified, UpdateTeamErrorNotFound, UpdateTeamErrorNameTooShort, UpdateTeamErrorNameTooLong, UpdateTeamErrorNoUpdateSpecified, UpdateTeamErrorIncrementScoreNotSpecified:
		return true
	}
	return false
}

func (e UpdateTeamError) String() string {
	return string(e)
}

func (e *UpdateTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateTeamError", str)
	}
	return nil
}

func (e UpdateTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpdateTeamMemberError string

const (
	UpdateTeamMemberErrorNone           UpdateTeamMemberError = "NONE"
	UpdateTeamMemberErrorUserIDRequired UpdateTeamMemberError = "USER_ID_REQUIRED"
	UpdateTeamMemberErrorDataRequired   UpdateTeamMemberError = "DATA_REQUIRED"
	UpdateTeamMemberErrorNotFound       UpdateTeamMemberError = "NOT_FOUND"
)

var AllUpdateTeamMemberError = []UpdateTeamMemberError{
	UpdateTeamMemberErrorNone,
	UpdateTeamMemberErrorUserIDRequired,
	UpdateTeamMemberErrorDataRequired,
	UpdateTeamMemberErrorNotFound,
}

func (e UpdateTeamMemberError) IsValid() bool {
	switch e {
	case UpdateTeamMemberErrorNone, UpdateTeamMemberErrorUserIDRequired, UpdateTeamMemberErrorDataRequired, UpdateTeamMemberErrorNotFound:
		return true
	}
	return false
}

func (e UpdateTeamMemberError) String() string {
	return string(e)
}

func (e *UpdateTeamMemberError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateTeamMemberError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateTeamMemberError", str)
	}
	return nil
}

func (e UpdateTeamMemberError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
