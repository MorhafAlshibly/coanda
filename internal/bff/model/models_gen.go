// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type CreateItemRequest struct {
	Type   string                 `json:"type"`
	Data   map[string]interface{} `json:"data"`
	Expire *string                `json:"expire,omitempty"`
}

type CreateItemResponse struct {
	Success bool            `json:"success"`
	Item    *Item           `json:"item"`
	Error   CreateItemError `json:"error"`
}

type CreateRecordRequest struct {
	Name   string                 `json:"name"`
	UserID uint64                 `json:"userId"`
	Record uint64                 `json:"record"`
	Data   map[string]interface{} `json:"data"`
}

type CreateRecordResponse struct {
	Success bool              `json:"success"`
	Error   CreateRecordError `json:"error"`
}

type CreateTeamRequest struct {
	Name                string                 `json:"name"`
	Owner               uint64                 `json:"owner"`
	MembersWithoutOwner []uint64               `json:"membersWithoutOwner,omitempty"`
	Score               *int64                 `json:"score,omitempty"`
	Data                map[string]interface{} `json:"data"`
}

type CreateTeamResponse struct {
	Success bool            `json:"success"`
	ID      string          `json:"id"`
	Error   CreateTeamError `json:"error"`
}

type DeleteRecordResponse struct {
	Success bool              `json:"success"`
	Error   DeleteRecordError `json:"error"`
}

type GetItemRequest struct {
	ID   string `json:"id"`
	Type string `json:"type"`
}

type GetItemResponse struct {
	Success bool         `json:"success"`
	Item    *Item        `json:"item"`
	Error   GetItemError `json:"error"`
}

type GetItemsRequest struct {
	Type            *string `json:"type,omitempty"`
	Max             *uint32 `json:"max,omitempty"`
	LastEvaluatedID *string `json:"lastEvaluatedId,omitempty"`
}

type GetItemsResponse struct {
	Success bool          `json:"success"`
	Items   []*Item       `json:"items"`
	Error   GetItemsError `json:"error"`
}

type GetRecordRequest struct {
	Name   string `json:"name"`
	UserID uint64 `json:"userId"`
}

type GetRecordResponse struct {
	Success bool           `json:"success"`
	Record  *Record        `json:"record"`
	Error   GetRecordError `json:"error"`
}

type GetRecordsRequest struct {
	Name             *string `json:"name,omitempty"`
	Max              *uint32 `json:"max,omitempty"`
	LastEvaluatedKey *string `json:"lastEvaluatedKey,omitempty"`
}

type GetRecordsResponse struct {
	Success bool            `json:"success"`
	Records []*Record       `json:"records"`
	Error   GetRecordsError `json:"error"`
}

type GetTeamRequest struct {
	ID    *string `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
	Owner *uint64 `json:"owner,omitempty"`
}

type GetTeamResponse struct {
	Success bool         `json:"success"`
	Team    *Team        `json:"team"`
	Error   GetTeamError `json:"error"`
}

type GetTeamsRequest struct {
	Max  *uint32 `json:"max,omitempty"`
	Page *uint64 `json:"page,omitempty"`
}

type GetTeamsResponse struct {
	Success bool    `json:"success"`
	Teams   []*Team `json:"teams"`
}

type Item struct {
	ID     string                 `json:"id"`
	Type   string                 `json:"type"`
	Data   map[string]interface{} `json:"data"`
	Expire string                 `json:"expire"`
}

type JoinTeamRequest struct {
	Team   *GetTeamRequest `json:"team"`
	UserID uint64          `json:"userId"`
}

type JoinTeamResponse struct {
	Success bool          `json:"success"`
	Error   JoinTeamError `json:"error"`
}

type LeaveTeamRequest struct {
	Team   *GetTeamRequest `json:"team"`
	UserID uint64          `json:"userId"`
}

type LeaveTeamResponse struct {
	Success bool           `json:"success"`
	Error   LeaveTeamError `json:"error"`
}

type Mutation struct {
}

type Query struct {
}

type Record struct {
	Name      string                 `json:"name"`
	UserID    uint64                 `json:"userId"`
	Record    uint64                 `json:"record"`
	Rank      uint64                 `json:"rank"`
	Data      map[string]interface{} `json:"data"`
	CreatedAt string                 `json:"createdAt"`
	UpdatedAt string                 `json:"updatedAt"`
}

type SearchTeamsRequest struct {
	Query      string           `json:"query"`
	Pagination *GetTeamsRequest `json:"pagination,omitempty"`
}

type SearchTeamsResponse struct {
	Success bool             `json:"success"`
	Teams   []*Team          `json:"teams"`
	Error   SearchTeamsError `json:"error"`
}

type Team struct {
	ID                  string                 `json:"id"`
	Name                string                 `json:"name"`
	Owner               uint64                 `json:"owner"`
	MembersWithoutOwner []uint64               `json:"membersWithoutOwner"`
	Score               int64                  `json:"score"`
	Rank                uint64                 `json:"rank"`
	Data                map[string]interface{} `json:"data"`
}

type TeamResponse struct {
	Success bool      `json:"success"`
	Error   TeamError `json:"error"`
}

type UpdateRecordRequest struct {
	Request *GetRecordRequest      `json:"request"`
	Record  *uint64                `json:"record,omitempty"`
	Data    map[string]interface{} `json:"data,omitempty"`
}

type UpdateRecordResponse struct {
	Success bool              `json:"success"`
	Error   UpdateRecordError `json:"error"`
}

type UpdateTeamDataRequest struct {
	Team *GetTeamRequest        `json:"team"`
	Data map[string]interface{} `json:"data"`
}

type UpdateTeamScoreRequest struct {
	Team        *GetTeamRequest `json:"team"`
	ScoreOffset int64           `json:"scoreOffset"`
}

type CreateItemError string

const (
	CreateItemErrorNone          CreateItemError = "NONE"
	CreateItemErrorTypeTooShort  CreateItemError = "TYPE_TOO_SHORT"
	CreateItemErrorTypeTooLong   CreateItemError = "TYPE_TOO_LONG"
	CreateItemErrorDataNotSet    CreateItemError = "DATA_NOT_SET"
	CreateItemErrorExpireInvalid CreateItemError = "EXPIRE_INVALID"
)

var AllCreateItemError = []CreateItemError{
	CreateItemErrorNone,
	CreateItemErrorTypeTooShort,
	CreateItemErrorTypeTooLong,
	CreateItemErrorDataNotSet,
	CreateItemErrorExpireInvalid,
}

func (e CreateItemError) IsValid() bool {
	switch e {
	case CreateItemErrorNone, CreateItemErrorTypeTooShort, CreateItemErrorTypeTooLong, CreateItemErrorDataNotSet, CreateItemErrorExpireInvalid:
		return true
	}
	return false
}

func (e CreateItemError) String() string {
	return string(e)
}

func (e *CreateItemError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateItemError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateItemError", str)
	}
	return nil
}

func (e CreateItemError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CreateRecordError string

const (
	CreateRecordErrorNone           CreateRecordError = "NONE"
	CreateRecordErrorNameTooShort   CreateRecordError = "NAME_TOO_SHORT"
	CreateRecordErrorNameTooLong    CreateRecordError = "NAME_TOO_LONG"
	CreateRecordErrorUserIDRequired CreateRecordError = "USER_ID_REQUIRED"
	CreateRecordErrorRecordRequired CreateRecordError = "RECORD_REQUIRED"
	CreateRecordErrorRecordExists   CreateRecordError = "RECORD_EXISTS"
)

var AllCreateRecordError = []CreateRecordError{
	CreateRecordErrorNone,
	CreateRecordErrorNameTooShort,
	CreateRecordErrorNameTooLong,
	CreateRecordErrorUserIDRequired,
	CreateRecordErrorRecordRequired,
	CreateRecordErrorRecordExists,
}

func (e CreateRecordError) IsValid() bool {
	switch e {
	case CreateRecordErrorNone, CreateRecordErrorNameTooShort, CreateRecordErrorNameTooLong, CreateRecordErrorUserIDRequired, CreateRecordErrorRecordRequired, CreateRecordErrorRecordExists:
		return true
	}
	return false
}

func (e CreateRecordError) String() string {
	return string(e)
}

func (e *CreateRecordError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateRecordError", str)
	}
	return nil
}

func (e CreateRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CreateTeamError string

const (
	CreateTeamErrorNone           CreateTeamError = "NONE"
	CreateTeamErrorOwnerRequired  CreateTeamError = "OWNER_REQUIRED"
	CreateTeamErrorNameTooShort   CreateTeamError = "NAME_TOO_SHORT"
	CreateTeamErrorNameTooLong    CreateTeamError = "NAME_TOO_LONG"
	CreateTeamErrorNameTaken      CreateTeamError = "NAME_TAKEN"
	CreateTeamErrorOwnerTaken     CreateTeamError = "OWNER_TAKEN"
	CreateTeamErrorTooManyMembers CreateTeamError = "TOO_MANY_MEMBERS"
)

var AllCreateTeamError = []CreateTeamError{
	CreateTeamErrorNone,
	CreateTeamErrorOwnerRequired,
	CreateTeamErrorNameTooShort,
	CreateTeamErrorNameTooLong,
	CreateTeamErrorNameTaken,
	CreateTeamErrorOwnerTaken,
	CreateTeamErrorTooManyMembers,
}

func (e CreateTeamError) IsValid() bool {
	switch e {
	case CreateTeamErrorNone, CreateTeamErrorOwnerRequired, CreateTeamErrorNameTooShort, CreateTeamErrorNameTooLong, CreateTeamErrorNameTaken, CreateTeamErrorOwnerTaken, CreateTeamErrorTooManyMembers:
		return true
	}
	return false
}

func (e CreateTeamError) String() string {
	return string(e)
}

func (e *CreateTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateTeamError", str)
	}
	return nil
}

func (e CreateTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeleteRecordError string

const (
	DeleteRecordErrorNone         DeleteRecordError = "NONE"
	DeleteRecordErrorInvalid      DeleteRecordError = "INVALID"
	DeleteRecordErrorNotFound     DeleteRecordError = "NOT_FOUND"
	DeleteRecordErrorNameTooShort DeleteRecordError = "NAME_TOO_SHORT"
	DeleteRecordErrorNameTooLong  DeleteRecordError = "NAME_TOO_LONG"
)

var AllDeleteRecordError = []DeleteRecordError{
	DeleteRecordErrorNone,
	DeleteRecordErrorInvalid,
	DeleteRecordErrorNotFound,
	DeleteRecordErrorNameTooShort,
	DeleteRecordErrorNameTooLong,
}

func (e DeleteRecordError) IsValid() bool {
	switch e {
	case DeleteRecordErrorNone, DeleteRecordErrorInvalid, DeleteRecordErrorNotFound, DeleteRecordErrorNameTooShort, DeleteRecordErrorNameTooLong:
		return true
	}
	return false
}

func (e DeleteRecordError) String() string {
	return string(e)
}

func (e *DeleteRecordError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteRecordError", str)
	}
	return nil
}

func (e DeleteRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetItemError string

const (
	GetItemErrorNone         GetItemError = "NONE"
	GetItemErrorIDNotSet     GetItemError = "ID_NOT_SET"
	GetItemErrorNotFound     GetItemError = "NOT_FOUND"
	GetItemErrorTypeTooShort GetItemError = "TYPE_TOO_SHORT"
	GetItemErrorTypeTooLong  GetItemError = "TYPE_TOO_LONG"
)

var AllGetItemError = []GetItemError{
	GetItemErrorNone,
	GetItemErrorIDNotSet,
	GetItemErrorNotFound,
	GetItemErrorTypeTooShort,
	GetItemErrorTypeTooLong,
}

func (e GetItemError) IsValid() bool {
	switch e {
	case GetItemErrorNone, GetItemErrorIDNotSet, GetItemErrorNotFound, GetItemErrorTypeTooShort, GetItemErrorTypeTooLong:
		return true
	}
	return false
}

func (e GetItemError) String() string {
	return string(e)
}

func (e *GetItemError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetItemError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetItemError", str)
	}
	return nil
}

func (e GetItemError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetItemsError string

const (
	GetItemsErrorNone         GetItemsError = "NONE"
	GetItemsErrorTypeTooShort GetItemsError = "TYPE_TOO_SHORT"
	GetItemsErrorTypeTooLong  GetItemsError = "TYPE_TOO_LONG"
)

var AllGetItemsError = []GetItemsError{
	GetItemsErrorNone,
	GetItemsErrorTypeTooShort,
	GetItemsErrorTypeTooLong,
}

func (e GetItemsError) IsValid() bool {
	switch e {
	case GetItemsErrorNone, GetItemsErrorTypeTooShort, GetItemsErrorTypeTooLong:
		return true
	}
	return false
}

func (e GetItemsError) String() string {
	return string(e)
}

func (e *GetItemsError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetItemsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetItemsError", str)
	}
	return nil
}

func (e GetItemsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetRecordError string

const (
	GetRecordErrorNone         GetRecordError = "NONE"
	GetRecordErrorInvalid      GetRecordError = "INVALID"
	GetRecordErrorNotFound     GetRecordError = "NOT_FOUND"
	GetRecordErrorNameTooShort GetRecordError = "NAME_TOO_SHORT"
	GetRecordErrorNameTooLong  GetRecordError = "NAME_TOO_LONG"
)

var AllGetRecordError = []GetRecordError{
	GetRecordErrorNone,
	GetRecordErrorInvalid,
	GetRecordErrorNotFound,
	GetRecordErrorNameTooShort,
	GetRecordErrorNameTooLong,
}

func (e GetRecordError) IsValid() bool {
	switch e {
	case GetRecordErrorNone, GetRecordErrorInvalid, GetRecordErrorNotFound, GetRecordErrorNameTooShort, GetRecordErrorNameTooLong:
		return true
	}
	return false
}

func (e GetRecordError) String() string {
	return string(e)
}

func (e *GetRecordError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetRecordError", str)
	}
	return nil
}

func (e GetRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetRecordsError string

const (
	GetRecordsErrorNone         GetRecordsError = "NONE"
	GetRecordsErrorNameTooShort GetRecordsError = "NAME_TOO_SHORT"
	GetRecordsErrorNameTooLong  GetRecordsError = "NAME_TOO_LONG"
)

var AllGetRecordsError = []GetRecordsError{
	GetRecordsErrorNone,
	GetRecordsErrorNameTooShort,
	GetRecordsErrorNameTooLong,
}

func (e GetRecordsError) IsValid() bool {
	switch e {
	case GetRecordsErrorNone, GetRecordsErrorNameTooShort, GetRecordsErrorNameTooLong:
		return true
	}
	return false
}

func (e GetRecordsError) String() string {
	return string(e)
}

func (e *GetRecordsError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetRecordsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetRecordsError", str)
	}
	return nil
}

func (e GetRecordsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetTeamError string

const (
	GetTeamErrorNone         GetTeamError = "NONE"
	GetTeamErrorInvalid      GetTeamError = "INVALID"
	GetTeamErrorNotFound     GetTeamError = "NOT_FOUND"
	GetTeamErrorNameTooShort GetTeamError = "NAME_TOO_SHORT"
	GetTeamErrorNameTooLong  GetTeamError = "NAME_TOO_LONG"
)

var AllGetTeamError = []GetTeamError{
	GetTeamErrorNone,
	GetTeamErrorInvalid,
	GetTeamErrorNotFound,
	GetTeamErrorNameTooShort,
	GetTeamErrorNameTooLong,
}

func (e GetTeamError) IsValid() bool {
	switch e {
	case GetTeamErrorNone, GetTeamErrorInvalid, GetTeamErrorNotFound, GetTeamErrorNameTooShort, GetTeamErrorNameTooLong:
		return true
	}
	return false
}

func (e GetTeamError) String() string {
	return string(e)
}

func (e *GetTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTeamError", str)
	}
	return nil
}

func (e GetTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type JoinTeamError string

const (
	JoinTeamErrorNone               JoinTeamError = "NONE"
	JoinTeamErrorInvalid            JoinTeamError = "INVALID"
	JoinTeamErrorNameTooShort       JoinTeamError = "NAME_TOO_SHORT"
	JoinTeamErrorNameTooLong        JoinTeamError = "NAME_TOO_LONG"
	JoinTeamErrorNotFoundOrTeamFull JoinTeamError = "NOT_FOUND_OR_TEAM_FULL"
	JoinTeamErrorAlreadyMember      JoinTeamError = "ALREADY_MEMBER"
)

var AllJoinTeamError = []JoinTeamError{
	JoinTeamErrorNone,
	JoinTeamErrorInvalid,
	JoinTeamErrorNameTooShort,
	JoinTeamErrorNameTooLong,
	JoinTeamErrorNotFoundOrTeamFull,
	JoinTeamErrorAlreadyMember,
}

func (e JoinTeamError) IsValid() bool {
	switch e {
	case JoinTeamErrorNone, JoinTeamErrorInvalid, JoinTeamErrorNameTooShort, JoinTeamErrorNameTooLong, JoinTeamErrorNotFoundOrTeamFull, JoinTeamErrorAlreadyMember:
		return true
	}
	return false
}

func (e JoinTeamError) String() string {
	return string(e)
}

func (e *JoinTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JoinTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JoinTeamError", str)
	}
	return nil
}

func (e JoinTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LeaveTeamError string

const (
	LeaveTeamErrorNone         LeaveTeamError = "NONE"
	LeaveTeamErrorInvalid      LeaveTeamError = "INVALID"
	LeaveTeamErrorNameTooShort LeaveTeamError = "NAME_TOO_SHORT"
	LeaveTeamErrorNameTooLong  LeaveTeamError = "NAME_TOO_LONG"
	LeaveTeamErrorNotFound     LeaveTeamError = "NOT_FOUND"
	LeaveTeamErrorNotMember    LeaveTeamError = "NOT_MEMBER"
)

var AllLeaveTeamError = []LeaveTeamError{
	LeaveTeamErrorNone,
	LeaveTeamErrorInvalid,
	LeaveTeamErrorNameTooShort,
	LeaveTeamErrorNameTooLong,
	LeaveTeamErrorNotFound,
	LeaveTeamErrorNotMember,
}

func (e LeaveTeamError) IsValid() bool {
	switch e {
	case LeaveTeamErrorNone, LeaveTeamErrorInvalid, LeaveTeamErrorNameTooShort, LeaveTeamErrorNameTooLong, LeaveTeamErrorNotFound, LeaveTeamErrorNotMember:
		return true
	}
	return false
}

func (e LeaveTeamError) String() string {
	return string(e)
}

func (e *LeaveTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LeaveTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LeaveTeamError", str)
	}
	return nil
}

func (e LeaveTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SearchTeamsError string

const (
	SearchTeamsErrorNone          SearchTeamsError = "NONE"
	SearchTeamsErrorQueryTooShort SearchTeamsError = "QUERY_TOO_SHORT"
	SearchTeamsErrorQueryTooLong  SearchTeamsError = "QUERY_TOO_LONG"
)

var AllSearchTeamsError = []SearchTeamsError{
	SearchTeamsErrorNone,
	SearchTeamsErrorQueryTooShort,
	SearchTeamsErrorQueryTooLong,
}

func (e SearchTeamsError) IsValid() bool {
	switch e {
	case SearchTeamsErrorNone, SearchTeamsErrorQueryTooShort, SearchTeamsErrorQueryTooLong:
		return true
	}
	return false
}

func (e SearchTeamsError) String() string {
	return string(e)
}

func (e *SearchTeamsError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchTeamsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchTeamsError", str)
	}
	return nil
}

func (e SearchTeamsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TeamError string

const (
	TeamErrorNone         TeamError = "NONE"
	TeamErrorInvalid      TeamError = "INVALID"
	TeamErrorNotFound     TeamError = "NOT_FOUND"
	TeamErrorNameTooShort TeamError = "NAME_TOO_SHORT"
	TeamErrorNameTooLong  TeamError = "NAME_TOO_LONG"
)

var AllTeamError = []TeamError{
	TeamErrorNone,
	TeamErrorInvalid,
	TeamErrorNotFound,
	TeamErrorNameTooShort,
	TeamErrorNameTooLong,
}

func (e TeamError) IsValid() bool {
	switch e {
	case TeamErrorNone, TeamErrorInvalid, TeamErrorNotFound, TeamErrorNameTooShort, TeamErrorNameTooLong:
		return true
	}
	return false
}

func (e TeamError) String() string {
	return string(e)
}

func (e *TeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamError", str)
	}
	return nil
}

func (e TeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpdateRecordError string

const (
	UpdateRecordErrorNone         UpdateRecordError = "NONE"
	UpdateRecordErrorInvalid      UpdateRecordError = "INVALID"
	UpdateRecordErrorNotFound     UpdateRecordError = "NOT_FOUND"
	UpdateRecordErrorNameTooShort UpdateRecordError = "NAME_TOO_SHORT"
	UpdateRecordErrorNameTooLong  UpdateRecordError = "NAME_TOO_LONG"
)

var AllUpdateRecordError = []UpdateRecordError{
	UpdateRecordErrorNone,
	UpdateRecordErrorInvalid,
	UpdateRecordErrorNotFound,
	UpdateRecordErrorNameTooShort,
	UpdateRecordErrorNameTooLong,
}

func (e UpdateRecordError) IsValid() bool {
	switch e {
	case UpdateRecordErrorNone, UpdateRecordErrorInvalid, UpdateRecordErrorNotFound, UpdateRecordErrorNameTooShort, UpdateRecordErrorNameTooLong:
		return true
	}
	return false
}

func (e UpdateRecordError) String() string {
	return string(e)
}

func (e *UpdateRecordError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateRecordError", str)
	}
	return nil
}

func (e UpdateRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
