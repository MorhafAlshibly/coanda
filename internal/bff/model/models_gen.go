// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"

	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

type AddEventResultResponse struct {
	Success bool               `json:"success"`
	Error   AddEventRoundError `json:"error"`
}

type AddEventRoundRequest struct {
	Event         *EventRequest    `json:"event"`
	UserID        uint64           `json:"userId"`
	Result        uint64           `json:"result"`
	UserData      *structpb.Struct `json:"userData"`
	RoundUserData *structpb.Struct `json:"roundUserData"`
}

type CreateEventRequest struct {
	Name      string                 `json:"name"`
	Data      *structpb.Struct       `json:"data"`
	StartedAt *timestamppb.Timestamp `json:"startedAt"`
	Rounds    []*CreateEventRound    `json:"rounds"`
}

type CreateEventResponse struct {
	Success bool             `json:"success"`
	ID      uint64           `json:"id"`
	Error   CreateEventError `json:"error"`
}

type CreateEventRound struct {
	Name    string                 `json:"name"`
	Data    *structpb.Struct       `json:"data"`
	EndedAt *timestamppb.Timestamp `json:"endedAt"`
	Scoring []uint64               `json:"scoring"`
}

type CreateItemRequest struct {
	ID        string                 `json:"id"`
	Type      string                 `json:"type"`
	Data      *structpb.Struct       `json:"data"`
	ExpiresAt *timestamppb.Timestamp `json:"expiresAt,omitempty"`
}

type CreateItemResponse struct {
	Success bool            `json:"success"`
	Error   CreateItemError `json:"error"`
}

type CreateRecordRequest struct {
	Name   string           `json:"name"`
	UserID uint64           `json:"userId"`
	Record uint64           `json:"record"`
	Data   *structpb.Struct `json:"data"`
}

type CreateRecordResponse struct {
	Success bool              `json:"success"`
	ID      uint64            `json:"id"`
	Error   CreateRecordError `json:"error"`
}

type CreateTeamRequest struct {
	Name      string           `json:"name"`
	Owner     uint64           `json:"owner"`
	Score     *int64           `json:"score,omitempty"`
	Data      *structpb.Struct `json:"data"`
	OwnerData *structpb.Struct `json:"ownerData"`
}

type CreateTeamResponse struct {
	Success bool            `json:"success"`
	Error   CreateTeamError `json:"error"`
}

type CreateTournamentUserRequest struct {
	Tournament string             `json:"tournament"`
	Interval   TournamentInterval `json:"interval"`
	UserID     uint64             `json:"userId"`
	Score      *int64             `json:"score,omitempty"`
	Data       *structpb.Struct   `json:"data"`
}

type CreateTournamentUserResponse struct {
	Success bool                      `json:"success"`
	ID      uint64                    `json:"id"`
	Error   CreateTournamentUserError `json:"error"`
}

type DeleteRecordResponse struct {
	Success bool              `json:"success"`
	Error   DeleteRecordError `json:"error"`
}

type EventRequest struct {
	ID   *uint64 `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type GetItemResponse struct {
	Success bool         `json:"success"`
	Item    *Item        `json:"item"`
	Error   GetItemError `json:"error"`
}

type GetItemsRequest struct {
	Type       *string     `json:"type,omitempty"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

type GetItemsResponse struct {
	Success bool    `json:"success"`
	Items   []*Item `json:"items"`
}

type GetRecordResponse struct {
	Success bool           `json:"success"`
	Record  *Record        `json:"record"`
	Error   GetRecordError `json:"error"`
}

type GetRecordsRequest struct {
	Name       *string     `json:"name,omitempty"`
	UserID     *uint64     `json:"userId,omitempty"`
	Max        *uint32     `json:"max,omitempty"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

type GetRecordsResponse struct {
	Success bool            `json:"success"`
	Records []*Record       `json:"records"`
	Error   GetRecordsError `json:"error"`
}

type GetTeamMemberRequest struct {
	UserID uint64 `json:"userId"`
}

type GetTeamMemberResponse struct {
	Success    bool               `json:"success"`
	TeamMember *TeamMember        `json:"teamMember"`
	Error      GetTeamMemberError `json:"error"`
}

type GetTeamMembersRequest struct {
	Team       *TeamRequest `json:"team"`
	Pagination *Pagination  `json:"pagination,omitempty"`
}

type GetTeamMembersResponse struct {
	Success     bool                `json:"success"`
	TeamMembers []*TeamMember       `json:"teamMembers"`
	Error       GetTeamMembersError `json:"error"`
}

type GetTeamResponse struct {
	Success bool         `json:"success"`
	Team    *Team        `json:"team"`
	Error   GetTeamError `json:"error"`
}

type GetTeamsResponse struct {
	Success bool    `json:"success"`
	Teams   []*Team `json:"teams"`
}

type GetTournamentUserResponse struct {
	Success        bool                   `json:"success"`
	TournamentUser *TournamentUser        `json:"tournamentUser,omitempty"`
	Error          GetTournamentUserError `json:"error"`
}

type GetTournamentUsersRequest struct {
	Tournament *string            `json:"tournament,omitempty"`
	Interval   TournamentInterval `json:"interval"`
	UserID     *uint64            `json:"userId,omitempty"`
	Pagination *Pagination        `json:"pagination,omitempty"`
}

type GetTournamentUsersResponse struct {
	Success         bool                    `json:"success"`
	TournamentUsers []*TournamentUser       `json:"tournamentUsers,omitempty"`
	Error           GetTournamentUsersError `json:"error"`
}

type Item struct {
	ID        string                 `json:"id"`
	Type      string                 `json:"type"`
	Data      *structpb.Struct       `json:"data"`
	ExpiresAt *timestamppb.Timestamp `json:"expiresAt"`
	CreatedAt *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

type ItemRequest struct {
	ID   string `json:"id"`
	Type string `json:"type"`
}

type ItemResponse struct {
	Success bool      `json:"success"`
	Error   ItemError `json:"error"`
}

type JoinTeamRequest struct {
	Team   *TeamRequest     `json:"team"`
	UserID uint64           `json:"userId"`
	Data   *structpb.Struct `json:"data"`
}

type JoinTeamResponse struct {
	Success bool          `json:"success"`
	Error   JoinTeamError `json:"error"`
}

type LeaveTeamRequest struct {
	UserID uint64 `json:"userId"`
}

type LeaveTeamResponse struct {
	Success bool           `json:"success"`
	Error   LeaveTeamError `json:"error"`
}

type Mutation struct {
}

type NameUserID struct {
	Name   string `json:"name"`
	UserID uint64 `json:"userId"`
}

type Pagination struct {
	Max  *uint32 `json:"max,omitempty"`
	Page *uint64 `json:"page,omitempty"`
}

type Query struct {
}

type Record struct {
	ID        uint64                 `json:"id"`
	Name      string                 `json:"name"`
	UserID    uint64                 `json:"userId"`
	Record    uint64                 `json:"record"`
	Ranking   uint64                 `json:"ranking"`
	Data      *structpb.Struct       `json:"data"`
	CreatedAt *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

type RecordRequest struct {
	ID         *uint64     `json:"id,omitempty"`
	NameUserID *NameUserID `json:"nameUserId,omitempty"`
}

type SearchTeamsRequest struct {
	Query      string      `json:"query"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

type SearchTeamsResponse struct {
	Success bool             `json:"success"`
	Teams   []*Team          `json:"teams"`
	Error   SearchTeamsError `json:"error"`
}

type Team struct {
	Name      string                 `json:"name"`
	Owner     uint64                 `json:"owner"`
	Score     int64                  `json:"score"`
	Ranking   uint64                 `json:"ranking"`
	Data      *structpb.Struct       `json:"data"`
	CreatedAt *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

type TeamMember struct {
	Team      string                 `json:"team"`
	UserID    uint64                 `json:"userId"`
	Data      *structpb.Struct       `json:"data"`
	JoinedAt  *timestamppb.Timestamp `json:"joinedAt"`
	UpdatedAt *timestamppb.Timestamp `json:"updatedAt"`
}

type TeamRequest struct {
	Name   *string `json:"name,omitempty"`
	Owner  *uint64 `json:"owner,omitempty"`
	Member *uint64 `json:"member,omitempty"`
}

type TeamResponse struct {
	Success bool      `json:"success"`
	Error   TeamError `json:"error"`
}

type TournamentIntervalUserID struct {
	Tournament string             `json:"tournament"`
	Interval   TournamentInterval `json:"interval"`
	UserID     uint64             `json:"userId"`
}

type TournamentUser struct {
	ID                  uint64                 `json:"id"`
	Tournament          string                 `json:"tournament"`
	UserID              uint64                 `json:"userId"`
	Interval            TournamentInterval     `json:"interval"`
	Score               int64                  `json:"score"`
	Ranking             uint64                 `json:"ranking"`
	Data                *structpb.Struct       `json:"data"`
	TournamentStartedAt *timestamppb.Timestamp `json:"tournamentStartedAt"`
	CreatedAt           *timestamppb.Timestamp `json:"createdAt"`
	UpdatedAt           *timestamppb.Timestamp `json:"updatedAt"`
}

type TournamentUserRequest struct {
	ID                       *uint64                   `json:"id,omitempty"`
	TournamentIntervalUserID *TournamentIntervalUserID `json:"tournamentIntervalUserId,omitempty"`
}

type TournamentUserResponse struct {
	Success bool                `json:"success"`
	Error   TournamentUserError `json:"error"`
}

type UpdateItemRequest struct {
	Item      *ItemRequest           `json:"item"`
	Data      *structpb.Struct       `json:"data,omitempty"`
	ExpiresAt *timestamppb.Timestamp `json:"expiresAt,omitempty"`
}

type UpdateItemResponse struct {
	Success bool            `json:"success"`
	Error   UpdateItemError `json:"error"`
}

type UpdateRecordRequest struct {
	Request *RecordRequest   `json:"request"`
	Record  *uint64          `json:"record,omitempty"`
	Data    *structpb.Struct `json:"data,omitempty"`
}

type UpdateRecordResponse struct {
	Success bool              `json:"success"`
	Error   UpdateRecordError `json:"error"`
}

type UpdateTeamMemberRequest struct {
	UserID uint64           `json:"userId"`
	Data   *structpb.Struct `json:"data"`
}

type UpdateTeamMemberResponse struct {
	Success bool                  `json:"success"`
	Error   UpdateTeamMemberError `json:"error"`
}

type UpdateTeamRequest struct {
	Team           *TeamRequest     `json:"team"`
	Data           *structpb.Struct `json:"data,omitempty"`
	Score          *int64           `json:"score,omitempty"`
	IncrementScore *bool            `json:"incrementScore,omitempty"`
}

type UpdateTeamResponse struct {
	Success bool            `json:"success"`
	Error   UpdateTeamError `json:"error"`
}

type UpdateTournamentUserRequest struct {
	Tournament     *TournamentUserRequest `json:"tournament"`
	Data           *structpb.Struct       `json:"data,omitempty"`
	Score          *int64                 `json:"score,omitempty"`
	IncrementScore *bool                  `json:"incrementScore,omitempty"`
}

type UpdateTournamentUserResponse struct {
	Success bool                      `json:"success"`
	Error   UpdateTournamentUserError `json:"error"`
}

type AddEventRoundError string

const (
	AddEventRoundErrorNone                  AddEventRoundError = "NONE"
	AddEventRoundErrorNameTooShort          AddEventRoundError = "NAME_TOO_SHORT"
	AddEventRoundErrorNameTooLong           AddEventRoundError = "NAME_TOO_LONG"
	AddEventRoundErrorIDOrNameRequired      AddEventRoundError = "ID_OR_NAME_REQUIRED"
	AddEventRoundErrorUserIDRequired        AddEventRoundError = "USER_ID_REQUIRED"
	AddEventRoundErrorResultRequired        AddEventRoundError = "RESULT_REQUIRED"
	AddEventRoundErrorUserDataRequired      AddEventRoundError = "USER_DATA_REQUIRED"
	AddEventRoundErrorRoundUserDataRequired AddEventRoundError = "ROUND_USER_DATA_REQUIRED"
	AddEventRoundErrorNotFound              AddEventRoundError = "NOT_FOUND"
	AddEventRoundErrorEventEnded            AddEventRoundError = "EVENT_ENDED"
	AddEventRoundErrorAlreadyExists         AddEventRoundError = "ALREADY_EXISTS"
)

var AllAddEventRoundError = []AddEventRoundError{
	AddEventRoundErrorNone,
	AddEventRoundErrorNameTooShort,
	AddEventRoundErrorNameTooLong,
	AddEventRoundErrorIDOrNameRequired,
	AddEventRoundErrorUserIDRequired,
	AddEventRoundErrorResultRequired,
	AddEventRoundErrorUserDataRequired,
	AddEventRoundErrorRoundUserDataRequired,
	AddEventRoundErrorNotFound,
	AddEventRoundErrorEventEnded,
	AddEventRoundErrorAlreadyExists,
}

func (e AddEventRoundError) IsValid() bool {
	switch e {
	case AddEventRoundErrorNone, AddEventRoundErrorNameTooShort, AddEventRoundErrorNameTooLong, AddEventRoundErrorIDOrNameRequired, AddEventRoundErrorUserIDRequired, AddEventRoundErrorResultRequired, AddEventRoundErrorUserDataRequired, AddEventRoundErrorRoundUserDataRequired, AddEventRoundErrorNotFound, AddEventRoundErrorEventEnded, AddEventRoundErrorAlreadyExists:
		return true
	}
	return false
}

func (e AddEventRoundError) String() string {
	return string(e)
}

func (e *AddEventRoundError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddEventRoundError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddEventRoundError", str)
	}
	return nil
}

func (e AddEventRoundError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CreateEventError string

const (
	CreateEventErrorNone                        CreateEventError = "NONE"
	CreateEventErrorNameTooShort                CreateEventError = "NAME_TOO_SHORT"
	CreateEventErrorNameTooLong                 CreateEventError = "NAME_TOO_LONG"
	CreateEventErrorDataRequired                CreateEventError = "DATA_REQUIRED"
	CreateEventErrorStartedAtRequired           CreateEventError = "STARTED_AT_REQUIRED"
	CreateEventErrorStartedAtInThePast          CreateEventError = "STARTED_AT_IN_THE_PAST"
	CreateEventErrorRoundsRequired              CreateEventError = "ROUNDS_REQUIRED"
	CreateEventErrorTooManyRounds               CreateEventError = "TOO_MANY_ROUNDS"
	CreateEventErrorRoundNameTooShort           CreateEventError = "ROUND_NAME_TOO_SHORT"
	CreateEventErrorRoundNameTooLong            CreateEventError = "ROUND_NAME_TOO_LONG"
	CreateEventErrorRoundDataRequired           CreateEventError = "ROUND_DATA_REQUIRED"
	CreateEventErrorRoundEndedAtRequired        CreateEventError = "ROUND_ENDED_AT_REQUIRED"
	CreateEventErrorRoundEndedAtBeforeStartedAt CreateEventError = "ROUND_ENDED_AT_BEFORE_STARTED_AT"
	CreateEventErrorRoundScoringRequired        CreateEventError = "ROUND_SCORING_REQUIRED"
	CreateEventErrorAlreadyExists               CreateEventError = "ALREADY_EXISTS"
	CreateEventErrorDuplicateRoundNameOrEndedAt CreateEventError = "DUPLICATE_ROUND_NAME_OR_ENDED_AT"
)

var AllCreateEventError = []CreateEventError{
	CreateEventErrorNone,
	CreateEventErrorNameTooShort,
	CreateEventErrorNameTooLong,
	CreateEventErrorDataRequired,
	CreateEventErrorStartedAtRequired,
	CreateEventErrorStartedAtInThePast,
	CreateEventErrorRoundsRequired,
	CreateEventErrorTooManyRounds,
	CreateEventErrorRoundNameTooShort,
	CreateEventErrorRoundNameTooLong,
	CreateEventErrorRoundDataRequired,
	CreateEventErrorRoundEndedAtRequired,
	CreateEventErrorRoundEndedAtBeforeStartedAt,
	CreateEventErrorRoundScoringRequired,
	CreateEventErrorAlreadyExists,
	CreateEventErrorDuplicateRoundNameOrEndedAt,
}

func (e CreateEventError) IsValid() bool {
	switch e {
	case CreateEventErrorNone, CreateEventErrorNameTooShort, CreateEventErrorNameTooLong, CreateEventErrorDataRequired, CreateEventErrorStartedAtRequired, CreateEventErrorStartedAtInThePast, CreateEventErrorRoundsRequired, CreateEventErrorTooManyRounds, CreateEventErrorRoundNameTooShort, CreateEventErrorRoundNameTooLong, CreateEventErrorRoundDataRequired, CreateEventErrorRoundEndedAtRequired, CreateEventErrorRoundEndedAtBeforeStartedAt, CreateEventErrorRoundScoringRequired, CreateEventErrorAlreadyExists, CreateEventErrorDuplicateRoundNameOrEndedAt:
		return true
	}
	return false
}

func (e CreateEventError) String() string {
	return string(e)
}

func (e *CreateEventError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateEventError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateEventError", str)
	}
	return nil
}

func (e CreateEventError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CreateItemError string

const (
	CreateItemErrorNone          CreateItemError = "NONE"
	CreateItemErrorIDRequired    CreateItemError = "ID_REQUIRED"
	CreateItemErrorTypeRequired  CreateItemError = "TYPE_REQUIRED"
	CreateItemErrorDataRequired  CreateItemError = "DATA_REQUIRED"
	CreateItemErrorAlreadyExists CreateItemError = "ALREADY_EXISTS"
)

var AllCreateItemError = []CreateItemError{
	CreateItemErrorNone,
	CreateItemErrorIDRequired,
	CreateItemErrorTypeRequired,
	CreateItemErrorDataRequired,
	CreateItemErrorAlreadyExists,
}

func (e CreateItemError) IsValid() bool {
	switch e {
	case CreateItemErrorNone, CreateItemErrorIDRequired, CreateItemErrorTypeRequired, CreateItemErrorDataRequired, CreateItemErrorAlreadyExists:
		return true
	}
	return false
}

func (e CreateItemError) String() string {
	return string(e)
}

func (e *CreateItemError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateItemError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateItemError", str)
	}
	return nil
}

func (e CreateItemError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CreateRecordError string

const (
	CreateRecordErrorNone           CreateRecordError = "NONE"
	CreateRecordErrorNameTooShort   CreateRecordError = "NAME_TOO_SHORT"
	CreateRecordErrorNameTooLong    CreateRecordError = "NAME_TOO_LONG"
	CreateRecordErrorUserIDRequired CreateRecordError = "USER_ID_REQUIRED"
	CreateRecordErrorRecordRequired CreateRecordError = "RECORD_REQUIRED"
	CreateRecordErrorDataRequired   CreateRecordError = "DATA_REQUIRED"
	CreateRecordErrorRecordExists   CreateRecordError = "RECORD_EXISTS"
)

var AllCreateRecordError = []CreateRecordError{
	CreateRecordErrorNone,
	CreateRecordErrorNameTooShort,
	CreateRecordErrorNameTooLong,
	CreateRecordErrorUserIDRequired,
	CreateRecordErrorRecordRequired,
	CreateRecordErrorDataRequired,
	CreateRecordErrorRecordExists,
}

func (e CreateRecordError) IsValid() bool {
	switch e {
	case CreateRecordErrorNone, CreateRecordErrorNameTooShort, CreateRecordErrorNameTooLong, CreateRecordErrorUserIDRequired, CreateRecordErrorRecordRequired, CreateRecordErrorDataRequired, CreateRecordErrorRecordExists:
		return true
	}
	return false
}

func (e CreateRecordError) String() string {
	return string(e)
}

func (e *CreateRecordError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateRecordError", str)
	}
	return nil
}

func (e CreateRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CreateTeamError string

const (
	CreateTeamErrorNone                 CreateTeamError = "NONE"
	CreateTeamErrorOwnerRequired        CreateTeamError = "OWNER_REQUIRED"
	CreateTeamErrorNameTooShort         CreateTeamError = "NAME_TOO_SHORT"
	CreateTeamErrorNameTooLong          CreateTeamError = "NAME_TOO_LONG"
	CreateTeamErrorDataRequired         CreateTeamError = "DATA_REQUIRED"
	CreateTeamErrorOwnerDataRequired    CreateTeamError = "OWNER_DATA_REQUIRED"
	CreateTeamErrorNameTaken            CreateTeamError = "NAME_TAKEN"
	CreateTeamErrorOwnerOwnsAnotherTeam CreateTeamError = "OWNER_OWNS_ANOTHER_TEAM"
	CreateTeamErrorOwnerAlreadyInTeam   CreateTeamError = "OWNER_ALREADY_IN_TEAM"
)

var AllCreateTeamError = []CreateTeamError{
	CreateTeamErrorNone,
	CreateTeamErrorOwnerRequired,
	CreateTeamErrorNameTooShort,
	CreateTeamErrorNameTooLong,
	CreateTeamErrorDataRequired,
	CreateTeamErrorOwnerDataRequired,
	CreateTeamErrorNameTaken,
	CreateTeamErrorOwnerOwnsAnotherTeam,
	CreateTeamErrorOwnerAlreadyInTeam,
}

func (e CreateTeamError) IsValid() bool {
	switch e {
	case CreateTeamErrorNone, CreateTeamErrorOwnerRequired, CreateTeamErrorNameTooShort, CreateTeamErrorNameTooLong, CreateTeamErrorDataRequired, CreateTeamErrorOwnerDataRequired, CreateTeamErrorNameTaken, CreateTeamErrorOwnerOwnsAnotherTeam, CreateTeamErrorOwnerAlreadyInTeam:
		return true
	}
	return false
}

func (e CreateTeamError) String() string {
	return string(e)
}

func (e *CreateTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateTeamError", str)
	}
	return nil
}

func (e CreateTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CreateTournamentUserError string

const (
	CreateTournamentUserErrorNone                   CreateTournamentUserError = "NONE"
	CreateTournamentUserErrorTournamentNameTooShort CreateTournamentUserError = "TOURNAMENT_NAME_TOO_SHORT"
	CreateTournamentUserErrorTournamentNameTooLong  CreateTournamentUserError = "TOURNAMENT_NAME_TOO_LONG"
	CreateTournamentUserErrorUserIDRequired         CreateTournamentUserError = "USER_ID_REQUIRED"
	CreateTournamentUserErrorDataRequired           CreateTournamentUserError = "DATA_REQUIRED"
	CreateTournamentUserErrorAlreadyExists          CreateTournamentUserError = "ALREADY_EXISTS"
)

var AllCreateTournamentUserError = []CreateTournamentUserError{
	CreateTournamentUserErrorNone,
	CreateTournamentUserErrorTournamentNameTooShort,
	CreateTournamentUserErrorTournamentNameTooLong,
	CreateTournamentUserErrorUserIDRequired,
	CreateTournamentUserErrorDataRequired,
	CreateTournamentUserErrorAlreadyExists,
}

func (e CreateTournamentUserError) IsValid() bool {
	switch e {
	case CreateTournamentUserErrorNone, CreateTournamentUserErrorTournamentNameTooShort, CreateTournamentUserErrorTournamentNameTooLong, CreateTournamentUserErrorUserIDRequired, CreateTournamentUserErrorDataRequired, CreateTournamentUserErrorAlreadyExists:
		return true
	}
	return false
}

func (e CreateTournamentUserError) String() string {
	return string(e)
}

func (e *CreateTournamentUserError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateTournamentUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateTournamentUserError", str)
	}
	return nil
}

func (e CreateTournamentUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeleteRecordError string

const (
	DeleteRecordErrorNone                   DeleteRecordError = "NONE"
	DeleteRecordErrorIDOrNameUserIDRequired DeleteRecordError = "ID_OR_NAME_USER_ID_REQUIRED"
	DeleteRecordErrorNotFound               DeleteRecordError = "NOT_FOUND"
	DeleteRecordErrorNameTooShort           DeleteRecordError = "NAME_TOO_SHORT"
	DeleteRecordErrorNameTooLong            DeleteRecordError = "NAME_TOO_LONG"
	DeleteRecordErrorUserIDRequired         DeleteRecordError = "USER_ID_REQUIRED"
)

var AllDeleteRecordError = []DeleteRecordError{
	DeleteRecordErrorNone,
	DeleteRecordErrorIDOrNameUserIDRequired,
	DeleteRecordErrorNotFound,
	DeleteRecordErrorNameTooShort,
	DeleteRecordErrorNameTooLong,
	DeleteRecordErrorUserIDRequired,
}

func (e DeleteRecordError) IsValid() bool {
	switch e {
	case DeleteRecordErrorNone, DeleteRecordErrorIDOrNameUserIDRequired, DeleteRecordErrorNotFound, DeleteRecordErrorNameTooShort, DeleteRecordErrorNameTooLong, DeleteRecordErrorUserIDRequired:
		return true
	}
	return false
}

func (e DeleteRecordError) String() string {
	return string(e)
}

func (e *DeleteRecordError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteRecordError", str)
	}
	return nil
}

func (e DeleteRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetItemError string

const (
	GetItemErrorNone         GetItemError = "NONE"
	GetItemErrorIDRequired   GetItemError = "ID_REQUIRED"
	GetItemErrorTypeRequired GetItemError = "TYPE_REQUIRED"
	GetItemErrorNotFound     GetItemError = "NOT_FOUND"
)

var AllGetItemError = []GetItemError{
	GetItemErrorNone,
	GetItemErrorIDRequired,
	GetItemErrorTypeRequired,
	GetItemErrorNotFound,
}

func (e GetItemError) IsValid() bool {
	switch e {
	case GetItemErrorNone, GetItemErrorIDRequired, GetItemErrorTypeRequired, GetItemErrorNotFound:
		return true
	}
	return false
}

func (e GetItemError) String() string {
	return string(e)
}

func (e *GetItemError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetItemError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetItemError", str)
	}
	return nil
}

func (e GetItemError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetRecordError string

const (
	GetRecordErrorNone                   GetRecordError = "NONE"
	GetRecordErrorIDOrNameUserIDRequired GetRecordError = "ID_OR_NAME_USER_ID_REQUIRED"
	GetRecordErrorNotFound               GetRecordError = "NOT_FOUND"
	GetRecordErrorNameTooShort           GetRecordError = "NAME_TOO_SHORT"
	GetRecordErrorNameTooLong            GetRecordError = "NAME_TOO_LONG"
	GetRecordErrorUserIDRequired         GetRecordError = "USER_ID_REQUIRED"
)

var AllGetRecordError = []GetRecordError{
	GetRecordErrorNone,
	GetRecordErrorIDOrNameUserIDRequired,
	GetRecordErrorNotFound,
	GetRecordErrorNameTooShort,
	GetRecordErrorNameTooLong,
	GetRecordErrorUserIDRequired,
}

func (e GetRecordError) IsValid() bool {
	switch e {
	case GetRecordErrorNone, GetRecordErrorIDOrNameUserIDRequired, GetRecordErrorNotFound, GetRecordErrorNameTooShort, GetRecordErrorNameTooLong, GetRecordErrorUserIDRequired:
		return true
	}
	return false
}

func (e GetRecordError) String() string {
	return string(e)
}

func (e *GetRecordError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetRecordError", str)
	}
	return nil
}

func (e GetRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetRecordsError string

const (
	GetRecordsErrorNone         GetRecordsError = "NONE"
	GetRecordsErrorNameTooShort GetRecordsError = "NAME_TOO_SHORT"
	GetRecordsErrorNameTooLong  GetRecordsError = "NAME_TOO_LONG"
)

var AllGetRecordsError = []GetRecordsError{
	GetRecordsErrorNone,
	GetRecordsErrorNameTooShort,
	GetRecordsErrorNameTooLong,
}

func (e GetRecordsError) IsValid() bool {
	switch e {
	case GetRecordsErrorNone, GetRecordsErrorNameTooShort, GetRecordsErrorNameTooLong:
		return true
	}
	return false
}

func (e GetRecordsError) String() string {
	return string(e)
}

func (e *GetRecordsError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetRecordsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetRecordsError", str)
	}
	return nil
}

func (e GetRecordsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetTeamError string

const (
	GetTeamErrorNone             GetTeamError = "NONE"
	GetTeamErrorNoFieldSpecified GetTeamError = "NO_FIELD_SPECIFIED"
	GetTeamErrorNotFound         GetTeamError = "NOT_FOUND"
	GetTeamErrorNameTooShort     GetTeamError = "NAME_TOO_SHORT"
	GetTeamErrorNameTooLong      GetTeamError = "NAME_TOO_LONG"
)

var AllGetTeamError = []GetTeamError{
	GetTeamErrorNone,
	GetTeamErrorNoFieldSpecified,
	GetTeamErrorNotFound,
	GetTeamErrorNameTooShort,
	GetTeamErrorNameTooLong,
}

func (e GetTeamError) IsValid() bool {
	switch e {
	case GetTeamErrorNone, GetTeamErrorNoFieldSpecified, GetTeamErrorNotFound, GetTeamErrorNameTooShort, GetTeamErrorNameTooLong:
		return true
	}
	return false
}

func (e GetTeamError) String() string {
	return string(e)
}

func (e *GetTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTeamError", str)
	}
	return nil
}

func (e GetTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetTeamMemberError string

const (
	GetTeamMemberErrorNone           GetTeamMemberError = "NONE"
	GetTeamMemberErrorUserIDRequired GetTeamMemberError = "USER_ID_REQUIRED"
	GetTeamMemberErrorNotFound       GetTeamMemberError = "NOT_FOUND"
)

var AllGetTeamMemberError = []GetTeamMemberError{
	GetTeamMemberErrorNone,
	GetTeamMemberErrorUserIDRequired,
	GetTeamMemberErrorNotFound,
}

func (e GetTeamMemberError) IsValid() bool {
	switch e {
	case GetTeamMemberErrorNone, GetTeamMemberErrorUserIDRequired, GetTeamMemberErrorNotFound:
		return true
	}
	return false
}

func (e GetTeamMemberError) String() string {
	return string(e)
}

func (e *GetTeamMemberError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTeamMemberError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTeamMemberError", str)
	}
	return nil
}

func (e GetTeamMemberError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetTeamMembersError string

const (
	GetTeamMembersErrorNone             GetTeamMembersError = "NONE"
	GetTeamMembersErrorNoFieldSpecified GetTeamMembersError = "NO_FIELD_SPECIFIED"
	GetTeamMembersErrorNotFound         GetTeamMembersError = "NOT_FOUND"
	GetTeamMembersErrorNameTooShort     GetTeamMembersError = "NAME_TOO_SHORT"
	GetTeamMembersErrorNameTooLong      GetTeamMembersError = "NAME_TOO_LONG"
)

var AllGetTeamMembersError = []GetTeamMembersError{
	GetTeamMembersErrorNone,
	GetTeamMembersErrorNoFieldSpecified,
	GetTeamMembersErrorNotFound,
	GetTeamMembersErrorNameTooShort,
	GetTeamMembersErrorNameTooLong,
}

func (e GetTeamMembersError) IsValid() bool {
	switch e {
	case GetTeamMembersErrorNone, GetTeamMembersErrorNoFieldSpecified, GetTeamMembersErrorNotFound, GetTeamMembersErrorNameTooShort, GetTeamMembersErrorNameTooLong:
		return true
	}
	return false
}

func (e GetTeamMembersError) String() string {
	return string(e)
}

func (e *GetTeamMembersError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTeamMembersError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTeamMembersError", str)
	}
	return nil
}

func (e GetTeamMembersError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetTournamentUserError string

const (
	GetTournamentUserErrorNone                                 GetTournamentUserError = "NONE"
	GetTournamentUserErrorIDOrTournamentIntervalUserIDRequired GetTournamentUserError = "ID_OR_TOURNAMENT_INTERVAL_USER_ID_REQUIRED"
	GetTournamentUserErrorTournamentNameTooShort               GetTournamentUserError = "TOURNAMENT_NAME_TOO_SHORT"
	GetTournamentUserErrorTournamentNameTooLong                GetTournamentUserError = "TOURNAMENT_NAME_TOO_LONG"
	GetTournamentUserErrorUserIDRequired                       GetTournamentUserError = "USER_ID_REQUIRED"
	GetTournamentUserErrorNotFound                             GetTournamentUserError = "NOT_FOUND"
)

var AllGetTournamentUserError = []GetTournamentUserError{
	GetTournamentUserErrorNone,
	GetTournamentUserErrorIDOrTournamentIntervalUserIDRequired,
	GetTournamentUserErrorTournamentNameTooShort,
	GetTournamentUserErrorTournamentNameTooLong,
	GetTournamentUserErrorUserIDRequired,
	GetTournamentUserErrorNotFound,
}

func (e GetTournamentUserError) IsValid() bool {
	switch e {
	case GetTournamentUserErrorNone, GetTournamentUserErrorIDOrTournamentIntervalUserIDRequired, GetTournamentUserErrorTournamentNameTooShort, GetTournamentUserErrorTournamentNameTooLong, GetTournamentUserErrorUserIDRequired, GetTournamentUserErrorNotFound:
		return true
	}
	return false
}

func (e GetTournamentUserError) String() string {
	return string(e)
}

func (e *GetTournamentUserError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTournamentUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTournamentUserError", str)
	}
	return nil
}

func (e GetTournamentUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GetTournamentUsersError string

const (
	GetTournamentUsersErrorNone                   GetTournamentUsersError = "NONE"
	GetTournamentUsersErrorTournamentNameTooShort GetTournamentUsersError = "TOURNAMENT_NAME_TOO_SHORT"
	GetTournamentUsersErrorTournamentNameTooLong  GetTournamentUsersError = "TOURNAMENT_NAME_TOO_LONG"
)

var AllGetTournamentUsersError = []GetTournamentUsersError{
	GetTournamentUsersErrorNone,
	GetTournamentUsersErrorTournamentNameTooShort,
	GetTournamentUsersErrorTournamentNameTooLong,
}

func (e GetTournamentUsersError) IsValid() bool {
	switch e {
	case GetTournamentUsersErrorNone, GetTournamentUsersErrorTournamentNameTooShort, GetTournamentUsersErrorTournamentNameTooLong:
		return true
	}
	return false
}

func (e GetTournamentUsersError) String() string {
	return string(e)
}

func (e *GetTournamentUsersError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetTournamentUsersError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetTournamentUsersError", str)
	}
	return nil
}

func (e GetTournamentUsersError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ItemError string

const (
	ItemErrorNone         ItemError = "NONE"
	ItemErrorIDRequired   ItemError = "ID_REQUIRED"
	ItemErrorTypeRequired ItemError = "TYPE_REQUIRED"
	ItemErrorNotFound     ItemError = "NOT_FOUND"
)

var AllItemError = []ItemError{
	ItemErrorNone,
	ItemErrorIDRequired,
	ItemErrorTypeRequired,
	ItemErrorNotFound,
}

func (e ItemError) IsValid() bool {
	switch e {
	case ItemErrorNone, ItemErrorIDRequired, ItemErrorTypeRequired, ItemErrorNotFound:
		return true
	}
	return false
}

func (e ItemError) String() string {
	return string(e)
}

func (e *ItemError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemError", str)
	}
	return nil
}

func (e ItemError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type JoinTeamError string

const (
	JoinTeamErrorNone             JoinTeamError = "NONE"
	JoinTeamErrorNoFieldSpecified JoinTeamError = "NO_FIELD_SPECIFIED"
	JoinTeamErrorUserIDRequired   JoinTeamError = "USER_ID_REQUIRED"
	JoinTeamErrorDataRequired     JoinTeamError = "DATA_REQUIRED"
	JoinTeamErrorNameTooShort     JoinTeamError = "NAME_TOO_SHORT"
	JoinTeamErrorNameTooLong      JoinTeamError = "NAME_TOO_LONG"
	JoinTeamErrorNotFound         JoinTeamError = "NOT_FOUND"
	JoinTeamErrorTeamFull         JoinTeamError = "TEAM_FULL"
	JoinTeamErrorAlreadyInATeam   JoinTeamError = "ALREADY_IN_A_TEAM"
)

var AllJoinTeamError = []JoinTeamError{
	JoinTeamErrorNone,
	JoinTeamErrorNoFieldSpecified,
	JoinTeamErrorUserIDRequired,
	JoinTeamErrorDataRequired,
	JoinTeamErrorNameTooShort,
	JoinTeamErrorNameTooLong,
	JoinTeamErrorNotFound,
	JoinTeamErrorTeamFull,
	JoinTeamErrorAlreadyInATeam,
}

func (e JoinTeamError) IsValid() bool {
	switch e {
	case JoinTeamErrorNone, JoinTeamErrorNoFieldSpecified, JoinTeamErrorUserIDRequired, JoinTeamErrorDataRequired, JoinTeamErrorNameTooShort, JoinTeamErrorNameTooLong, JoinTeamErrorNotFound, JoinTeamErrorTeamFull, JoinTeamErrorAlreadyInATeam:
		return true
	}
	return false
}

func (e JoinTeamError) String() string {
	return string(e)
}

func (e *JoinTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JoinTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JoinTeamError", str)
	}
	return nil
}

func (e JoinTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LeaveTeamError string

const (
	LeaveTeamErrorNone           LeaveTeamError = "NONE"
	LeaveTeamErrorUserIDRequired LeaveTeamError = "USER_ID_REQUIRED"
	LeaveTeamErrorNotInTeam      LeaveTeamError = "NOT_IN_TEAM"
	LeaveTeamErrorMemberIsOwner  LeaveTeamError = "MEMBER_IS_OWNER"
)

var AllLeaveTeamError = []LeaveTeamError{
	LeaveTeamErrorNone,
	LeaveTeamErrorUserIDRequired,
	LeaveTeamErrorNotInTeam,
	LeaveTeamErrorMemberIsOwner,
}

func (e LeaveTeamError) IsValid() bool {
	switch e {
	case LeaveTeamErrorNone, LeaveTeamErrorUserIDRequired, LeaveTeamErrorNotInTeam, LeaveTeamErrorMemberIsOwner:
		return true
	}
	return false
}

func (e LeaveTeamError) String() string {
	return string(e)
}

func (e *LeaveTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LeaveTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LeaveTeamError", str)
	}
	return nil
}

func (e LeaveTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SearchTeamsError string

const (
	SearchTeamsErrorNone          SearchTeamsError = "NONE"
	SearchTeamsErrorQueryTooShort SearchTeamsError = "QUERY_TOO_SHORT"
	SearchTeamsErrorQueryTooLong  SearchTeamsError = "QUERY_TOO_LONG"
)

var AllSearchTeamsError = []SearchTeamsError{
	SearchTeamsErrorNone,
	SearchTeamsErrorQueryTooShort,
	SearchTeamsErrorQueryTooLong,
}

func (e SearchTeamsError) IsValid() bool {
	switch e {
	case SearchTeamsErrorNone, SearchTeamsErrorQueryTooShort, SearchTeamsErrorQueryTooLong:
		return true
	}
	return false
}

func (e SearchTeamsError) String() string {
	return string(e)
}

func (e *SearchTeamsError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchTeamsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchTeamsError", str)
	}
	return nil
}

func (e SearchTeamsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TeamError string

const (
	TeamErrorNone             TeamError = "NONE"
	TeamErrorNoFieldSpecified TeamError = "NO_FIELD_SPECIFIED"
	TeamErrorNotFound         TeamError = "NOT_FOUND"
	TeamErrorNameTooShort     TeamError = "NAME_TOO_SHORT"
	TeamErrorNameTooLong      TeamError = "NAME_TOO_LONG"
)

var AllTeamError = []TeamError{
	TeamErrorNone,
	TeamErrorNoFieldSpecified,
	TeamErrorNotFound,
	TeamErrorNameTooShort,
	TeamErrorNameTooLong,
}

func (e TeamError) IsValid() bool {
	switch e {
	case TeamErrorNone, TeamErrorNoFieldSpecified, TeamErrorNotFound, TeamErrorNameTooShort, TeamErrorNameTooLong:
		return true
	}
	return false
}

func (e TeamError) String() string {
	return string(e)
}

func (e *TeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamError", str)
	}
	return nil
}

func (e TeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TournamentInterval string

const (
	TournamentIntervalDaily     TournamentInterval = "DAILY"
	TournamentIntervalWeekly    TournamentInterval = "WEEKLY"
	TournamentIntervalMonthly   TournamentInterval = "MONTHLY"
	TournamentIntervalUnlimited TournamentInterval = "UNLIMITED"
)

var AllTournamentInterval = []TournamentInterval{
	TournamentIntervalDaily,
	TournamentIntervalWeekly,
	TournamentIntervalMonthly,
	TournamentIntervalUnlimited,
}

func (e TournamentInterval) IsValid() bool {
	switch e {
	case TournamentIntervalDaily, TournamentIntervalWeekly, TournamentIntervalMonthly, TournamentIntervalUnlimited:
		return true
	}
	return false
}

func (e TournamentInterval) String() string {
	return string(e)
}

func (e *TournamentInterval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TournamentInterval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TournamentInterval", str)
	}
	return nil
}

func (e TournamentInterval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TournamentUserError string

const (
	TournamentUserErrorNone                                 TournamentUserError = "NONE"
	TournamentUserErrorIDOrTournamentIntervalUserIDRequired TournamentUserError = "ID_OR_TOURNAMENT_INTERVAL_USER_ID_REQUIRED"
	TournamentUserErrorTournamentNameTooShort               TournamentUserError = "TOURNAMENT_NAME_TOO_SHORT"
	TournamentUserErrorTournamentNameTooLong                TournamentUserError = "TOURNAMENT_NAME_TOO_LONG"
	TournamentUserErrorUserIDRequired                       TournamentUserError = "USER_ID_REQUIRED"
	TournamentUserErrorNotFound                             TournamentUserError = "NOT_FOUND"
)

var AllTournamentUserError = []TournamentUserError{
	TournamentUserErrorNone,
	TournamentUserErrorIDOrTournamentIntervalUserIDRequired,
	TournamentUserErrorTournamentNameTooShort,
	TournamentUserErrorTournamentNameTooLong,
	TournamentUserErrorUserIDRequired,
	TournamentUserErrorNotFound,
}

func (e TournamentUserError) IsValid() bool {
	switch e {
	case TournamentUserErrorNone, TournamentUserErrorIDOrTournamentIntervalUserIDRequired, TournamentUserErrorTournamentNameTooShort, TournamentUserErrorTournamentNameTooLong, TournamentUserErrorUserIDRequired, TournamentUserErrorNotFound:
		return true
	}
	return false
}

func (e TournamentUserError) String() string {
	return string(e)
}

func (e *TournamentUserError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TournamentUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TournamentUserError", str)
	}
	return nil
}

func (e TournamentUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpdateItemError string

const (
	UpdateItemErrorNone              UpdateItemError = "NONE"
	UpdateItemErrorIDRequired        UpdateItemError = "ID_REQUIRED"
	UpdateItemErrorTypeRequired      UpdateItemError = "TYPE_REQUIRED"
	UpdateItemErrorNotFound          UpdateItemError = "NOT_FOUND"
	UpdateItemErrorNoUpdateSpecified UpdateItemError = "NO_UPDATE_SPECIFIED"
)

var AllUpdateItemError = []UpdateItemError{
	UpdateItemErrorNone,
	UpdateItemErrorIDRequired,
	UpdateItemErrorTypeRequired,
	UpdateItemErrorNotFound,
	UpdateItemErrorNoUpdateSpecified,
}

func (e UpdateItemError) IsValid() bool {
	switch e {
	case UpdateItemErrorNone, UpdateItemErrorIDRequired, UpdateItemErrorTypeRequired, UpdateItemErrorNotFound, UpdateItemErrorNoUpdateSpecified:
		return true
	}
	return false
}

func (e UpdateItemError) String() string {
	return string(e)
}

func (e *UpdateItemError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateItemError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateItemError", str)
	}
	return nil
}

func (e UpdateItemError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpdateRecordError string

const (
	UpdateRecordErrorNone                   UpdateRecordError = "NONE"
	UpdateRecordErrorIDOrNameUserIDRequired UpdateRecordError = "ID_OR_NAME_USER_ID_REQUIRED"
	UpdateRecordErrorNotFound               UpdateRecordError = "NOT_FOUND"
	UpdateRecordErrorNameTooShort           UpdateRecordError = "NAME_TOO_SHORT"
	UpdateRecordErrorNameTooLong            UpdateRecordError = "NAME_TOO_LONG"
	UpdateRecordErrorUserIDRequired         UpdateRecordError = "USER_ID_REQUIRED"
	UpdateRecordErrorNoUpdateSpecified      UpdateRecordError = "NO_UPDATE_SPECIFIED"
)

var AllUpdateRecordError = []UpdateRecordError{
	UpdateRecordErrorNone,
	UpdateRecordErrorIDOrNameUserIDRequired,
	UpdateRecordErrorNotFound,
	UpdateRecordErrorNameTooShort,
	UpdateRecordErrorNameTooLong,
	UpdateRecordErrorUserIDRequired,
	UpdateRecordErrorNoUpdateSpecified,
}

func (e UpdateRecordError) IsValid() bool {
	switch e {
	case UpdateRecordErrorNone, UpdateRecordErrorIDOrNameUserIDRequired, UpdateRecordErrorNotFound, UpdateRecordErrorNameTooShort, UpdateRecordErrorNameTooLong, UpdateRecordErrorUserIDRequired, UpdateRecordErrorNoUpdateSpecified:
		return true
	}
	return false
}

func (e UpdateRecordError) String() string {
	return string(e)
}

func (e *UpdateRecordError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateRecordError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateRecordError", str)
	}
	return nil
}

func (e UpdateRecordError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpdateTeamError string

const (
	UpdateTeamErrorNone                       UpdateTeamError = "NONE"
	UpdateTeamErrorNoFieldSpecified           UpdateTeamError = "NO_FIELD_SPECIFIED"
	UpdateTeamErrorNotFound                   UpdateTeamError = "NOT_FOUND"
	UpdateTeamErrorNameTooShort               UpdateTeamError = "NAME_TOO_SHORT"
	UpdateTeamErrorNameTooLong                UpdateTeamError = "NAME_TOO_LONG"
	UpdateTeamErrorNoUpdateSpecified          UpdateTeamError = "NO_UPDATE_SPECIFIED"
	UpdateTeamErrorIncrementScoreNotSpecified UpdateTeamError = "INCREMENT_SCORE_NOT_SPECIFIED"
)

var AllUpdateTeamError = []UpdateTeamError{
	UpdateTeamErrorNone,
	UpdateTeamErrorNoFieldSpecified,
	UpdateTeamErrorNotFound,
	UpdateTeamErrorNameTooShort,
	UpdateTeamErrorNameTooLong,
	UpdateTeamErrorNoUpdateSpecified,
	UpdateTeamErrorIncrementScoreNotSpecified,
}

func (e UpdateTeamError) IsValid() bool {
	switch e {
	case UpdateTeamErrorNone, UpdateTeamErrorNoFieldSpecified, UpdateTeamErrorNotFound, UpdateTeamErrorNameTooShort, UpdateTeamErrorNameTooLong, UpdateTeamErrorNoUpdateSpecified, UpdateTeamErrorIncrementScoreNotSpecified:
		return true
	}
	return false
}

func (e UpdateTeamError) String() string {
	return string(e)
}

func (e *UpdateTeamError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateTeamError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateTeamError", str)
	}
	return nil
}

func (e UpdateTeamError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpdateTeamMemberError string

const (
	UpdateTeamMemberErrorNone           UpdateTeamMemberError = "NONE"
	UpdateTeamMemberErrorUserIDRequired UpdateTeamMemberError = "USER_ID_REQUIRED"
	UpdateTeamMemberErrorDataRequired   UpdateTeamMemberError = "DATA_REQUIRED"
	UpdateTeamMemberErrorNotFound       UpdateTeamMemberError = "NOT_FOUND"
)

var AllUpdateTeamMemberError = []UpdateTeamMemberError{
	UpdateTeamMemberErrorNone,
	UpdateTeamMemberErrorUserIDRequired,
	UpdateTeamMemberErrorDataRequired,
	UpdateTeamMemberErrorNotFound,
}

func (e UpdateTeamMemberError) IsValid() bool {
	switch e {
	case UpdateTeamMemberErrorNone, UpdateTeamMemberErrorUserIDRequired, UpdateTeamMemberErrorDataRequired, UpdateTeamMemberErrorNotFound:
		return true
	}
	return false
}

func (e UpdateTeamMemberError) String() string {
	return string(e)
}

func (e *UpdateTeamMemberError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateTeamMemberError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateTeamMemberError", str)
	}
	return nil
}

func (e UpdateTeamMemberError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpdateTournamentUserError string

const (
	UpdateTournamentUserErrorNone                                 UpdateTournamentUserError = "NONE"
	UpdateTournamentUserErrorIDOrTournamentIntervalUserIDRequired UpdateTournamentUserError = "ID_OR_TOURNAMENT_INTERVAL_USER_ID_REQUIRED"
	UpdateTournamentUserErrorTournamentNameTooShort               UpdateTournamentUserError = "TOURNAMENT_NAME_TOO_SHORT"
	UpdateTournamentUserErrorTournamentNameTooLong                UpdateTournamentUserError = "TOURNAMENT_NAME_TOO_LONG"
	UpdateTournamentUserErrorUserIDRequired                       UpdateTournamentUserError = "USER_ID_REQUIRED"
	UpdateTournamentUserErrorNotFound                             UpdateTournamentUserError = "NOT_FOUND"
	UpdateTournamentUserErrorNoUpdateSpecified                    UpdateTournamentUserError = "NO_UPDATE_SPECIFIED"
	UpdateTournamentUserErrorIncrementScoreNotSpecified           UpdateTournamentUserError = "INCREMENT_SCORE_NOT_SPECIFIED"
)

var AllUpdateTournamentUserError = []UpdateTournamentUserError{
	UpdateTournamentUserErrorNone,
	UpdateTournamentUserErrorIDOrTournamentIntervalUserIDRequired,
	UpdateTournamentUserErrorTournamentNameTooShort,
	UpdateTournamentUserErrorTournamentNameTooLong,
	UpdateTournamentUserErrorUserIDRequired,
	UpdateTournamentUserErrorNotFound,
	UpdateTournamentUserErrorNoUpdateSpecified,
	UpdateTournamentUserErrorIncrementScoreNotSpecified,
}

func (e UpdateTournamentUserError) IsValid() bool {
	switch e {
	case UpdateTournamentUserErrorNone, UpdateTournamentUserErrorIDOrTournamentIntervalUserIDRequired, UpdateTournamentUserErrorTournamentNameTooShort, UpdateTournamentUserErrorTournamentNameTooLong, UpdateTournamentUserErrorUserIDRequired, UpdateTournamentUserErrorNotFound, UpdateTournamentUserErrorNoUpdateSpecified, UpdateTournamentUserErrorIncrementScoreNotSpecified:
		return true
	}
	return false
}

func (e UpdateTournamentUserError) String() string {
	return string(e)
}

func (e *UpdateTournamentUserError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateTournamentUserError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateTournamentUserError", str)
	}
	return nil
}

func (e UpdateTournamentUserError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
