package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"context"

	"github.com/MorhafAlshibly/coanda/api"
	"github.com/MorhafAlshibly/coanda/internal/bff/model"
)

// CreateItem is the resolver for the CreateItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input model.CreateItemRequest) (*model.CreateItemResponse, error) {
	resp, err := r.itemClient.CreateItem(ctx, &api.CreateItemRequest{
		Type:     input.Type,
		Data:     input.Data,
		ExpireAt: input.ExpireAt,
	})
	if err != nil {
		return nil, err
	}
	var item *model.Item
	if resp.Item != nil {
		item = &model.Item{
			ID:       resp.Item.Id,
			Type:     resp.Item.Type,
			Data:     resp.Item.Data,
			ExpireAt: resp.Item.ExpireAt,
		}
	}
	return &model.CreateItemResponse{
		Success: resp.Success,
		Item:    item,
		Error:   model.CreateItemError(resp.Error.String()),
	}, nil
}

// GetItem is the resolver for the GetItem field.
func (r *queryResolver) GetItem(ctx context.Context, input model.GetItemRequest) (*model.GetItemResponse, error) {
	resp, err := r.itemClient.GetItem(ctx, &api.GetItemRequest{
		Id:   input.ID,
		Type: input.Type,
	})
	if err != nil {
		return nil, err
	}
	var item *model.Item
	if resp.Item != nil {
		item = &model.Item{
			ID:       resp.Item.Id,
			Type:     resp.Item.Type,
			Data:     resp.Item.Data,
			ExpireAt: resp.Item.ExpireAt,
		}
	}
	return &model.GetItemResponse{
		Success: resp.Success,
		Item:    item,
		Error:   model.GetItemError(resp.Error.String()),
	}, nil
}

// GetItems is the resolver for the GetItems field.
func (r *queryResolver) GetItems(ctx context.Context, input model.GetItemsRequest) (*model.GetItemsResponse, error) {
	resp, err := r.itemClient.GetItems(ctx, &api.GetItemsRequest{
		Type:            input.Type,
		Max:             input.Max,
		LastEvaluatedId: input.LastEvaluatedID,
	})
	if err != nil {
		return nil, err
	}
	items := make([]*model.Item, len(resp.Items))
	for i, item := range resp.Items {
		items[i] = &model.Item{
			ID:       item.Id,
			Type:     item.Type,
			Data:     item.Data,
			ExpireAt: item.ExpireAt,
		}
	}
	return &model.GetItemsResponse{
		Success: resp.Success,
		Items:   items,
		Error:   model.GetItemsError(resp.Error.String()),
	}, nil
}
