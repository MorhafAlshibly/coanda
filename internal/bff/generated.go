// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package bff

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/MorhafAlshibly/coanda/api"
	"github.com/MorhafAlshibly/coanda/internal/bff/model"
	"github.com/MorhafAlshibly/coanda/pkg/graphqlEnums"
	"github.com/MorhafAlshibly/coanda/pkg/scalar"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AddEventResultResponse() AddEventResultResponseResolver
	CompleteTaskResponse() CompleteTaskResponseResolver
	CreateArenaResponse() CreateArenaResponseResolver
	CreateEventResponse() CreateEventResponseResolver
	CreateEventRoundResponse() CreateEventRoundResponseResolver
	CreateItemResponse() CreateItemResponseResolver
	CreateMatchmakingTicketResponse() CreateMatchmakingTicketResponseResolver
	CreateMatchmakingUserResponse() CreateMatchmakingUserResponseResolver
	CreateRecordResponse() CreateRecordResponseResolver
	CreateTaskResponse() CreateTaskResponseResolver
	CreateTeamResponse() CreateTeamResponseResolver
	CreateTournamentUserResponse() CreateTournamentUserResponseResolver
	DeleteMatchResponse() DeleteMatchResponseResolver
	DeleteMatchmakingTicketResponse() DeleteMatchmakingTicketResponseResolver
	DeleteMatchmakingUserResponse() DeleteMatchmakingUserResponseResolver
	DeleteRecordResponse() DeleteRecordResponseResolver
	EndMatchResponse() EndMatchResponseResolver
	EventResponse() EventResponseResolver
	EventUserResponse() EventUserResponseResolver
	GetArenaResponse() GetArenaResponseResolver
	GetEventResponse() GetEventResponseResolver
	GetEventRoundResponse() GetEventRoundResponseResolver
	GetEventUserResponse() GetEventUserResponseResolver
	GetItemResponse() GetItemResponseResolver
	GetMatchResponse() GetMatchResponseResolver
	GetMatchmakingTicketResponse() GetMatchmakingTicketResponseResolver
	GetMatchmakingTicketsResponse() GetMatchmakingTicketsResponseResolver
	GetMatchmakingUserResponse() GetMatchmakingUserResponseResolver
	GetRecordResponse() GetRecordResponseResolver
	GetRecordsResponse() GetRecordsResponseResolver
	GetTaskResponse() GetTaskResponseResolver
	GetTeamMemberResponse() GetTeamMemberResponseResolver
	GetTeamResponse() GetTeamResponseResolver
	GetTournamentUserResponse() GetTournamentUserResponseResolver
	GetTournamentUsersResponse() GetTournamentUsersResponseResolver
	ItemResponse() ItemResponseResolver
	JoinTeamResponse() JoinTeamResponseResolver
	LeaveTeamResponse() LeaveTeamResponseResolver
	Match() MatchResolver
	MatchmakingTicket() MatchmakingTicketResolver
	Mutation() MutationResolver
	Query() QueryResolver
	RemoveEventResultResponse() RemoveEventResultResponseResolver
	SearchTeamsResponse() SearchTeamsResponseResolver
	SetMatchPrivateServerResponse() SetMatchPrivateServerResponseResolver
	StartMatchResponse() StartMatchResponseResolver
	TaskResponse() TaskResponseResolver
	TeamResponse() TeamResponseResolver
	TournamentUser() TournamentUserResolver
	TournamentUserResponse() TournamentUserResponseResolver
	UpdateArenaResponse() UpdateArenaResponseResolver
	UpdateEventResponse() UpdateEventResponseResolver
	UpdateEventRoundResponse() UpdateEventRoundResponseResolver
	UpdateEventUserResponse() UpdateEventUserResponseResolver
	UpdateItemResponse() UpdateItemResponseResolver
	UpdateMatchResponse() UpdateMatchResponseResolver
	UpdateMatchmakingTicketResponse() UpdateMatchmakingTicketResponseResolver
	UpdateMatchmakingUserResponse() UpdateMatchmakingUserResponseResolver
	UpdateRecordResponse() UpdateRecordResponseResolver
	UpdateTaskResponse() UpdateTaskResponseResolver
	UpdateTeamMemberResponse() UpdateTeamMemberResponseResolver
	UpdateTeamResponse() UpdateTeamResponseResolver
	UpdateTournamentUserResponse() UpdateTournamentUserResponseResolver
	CreateTournamentUserRequest() CreateTournamentUserRequestResolver
	GetMatchesRequest() GetMatchesRequestResolver
	GetMatchmakingTicketsRequest() GetMatchmakingTicketsRequestResolver
	GetTournamentUsersRequest() GetTournamentUsersRequestResolver
	TournamentIntervalUserId() TournamentIntervalUserIdResolver
}

type DirectiveRoot struct {
	Doc     func(ctx context.Context, obj any, next graphql.Resolver, category *string) (res any, err error)
	Example func(ctx context.Context, obj any, next graphql.Resolver, value *string) (res any, err error)
}

type ComplexityRoot struct {
	AddEventResultResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	Arena struct {
		CreatedAt           func(childComplexity int) int
		Data                func(childComplexity int) int
		Id                  func(childComplexity int) int
		MaxPlayers          func(childComplexity int) int
		MaxPlayersPerTicket func(childComplexity int) int
		MinPlayers          func(childComplexity int) int
		Name                func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
	}

	CompleteTaskResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateArenaResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateEventResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateEventRoundResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateItemResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateMatchmakingTicketResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateMatchmakingUserResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateRecordResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateTaskResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateTeamResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateTournamentUserResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	DeleteMatchResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	DeleteMatchmakingTicketResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	DeleteMatchmakingUserResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	DeleteRecordResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	EndMatchResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	Event struct {
		CreatedAt        func(childComplexity int) int
		CurrentRoundId   func(childComplexity int) int
		CurrentRoundName func(childComplexity int) int
		Data             func(childComplexity int) int
		Id               func(childComplexity int) int
		Name             func(childComplexity int) int
		Rounds           func(childComplexity int) int
		StartedAt        func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	EventResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	EventRound struct {
		CreatedAt func(childComplexity int) int
		Data      func(childComplexity int) int
		EndedAt   func(childComplexity int) int
		EventId   func(childComplexity int) int
		Id        func(childComplexity int) int
		Name      func(childComplexity int) int
		Scoring   func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	EventRoundUser struct {
		ClientUserId func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Data         func(childComplexity int) int
		EventRoundId func(childComplexity int) int
		EventUserId  func(childComplexity int) int
		Id           func(childComplexity int) int
		Ranking      func(childComplexity int) int
		Result       func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	EventUser struct {
		ClientUserId func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Data         func(childComplexity int) int
		EventId      func(childComplexity int) int
		Id           func(childComplexity int) int
		Ranking      func(childComplexity int) int
		Score        func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	EventUserResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetArenaResponse struct {
		Arena   func(childComplexity int) int
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetArenasResponse struct {
		Arenas  func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetEventResponse struct {
		Error       func(childComplexity int) int
		Event       func(childComplexity int) int
		Leaderboard func(childComplexity int) int
		Success     func(childComplexity int) int
	}

	GetEventRoundResponse struct {
		Error   func(childComplexity int) int
		Results func(childComplexity int) int
		Round   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetEventUserResponse struct {
		Error   func(childComplexity int) int
		Results func(childComplexity int) int
		Success func(childComplexity int) int
		User    func(childComplexity int) int
	}

	GetItemResponse struct {
		Error   func(childComplexity int) int
		Item    func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetItemsResponse struct {
		Items   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetMatchResponse struct {
		Error   func(childComplexity int) int
		Match   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetMatchesResponse struct {
		Matches func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetMatchmakingTicketResponse struct {
		Error             func(childComplexity int) int
		MatchmakingTicket func(childComplexity int) int
		Success           func(childComplexity int) int
	}

	GetMatchmakingTicketsResponse struct {
		Error              func(childComplexity int) int
		MatchmakingTickets func(childComplexity int) int
		Success            func(childComplexity int) int
	}

	GetMatchmakingUserResponse struct {
		Error           func(childComplexity int) int
		MatchmakingUser func(childComplexity int) int
		Success         func(childComplexity int) int
	}

	GetMatchmakingUsersResponse struct {
		MatchmakingUsers func(childComplexity int) int
		Success          func(childComplexity int) int
	}

	GetRecordResponse struct {
		Error   func(childComplexity int) int
		Record  func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetRecordsResponse struct {
		Error   func(childComplexity int) int
		Records func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetTaskResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
		Task    func(childComplexity int) int
	}

	GetTasksResponse struct {
		Success func(childComplexity int) int
		Tasks   func(childComplexity int) int
	}

	GetTeamMemberResponse struct {
		Error   func(childComplexity int) int
		Member  func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetTeamResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
		Team    func(childComplexity int) int
	}

	GetTeamsResponse struct {
		Success func(childComplexity int) int
		Teams   func(childComplexity int) int
	}

	GetTournamentUserResponse struct {
		Error          func(childComplexity int) int
		Success        func(childComplexity int) int
		TournamentUser func(childComplexity int) int
	}

	GetTournamentUsersResponse struct {
		Error           func(childComplexity int) int
		Success         func(childComplexity int) int
		TournamentUsers func(childComplexity int) int
	}

	Item struct {
		CreatedAt func(childComplexity int) int
		Data      func(childComplexity int) int
		ExpiresAt func(childComplexity int) int
		Id        func(childComplexity int) int
		Type      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	ItemResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	JoinTeamResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	LeaveTeamResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	Match struct {
		Arena           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EndedAt         func(childComplexity int) int
		Id              func(childComplexity int) int
		LockedAt        func(childComplexity int) int
		PrivateServerId func(childComplexity int) int
		StartedAt       func(childComplexity int) int
		Status          func(childComplexity int) int
		Tickets         func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
	}

	MatchmakingTicket struct {
		Arenas           func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		Data             func(childComplexity int) int
		Id               func(childComplexity int) int
		MatchId          func(childComplexity int) int
		MatchmakingUsers func(childComplexity int) int
		Status           func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	MatchmakingUser struct {
		ClientUserId func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Data         func(childComplexity int) int
		Elo          func(childComplexity int) int
		Id           func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	Mutation struct {
		AddEventResult          func(childComplexity int, input *api.AddEventResultRequest) int
		CompleteTask            func(childComplexity int, input *api.TaskRequest) int
		CreateArena             func(childComplexity int, input *api.CreateArenaRequest) int
		CreateEvent             func(childComplexity int, input *api.CreateEventRequest) int
		CreateEventRound        func(childComplexity int, input *api.CreateEventRoundRequest) int
		CreateItem              func(childComplexity int, input *api.CreateItemRequest) int
		CreateMatchmakingTicket func(childComplexity int, input *api.CreateMatchmakingTicketRequest) int
		CreateMatchmakingUser   func(childComplexity int, input *api.CreateMatchmakingUserRequest) int
		CreateRecord            func(childComplexity int, input *api.CreateRecordRequest) int
		CreateTask              func(childComplexity int, input *api.CreateTaskRequest) int
		CreateTeam              func(childComplexity int, input *api.CreateTeamRequest) int
		CreateTournamentUser    func(childComplexity int, input *api.CreateTournamentUserRequest) int
		DeleteEvent             func(childComplexity int, input *api.EventRequest) int
		DeleteEventUser         func(childComplexity int, input *api.EventUserRequest) int
		DeleteItem              func(childComplexity int, input *api.ItemRequest) int
		DeleteMatch             func(childComplexity int, input *api.MatchRequest) int
		DeleteMatchmakingTicket func(childComplexity int, input *api.MatchmakingTicketRequest) int
		DeleteMatchmakingUser   func(childComplexity int, input *api.MatchmakingUserRequest) int
		DeleteRecord            func(childComplexity int, input *api.RecordRequest) int
		DeleteTask              func(childComplexity int, input *api.TaskRequest) int
		DeleteTeam              func(childComplexity int, input *api.TeamRequest) int
		DeleteTournamentUser    func(childComplexity int, input *api.TournamentUserRequest) int
		EndMatch                func(childComplexity int, input *api.EndMatchRequest) int
		JoinTeam                func(childComplexity int, input *api.JoinTeamRequest) int
		LeaveTeam               func(childComplexity int, input *api.TeamMemberRequest) int
		RemoveEventResult       func(childComplexity int, input *api.EventRoundUserRequest) int
		SetMatchPrivateServer   func(childComplexity int, input *api.SetMatchPrivateServerRequest) int
		StartMatch              func(childComplexity int, input *api.StartMatchRequest) int
		UpdateArena             func(childComplexity int, input *api.UpdateArenaRequest) int
		UpdateEvent             func(childComplexity int, input *api.UpdateEventRequest) int
		UpdateEventRound        func(childComplexity int, input *api.UpdateEventRoundRequest) int
		UpdateEventUser         func(childComplexity int, input *api.UpdateEventUserRequest) int
		UpdateItem              func(childComplexity int, input *api.UpdateItemRequest) int
		UpdateMatch             func(childComplexity int, input *api.UpdateMatchRequest) int
		UpdateMatchmakingTicket func(childComplexity int, input *api.UpdateMatchmakingTicketRequest) int
		UpdateMatchmakingUser   func(childComplexity int, input *api.UpdateMatchmakingUserRequest) int
		UpdateRecord            func(childComplexity int, input *api.UpdateRecordRequest) int
		UpdateTask              func(childComplexity int, input *api.UpdateTaskRequest) int
		UpdateTeam              func(childComplexity int, input *api.UpdateTeamRequest) int
		UpdateTeamMember        func(childComplexity int, input *api.UpdateTeamMemberRequest) int
		UpdateTournamentUser    func(childComplexity int, input *api.UpdateTournamentUserRequest) int
		Webhook                 func(childComplexity int, input *api.WebhookRequest) int
	}

	Query struct {
		GetArena              func(childComplexity int, input *api.ArenaRequest) int
		GetArenas             func(childComplexity int, input *api.Pagination) int
		GetEvent              func(childComplexity int, input *api.GetEventRequest) int
		GetEventRound         func(childComplexity int, input *api.GetEventRoundRequest) int
		GetEventUser          func(childComplexity int, input *api.GetEventUserRequest) int
		GetItem               func(childComplexity int, input *api.ItemRequest) int
		GetItems              func(childComplexity int, input *api.GetItemsRequest) int
		GetMatch              func(childComplexity int, input *api.GetMatchRequest) int
		GetMatches            func(childComplexity int, input *api.GetMatchesRequest) int
		GetMatchmakingTicket  func(childComplexity int, input *api.GetMatchmakingTicketRequest) int
		GetMatchmakingTickets func(childComplexity int, input *api.GetMatchmakingTicketsRequest) int
		GetMatchmakingUser    func(childComplexity int, input *api.MatchmakingUserRequest) int
		GetMatchmakingUsers   func(childComplexity int, input *api.Pagination) int
		GetRecord             func(childComplexity int, input *api.RecordRequest) int
		GetRecords            func(childComplexity int, input *api.GetRecordsRequest) int
		GetTask               func(childComplexity int, input *api.TaskRequest) int
		GetTasks              func(childComplexity int, input *api.GetTasksRequest) int
		GetTeam               func(childComplexity int, input *api.GetTeamRequest) int
		GetTeamMember         func(childComplexity int, input *api.TeamMemberRequest) int
		GetTeams              func(childComplexity int, input *api.GetTeamsRequest) int
		GetTournamentUser     func(childComplexity int, input *api.TournamentUserRequest) int
		GetTournamentUsers    func(childComplexity int, input *api.GetTournamentUsersRequest) int
		SearchTeams           func(childComplexity int, input *api.SearchTeamsRequest) int
	}

	Record struct {
		CreatedAt func(childComplexity int) int
		Data      func(childComplexity int) int
		Id        func(childComplexity int) int
		Name      func(childComplexity int) int
		Ranking   func(childComplexity int) int
		Record    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		UserId    func(childComplexity int) int
	}

	RemoveEventResultResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	SearchTeamsResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
		Teams   func(childComplexity int) int
	}

	SetMatchPrivateServerResponse struct {
		Error           func(childComplexity int) int
		PrivateServerId func(childComplexity int) int
		Success         func(childComplexity int) int
	}

	StartMatchResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	Task struct {
		CompletedAt func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Data        func(childComplexity int) int
		ExpiresAt   func(childComplexity int) int
		Id          func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	TaskResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	Team struct {
		CreatedAt func(childComplexity int) int
		Data      func(childComplexity int) int
		Id        func(childComplexity int) int
		Members   func(childComplexity int) int
		Name      func(childComplexity int) int
		Ranking   func(childComplexity int) int
		Score     func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	TeamMember struct {
		Data      func(childComplexity int) int
		Id        func(childComplexity int) int
		JoinedAt  func(childComplexity int) int
		TeamId    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		UserId    func(childComplexity int) int
	}

	TeamResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	TournamentUser struct {
		CreatedAt           func(childComplexity int) int
		Data                func(childComplexity int) int
		Id                  func(childComplexity int) int
		Interval            func(childComplexity int) int
		Ranking             func(childComplexity int) int
		Score               func(childComplexity int) int
		Tournament          func(childComplexity int) int
		TournamentStartedAt func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
		UserId              func(childComplexity int) int
	}

	TournamentUserResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateArenaResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateEventResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateEventRoundResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateEventUserResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateItemResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateMatchResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateMatchmakingTicketResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateMatchmakingUserResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateRecordResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateTaskResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateTeamMemberResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateTeamResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateTournamentUserResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	WebhookResponse struct {
		Body    func(childComplexity int) int
		Headers func(childComplexity int) int
		Status  func(childComplexity int) int
	}
}

type AddEventResultResponseResolver interface {
	Error(ctx context.Context, obj *api.AddEventResultResponse) (model.AddEventResultError, error)
}
type CompleteTaskResponseResolver interface {
	Error(ctx context.Context, obj *api.CompleteTaskResponse) (model.CompleteTaskError, error)
}
type CreateArenaResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateArenaResponse) (model.CreateArenaError, error)
}
type CreateEventResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateEventResponse) (model.CreateEventError, error)
}
type CreateEventRoundResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateEventRoundResponse) (model.CreateEventRoundError, error)
}
type CreateItemResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateItemResponse) (model.CreateItemError, error)
}
type CreateMatchmakingTicketResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateMatchmakingTicketResponse) (model.CreateMatchmakingTicketError, error)
}
type CreateMatchmakingUserResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateMatchmakingUserResponse) (model.CreateMatchmakingUserError, error)
}
type CreateRecordResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateRecordResponse) (model.CreateRecordError, error)
}
type CreateTaskResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateTaskResponse) (model.CreateTaskError, error)
}
type CreateTeamResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateTeamResponse) (model.CreateTeamError, error)
}
type CreateTournamentUserResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateTournamentUserResponse) (model.CreateTournamentUserError, error)
}
type DeleteMatchResponseResolver interface {
	Error(ctx context.Context, obj *api.DeleteMatchResponse) (model.DeleteMatchError, error)
}
type DeleteMatchmakingTicketResponseResolver interface {
	Error(ctx context.Context, obj *api.DeleteMatchmakingTicketResponse) (model.DeleteMatchmakingTicketError, error)
}
type DeleteMatchmakingUserResponseResolver interface {
	Error(ctx context.Context, obj *api.DeleteMatchmakingUserResponse) (model.DeleteMatchmakingUserError, error)
}
type DeleteRecordResponseResolver interface {
	Error(ctx context.Context, obj *api.DeleteRecordResponse) (model.DeleteRecordError, error)
}
type EndMatchResponseResolver interface {
	Error(ctx context.Context, obj *api.EndMatchResponse) (model.EndMatchError, error)
}
type EventResponseResolver interface {
	Error(ctx context.Context, obj *api.EventResponse) (model.EventError, error)
}
type EventUserResponseResolver interface {
	Error(ctx context.Context, obj *api.EventUserResponse) (model.EventUserError, error)
}
type GetArenaResponseResolver interface {
	Error(ctx context.Context, obj *api.GetArenaResponse) (model.GetArenaError, error)
}
type GetEventResponseResolver interface {
	Error(ctx context.Context, obj *api.GetEventResponse) (model.GetEventError, error)
}
type GetEventRoundResponseResolver interface {
	Error(ctx context.Context, obj *api.GetEventRoundResponse) (model.GetEventRoundError, error)
}
type GetEventUserResponseResolver interface {
	Error(ctx context.Context, obj *api.GetEventUserResponse) (model.GetEventUserError, error)
}
type GetItemResponseResolver interface {
	Error(ctx context.Context, obj *api.GetItemResponse) (model.GetItemError, error)
}
type GetMatchResponseResolver interface {
	Error(ctx context.Context, obj *api.GetMatchResponse) (model.GetMatchError, error)
}
type GetMatchmakingTicketResponseResolver interface {
	Error(ctx context.Context, obj *api.GetMatchmakingTicketResponse) (model.GetMatchmakingTicketError, error)
}
type GetMatchmakingTicketsResponseResolver interface {
	Error(ctx context.Context, obj *api.GetMatchmakingTicketsResponse) (model.GetMatchmakingTicketsError, error)
}
type GetMatchmakingUserResponseResolver interface {
	Error(ctx context.Context, obj *api.GetMatchmakingUserResponse) (model.GetMatchmakingUserError, error)
}
type GetRecordResponseResolver interface {
	Error(ctx context.Context, obj *api.GetRecordResponse) (model.GetRecordError, error)
}
type GetRecordsResponseResolver interface {
	Error(ctx context.Context, obj *api.GetRecordsResponse) (model.GetRecordsError, error)
}
type GetTaskResponseResolver interface {
	Error(ctx context.Context, obj *api.GetTaskResponse) (model.GetTaskError, error)
}
type GetTeamMemberResponseResolver interface {
	Error(ctx context.Context, obj *api.GetTeamMemberResponse) (model.GetTeamMemberError, error)
}
type GetTeamResponseResolver interface {
	Error(ctx context.Context, obj *api.GetTeamResponse) (model.GetTeamError, error)
}
type GetTournamentUserResponseResolver interface {
	Error(ctx context.Context, obj *api.GetTournamentUserResponse) (model.GetTournamentUserError, error)
}
type GetTournamentUsersResponseResolver interface {
	Error(ctx context.Context, obj *api.GetTournamentUsersResponse) (model.GetTournamentUsersError, error)
}
type ItemResponseResolver interface {
	Error(ctx context.Context, obj *api.ItemResponse) (model.ItemError, error)
}
type JoinTeamResponseResolver interface {
	Error(ctx context.Context, obj *api.JoinTeamResponse) (model.JoinTeamError, error)
}
type LeaveTeamResponseResolver interface {
	Error(ctx context.Context, obj *api.LeaveTeamResponse) (model.LeaveTeamError, error)
}
type MatchResolver interface {
	Status(ctx context.Context, obj *api.Match) (model.MatchStatus, error)
}
type MatchmakingTicketResolver interface {
	Status(ctx context.Context, obj *api.MatchmakingTicket) (model.MatchmakingTicketStatus, error)
}
type MutationResolver interface {
	CreateEvent(ctx context.Context, input *api.CreateEventRequest) (*api.CreateEventResponse, error)
	UpdateEvent(ctx context.Context, input *api.UpdateEventRequest) (*api.UpdateEventResponse, error)
	DeleteEvent(ctx context.Context, input *api.EventRequest) (*api.EventResponse, error)
	CreateEventRound(ctx context.Context, input *api.CreateEventRoundRequest) (*api.CreateEventRoundResponse, error)
	UpdateEventRound(ctx context.Context, input *api.UpdateEventRoundRequest) (*api.UpdateEventRoundResponse, error)
	UpdateEventUser(ctx context.Context, input *api.UpdateEventUserRequest) (*api.UpdateEventUserResponse, error)
	DeleteEventUser(ctx context.Context, input *api.EventUserRequest) (*api.EventUserResponse, error)
	AddEventResult(ctx context.Context, input *api.AddEventResultRequest) (*api.AddEventResultResponse, error)
	RemoveEventResult(ctx context.Context, input *api.EventRoundUserRequest) (*api.RemoveEventResultResponse, error)
	CreateItem(ctx context.Context, input *api.CreateItemRequest) (*api.CreateItemResponse, error)
	UpdateItem(ctx context.Context, input *api.UpdateItemRequest) (*api.UpdateItemResponse, error)
	DeleteItem(ctx context.Context, input *api.ItemRequest) (*api.ItemResponse, error)
	CreateArena(ctx context.Context, input *api.CreateArenaRequest) (*api.CreateArenaResponse, error)
	UpdateArena(ctx context.Context, input *api.UpdateArenaRequest) (*api.UpdateArenaResponse, error)
	CreateMatchmakingUser(ctx context.Context, input *api.CreateMatchmakingUserRequest) (*api.CreateMatchmakingUserResponse, error)
	UpdateMatchmakingUser(ctx context.Context, input *api.UpdateMatchmakingUserRequest) (*api.UpdateMatchmakingUserResponse, error)
	DeleteMatchmakingUser(ctx context.Context, input *api.MatchmakingUserRequest) (*api.DeleteMatchmakingUserResponse, error)
	CreateMatchmakingTicket(ctx context.Context, input *api.CreateMatchmakingTicketRequest) (*api.CreateMatchmakingTicketResponse, error)
	UpdateMatchmakingTicket(ctx context.Context, input *api.UpdateMatchmakingTicketRequest) (*api.UpdateMatchmakingTicketResponse, error)
	DeleteMatchmakingTicket(ctx context.Context, input *api.MatchmakingTicketRequest) (*api.DeleteMatchmakingTicketResponse, error)
	StartMatch(ctx context.Context, input *api.StartMatchRequest) (*api.StartMatchResponse, error)
	EndMatch(ctx context.Context, input *api.EndMatchRequest) (*api.EndMatchResponse, error)
	UpdateMatch(ctx context.Context, input *api.UpdateMatchRequest) (*api.UpdateMatchResponse, error)
	SetMatchPrivateServer(ctx context.Context, input *api.SetMatchPrivateServerRequest) (*api.SetMatchPrivateServerResponse, error)
	DeleteMatch(ctx context.Context, input *api.MatchRequest) (*api.DeleteMatchResponse, error)
	CreateRecord(ctx context.Context, input *api.CreateRecordRequest) (*api.CreateRecordResponse, error)
	UpdateRecord(ctx context.Context, input *api.UpdateRecordRequest) (*api.UpdateRecordResponse, error)
	DeleteRecord(ctx context.Context, input *api.RecordRequest) (*api.DeleteRecordResponse, error)
	CreateTask(ctx context.Context, input *api.CreateTaskRequest) (*api.CreateTaskResponse, error)
	UpdateTask(ctx context.Context, input *api.UpdateTaskRequest) (*api.UpdateTaskResponse, error)
	CompleteTask(ctx context.Context, input *api.TaskRequest) (*api.CompleteTaskResponse, error)
	DeleteTask(ctx context.Context, input *api.TaskRequest) (*api.TaskResponse, error)
	CreateTeam(ctx context.Context, input *api.CreateTeamRequest) (*api.CreateTeamResponse, error)
	UpdateTeam(ctx context.Context, input *api.UpdateTeamRequest) (*api.UpdateTeamResponse, error)
	DeleteTeam(ctx context.Context, input *api.TeamRequest) (*api.TeamResponse, error)
	JoinTeam(ctx context.Context, input *api.JoinTeamRequest) (*api.JoinTeamResponse, error)
	LeaveTeam(ctx context.Context, input *api.TeamMemberRequest) (*api.LeaveTeamResponse, error)
	UpdateTeamMember(ctx context.Context, input *api.UpdateTeamMemberRequest) (*api.UpdateTeamMemberResponse, error)
	CreateTournamentUser(ctx context.Context, input *api.CreateTournamentUserRequest) (*api.CreateTournamentUserResponse, error)
	UpdateTournamentUser(ctx context.Context, input *api.UpdateTournamentUserRequest) (*api.UpdateTournamentUserResponse, error)
	DeleteTournamentUser(ctx context.Context, input *api.TournamentUserRequest) (*api.TournamentUserResponse, error)
	Webhook(ctx context.Context, input *api.WebhookRequest) (*api.WebhookResponse, error)
}
type QueryResolver interface {
	GetEvent(ctx context.Context, input *api.GetEventRequest) (*api.GetEventResponse, error)
	GetEventRound(ctx context.Context, input *api.GetEventRoundRequest) (*api.GetEventRoundResponse, error)
	GetEventUser(ctx context.Context, input *api.GetEventUserRequest) (*api.GetEventUserResponse, error)
	GetItem(ctx context.Context, input *api.ItemRequest) (*api.GetItemResponse, error)
	GetItems(ctx context.Context, input *api.GetItemsRequest) (*api.GetItemsResponse, error)
	GetArena(ctx context.Context, input *api.ArenaRequest) (*api.GetArenaResponse, error)
	GetArenas(ctx context.Context, input *api.Pagination) (*api.GetArenasResponse, error)
	GetMatchmakingUser(ctx context.Context, input *api.MatchmakingUserRequest) (*api.GetMatchmakingUserResponse, error)
	GetMatchmakingUsers(ctx context.Context, input *api.Pagination) (*api.GetMatchmakingUsersResponse, error)
	GetMatchmakingTicket(ctx context.Context, input *api.GetMatchmakingTicketRequest) (*api.GetMatchmakingTicketResponse, error)
	GetMatchmakingTickets(ctx context.Context, input *api.GetMatchmakingTicketsRequest) (*api.GetMatchmakingTicketsResponse, error)
	GetMatch(ctx context.Context, input *api.GetMatchRequest) (*api.GetMatchResponse, error)
	GetMatches(ctx context.Context, input *api.GetMatchesRequest) (*api.GetMatchesResponse, error)
	GetRecord(ctx context.Context, input *api.RecordRequest) (*api.GetRecordResponse, error)
	GetRecords(ctx context.Context, input *api.GetRecordsRequest) (*api.GetRecordsResponse, error)
	GetTask(ctx context.Context, input *api.TaskRequest) (*api.GetTaskResponse, error)
	GetTasks(ctx context.Context, input *api.GetTasksRequest) (*api.GetTasksResponse, error)
	GetTeam(ctx context.Context, input *api.GetTeamRequest) (*api.GetTeamResponse, error)
	GetTeams(ctx context.Context, input *api.GetTeamsRequest) (*api.GetTeamsResponse, error)
	GetTeamMember(ctx context.Context, input *api.TeamMemberRequest) (*api.GetTeamMemberResponse, error)
	SearchTeams(ctx context.Context, input *api.SearchTeamsRequest) (*api.SearchTeamsResponse, error)
	GetTournamentUser(ctx context.Context, input *api.TournamentUserRequest) (*api.GetTournamentUserResponse, error)
	GetTournamentUsers(ctx context.Context, input *api.GetTournamentUsersRequest) (*api.GetTournamentUsersResponse, error)
}
type RemoveEventResultResponseResolver interface {
	Error(ctx context.Context, obj *api.RemoveEventResultResponse) (model.RemoveEventResultError, error)
}
type SearchTeamsResponseResolver interface {
	Error(ctx context.Context, obj *api.SearchTeamsResponse) (model.SearchTeamsError, error)
}
type SetMatchPrivateServerResponseResolver interface {
	Error(ctx context.Context, obj *api.SetMatchPrivateServerResponse) (model.SetMatchPrivateServerError, error)
}
type StartMatchResponseResolver interface {
	Error(ctx context.Context, obj *api.StartMatchResponse) (model.StartMatchError, error)
}
type TaskResponseResolver interface {
	Error(ctx context.Context, obj *api.TaskResponse) (model.TaskError, error)
}
type TeamResponseResolver interface {
	Error(ctx context.Context, obj *api.TeamResponse) (model.TeamError, error)
}
type TournamentUserResolver interface {
	Interval(ctx context.Context, obj *api.TournamentUser) (graphqlEnums.TournamentInterval, error)
}
type TournamentUserResponseResolver interface {
	Error(ctx context.Context, obj *api.TournamentUserResponse) (model.TournamentUserError, error)
}
type UpdateArenaResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateArenaResponse) (model.UpdateArenaError, error)
}
type UpdateEventResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateEventResponse) (model.UpdateEventError, error)
}
type UpdateEventRoundResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateEventRoundResponse) (model.UpdateEventRoundError, error)
}
type UpdateEventUserResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateEventUserResponse) (model.UpdateEventUserError, error)
}
type UpdateItemResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateItemResponse) (model.UpdateItemError, error)
}
type UpdateMatchResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateMatchResponse) (model.UpdateMatchError, error)
}
type UpdateMatchmakingTicketResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateMatchmakingTicketResponse) (model.UpdateMatchmakingTicketError, error)
}
type UpdateMatchmakingUserResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateMatchmakingUserResponse) (model.UpdateMatchmakingUserError, error)
}
type UpdateRecordResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateRecordResponse) (model.UpdateRecordError, error)
}
type UpdateTaskResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateTaskResponse) (model.UpdateTaskError, error)
}
type UpdateTeamMemberResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateTeamMemberResponse) (model.UpdateTeamMemberError, error)
}
type UpdateTeamResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateTeamResponse) (model.UpdateTeamError, error)
}
type UpdateTournamentUserResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateTournamentUserResponse) (model.UpdateTournamentUserError, error)
}

type CreateTournamentUserRequestResolver interface {
	Interval(ctx context.Context, obj *api.CreateTournamentUserRequest, data graphqlEnums.TournamentInterval) error
}
type GetMatchesRequestResolver interface {
	Statuses(ctx context.Context, obj *api.GetMatchesRequest, data []*model.MatchStatus) error
}
type GetMatchmakingTicketsRequestResolver interface {
	Statuses(ctx context.Context, obj *api.GetMatchmakingTicketsRequest, data []*model.MatchmakingTicketStatus) error
}
type GetTournamentUsersRequestResolver interface {
	Interval(ctx context.Context, obj *api.GetTournamentUsersRequest, data graphqlEnums.TournamentInterval) error
}
type TournamentIntervalUserIdResolver interface {
	Interval(ctx context.Context, obj *api.TournamentIntervalUserId, data graphqlEnums.TournamentInterval) error
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AddEventResultResponse.error":
		if e.complexity.AddEventResultResponse.Error == nil {
			break
		}

		return e.complexity.AddEventResultResponse.Error(childComplexity), true

	case "AddEventResultResponse.success":
		if e.complexity.AddEventResultResponse.Success == nil {
			break
		}

		return e.complexity.AddEventResultResponse.Success(childComplexity), true

	case "Arena.createdAt":
		if e.complexity.Arena.CreatedAt == nil {
			break
		}

		return e.complexity.Arena.CreatedAt(childComplexity), true

	case "Arena.data":
		if e.complexity.Arena.Data == nil {
			break
		}

		return e.complexity.Arena.Data(childComplexity), true

	case "Arena.id":
		if e.complexity.Arena.Id == nil {
			break
		}

		return e.complexity.Arena.Id(childComplexity), true

	case "Arena.maxPlayers":
		if e.complexity.Arena.MaxPlayers == nil {
			break
		}

		return e.complexity.Arena.MaxPlayers(childComplexity), true

	case "Arena.maxPlayersPerTicket":
		if e.complexity.Arena.MaxPlayersPerTicket == nil {
			break
		}

		return e.complexity.Arena.MaxPlayersPerTicket(childComplexity), true

	case "Arena.minPlayers":
		if e.complexity.Arena.MinPlayers == nil {
			break
		}

		return e.complexity.Arena.MinPlayers(childComplexity), true

	case "Arena.name":
		if e.complexity.Arena.Name == nil {
			break
		}

		return e.complexity.Arena.Name(childComplexity), true

	case "Arena.updatedAt":
		if e.complexity.Arena.UpdatedAt == nil {
			break
		}

		return e.complexity.Arena.UpdatedAt(childComplexity), true

	case "CompleteTaskResponse.error":
		if e.complexity.CompleteTaskResponse.Error == nil {
			break
		}

		return e.complexity.CompleteTaskResponse.Error(childComplexity), true

	case "CompleteTaskResponse.success":
		if e.complexity.CompleteTaskResponse.Success == nil {
			break
		}

		return e.complexity.CompleteTaskResponse.Success(childComplexity), true

	case "CreateArenaResponse.error":
		if e.complexity.CreateArenaResponse.Error == nil {
			break
		}

		return e.complexity.CreateArenaResponse.Error(childComplexity), true

	case "CreateArenaResponse.id":
		if e.complexity.CreateArenaResponse.Id == nil {
			break
		}

		return e.complexity.CreateArenaResponse.Id(childComplexity), true

	case "CreateArenaResponse.success":
		if e.complexity.CreateArenaResponse.Success == nil {
			break
		}

		return e.complexity.CreateArenaResponse.Success(childComplexity), true

	case "CreateEventResponse.error":
		if e.complexity.CreateEventResponse.Error == nil {
			break
		}

		return e.complexity.CreateEventResponse.Error(childComplexity), true

	case "CreateEventResponse.id":
		if e.complexity.CreateEventResponse.Id == nil {
			break
		}

		return e.complexity.CreateEventResponse.Id(childComplexity), true

	case "CreateEventResponse.success":
		if e.complexity.CreateEventResponse.Success == nil {
			break
		}

		return e.complexity.CreateEventResponse.Success(childComplexity), true

	case "CreateEventRoundResponse.error":
		if e.complexity.CreateEventRoundResponse.Error == nil {
			break
		}

		return e.complexity.CreateEventRoundResponse.Error(childComplexity), true

	case "CreateEventRoundResponse.id":
		if e.complexity.CreateEventRoundResponse.Id == nil {
			break
		}

		return e.complexity.CreateEventRoundResponse.Id(childComplexity), true

	case "CreateEventRoundResponse.success":
		if e.complexity.CreateEventRoundResponse.Success == nil {
			break
		}

		return e.complexity.CreateEventRoundResponse.Success(childComplexity), true

	case "CreateItemResponse.error":
		if e.complexity.CreateItemResponse.Error == nil {
			break
		}

		return e.complexity.CreateItemResponse.Error(childComplexity), true

	case "CreateItemResponse.success":
		if e.complexity.CreateItemResponse.Success == nil {
			break
		}

		return e.complexity.CreateItemResponse.Success(childComplexity), true

	case "CreateMatchmakingTicketResponse.error":
		if e.complexity.CreateMatchmakingTicketResponse.Error == nil {
			break
		}

		return e.complexity.CreateMatchmakingTicketResponse.Error(childComplexity), true

	case "CreateMatchmakingTicketResponse.id":
		if e.complexity.CreateMatchmakingTicketResponse.Id == nil {
			break
		}

		return e.complexity.CreateMatchmakingTicketResponse.Id(childComplexity), true

	case "CreateMatchmakingTicketResponse.success":
		if e.complexity.CreateMatchmakingTicketResponse.Success == nil {
			break
		}

		return e.complexity.CreateMatchmakingTicketResponse.Success(childComplexity), true

	case "CreateMatchmakingUserResponse.error":
		if e.complexity.CreateMatchmakingUserResponse.Error == nil {
			break
		}

		return e.complexity.CreateMatchmakingUserResponse.Error(childComplexity), true

	case "CreateMatchmakingUserResponse.id":
		if e.complexity.CreateMatchmakingUserResponse.Id == nil {
			break
		}

		return e.complexity.CreateMatchmakingUserResponse.Id(childComplexity), true

	case "CreateMatchmakingUserResponse.success":
		if e.complexity.CreateMatchmakingUserResponse.Success == nil {
			break
		}

		return e.complexity.CreateMatchmakingUserResponse.Success(childComplexity), true

	case "CreateRecordResponse.error":
		if e.complexity.CreateRecordResponse.Error == nil {
			break
		}

		return e.complexity.CreateRecordResponse.Error(childComplexity), true

	case "CreateRecordResponse.id":
		if e.complexity.CreateRecordResponse.Id == nil {
			break
		}

		return e.complexity.CreateRecordResponse.Id(childComplexity), true

	case "CreateRecordResponse.success":
		if e.complexity.CreateRecordResponse.Success == nil {
			break
		}

		return e.complexity.CreateRecordResponse.Success(childComplexity), true

	case "CreateTaskResponse.error":
		if e.complexity.CreateTaskResponse.Error == nil {
			break
		}

		return e.complexity.CreateTaskResponse.Error(childComplexity), true

	case "CreateTaskResponse.success":
		if e.complexity.CreateTaskResponse.Success == nil {
			break
		}

		return e.complexity.CreateTaskResponse.Success(childComplexity), true

	case "CreateTeamResponse.error":
		if e.complexity.CreateTeamResponse.Error == nil {
			break
		}

		return e.complexity.CreateTeamResponse.Error(childComplexity), true

	case "CreateTeamResponse.id":
		if e.complexity.CreateTeamResponse.Id == nil {
			break
		}

		return e.complexity.CreateTeamResponse.Id(childComplexity), true

	case "CreateTeamResponse.success":
		if e.complexity.CreateTeamResponse.Success == nil {
			break
		}

		return e.complexity.CreateTeamResponse.Success(childComplexity), true

	case "CreateTournamentUserResponse.error":
		if e.complexity.CreateTournamentUserResponse.Error == nil {
			break
		}

		return e.complexity.CreateTournamentUserResponse.Error(childComplexity), true

	case "CreateTournamentUserResponse.id":
		if e.complexity.CreateTournamentUserResponse.Id == nil {
			break
		}

		return e.complexity.CreateTournamentUserResponse.Id(childComplexity), true

	case "CreateTournamentUserResponse.success":
		if e.complexity.CreateTournamentUserResponse.Success == nil {
			break
		}

		return e.complexity.CreateTournamentUserResponse.Success(childComplexity), true

	case "DeleteMatchResponse.error":
		if e.complexity.DeleteMatchResponse.Error == nil {
			break
		}

		return e.complexity.DeleteMatchResponse.Error(childComplexity), true

	case "DeleteMatchResponse.success":
		if e.complexity.DeleteMatchResponse.Success == nil {
			break
		}

		return e.complexity.DeleteMatchResponse.Success(childComplexity), true

	case "DeleteMatchmakingTicketResponse.error":
		if e.complexity.DeleteMatchmakingTicketResponse.Error == nil {
			break
		}

		return e.complexity.DeleteMatchmakingTicketResponse.Error(childComplexity), true

	case "DeleteMatchmakingTicketResponse.success":
		if e.complexity.DeleteMatchmakingTicketResponse.Success == nil {
			break
		}

		return e.complexity.DeleteMatchmakingTicketResponse.Success(childComplexity), true

	case "DeleteMatchmakingUserResponse.error":
		if e.complexity.DeleteMatchmakingUserResponse.Error == nil {
			break
		}

		return e.complexity.DeleteMatchmakingUserResponse.Error(childComplexity), true

	case "DeleteMatchmakingUserResponse.success":
		if e.complexity.DeleteMatchmakingUserResponse.Success == nil {
			break
		}

		return e.complexity.DeleteMatchmakingUserResponse.Success(childComplexity), true

	case "DeleteRecordResponse.error":
		if e.complexity.DeleteRecordResponse.Error == nil {
			break
		}

		return e.complexity.DeleteRecordResponse.Error(childComplexity), true

	case "DeleteRecordResponse.success":
		if e.complexity.DeleteRecordResponse.Success == nil {
			break
		}

		return e.complexity.DeleteRecordResponse.Success(childComplexity), true

	case "EndMatchResponse.error":
		if e.complexity.EndMatchResponse.Error == nil {
			break
		}

		return e.complexity.EndMatchResponse.Error(childComplexity), true

	case "EndMatchResponse.success":
		if e.complexity.EndMatchResponse.Success == nil {
			break
		}

		return e.complexity.EndMatchResponse.Success(childComplexity), true

	case "Event.createdAt":
		if e.complexity.Event.CreatedAt == nil {
			break
		}

		return e.complexity.Event.CreatedAt(childComplexity), true

	case "Event.currentRoundId":
		if e.complexity.Event.CurrentRoundId == nil {
			break
		}

		return e.complexity.Event.CurrentRoundId(childComplexity), true

	case "Event.currentRoundName":
		if e.complexity.Event.CurrentRoundName == nil {
			break
		}

		return e.complexity.Event.CurrentRoundName(childComplexity), true

	case "Event.data":
		if e.complexity.Event.Data == nil {
			break
		}

		return e.complexity.Event.Data(childComplexity), true

	case "Event.id":
		if e.complexity.Event.Id == nil {
			break
		}

		return e.complexity.Event.Id(childComplexity), true

	case "Event.name":
		if e.complexity.Event.Name == nil {
			break
		}

		return e.complexity.Event.Name(childComplexity), true

	case "Event.rounds":
		if e.complexity.Event.Rounds == nil {
			break
		}

		return e.complexity.Event.Rounds(childComplexity), true

	case "Event.startedAt":
		if e.complexity.Event.StartedAt == nil {
			break
		}

		return e.complexity.Event.StartedAt(childComplexity), true

	case "Event.updatedAt":
		if e.complexity.Event.UpdatedAt == nil {
			break
		}

		return e.complexity.Event.UpdatedAt(childComplexity), true

	case "EventResponse.error":
		if e.complexity.EventResponse.Error == nil {
			break
		}

		return e.complexity.EventResponse.Error(childComplexity), true

	case "EventResponse.success":
		if e.complexity.EventResponse.Success == nil {
			break
		}

		return e.complexity.EventResponse.Success(childComplexity), true

	case "EventRound.createdAt":
		if e.complexity.EventRound.CreatedAt == nil {
			break
		}

		return e.complexity.EventRound.CreatedAt(childComplexity), true

	case "EventRound.data":
		if e.complexity.EventRound.Data == nil {
			break
		}

		return e.complexity.EventRound.Data(childComplexity), true

	case "EventRound.endedAt":
		if e.complexity.EventRound.EndedAt == nil {
			break
		}

		return e.complexity.EventRound.EndedAt(childComplexity), true

	case "EventRound.eventId":
		if e.complexity.EventRound.EventId == nil {
			break
		}

		return e.complexity.EventRound.EventId(childComplexity), true

	case "EventRound.id":
		if e.complexity.EventRound.Id == nil {
			break
		}

		return e.complexity.EventRound.Id(childComplexity), true

	case "EventRound.name":
		if e.complexity.EventRound.Name == nil {
			break
		}

		return e.complexity.EventRound.Name(childComplexity), true

	case "EventRound.scoring":
		if e.complexity.EventRound.Scoring == nil {
			break
		}

		return e.complexity.EventRound.Scoring(childComplexity), true

	case "EventRound.updatedAt":
		if e.complexity.EventRound.UpdatedAt == nil {
			break
		}

		return e.complexity.EventRound.UpdatedAt(childComplexity), true

	case "EventRoundUser.clientUserId":
		if e.complexity.EventRoundUser.ClientUserId == nil {
			break
		}

		return e.complexity.EventRoundUser.ClientUserId(childComplexity), true

	case "EventRoundUser.createdAt":
		if e.complexity.EventRoundUser.CreatedAt == nil {
			break
		}

		return e.complexity.EventRoundUser.CreatedAt(childComplexity), true

	case "EventRoundUser.data":
		if e.complexity.EventRoundUser.Data == nil {
			break
		}

		return e.complexity.EventRoundUser.Data(childComplexity), true

	case "EventRoundUser.eventRoundId":
		if e.complexity.EventRoundUser.EventRoundId == nil {
			break
		}

		return e.complexity.EventRoundUser.EventRoundId(childComplexity), true

	case "EventRoundUser.eventUserId":
		if e.complexity.EventRoundUser.EventUserId == nil {
			break
		}

		return e.complexity.EventRoundUser.EventUserId(childComplexity), true

	case "EventRoundUser.id":
		if e.complexity.EventRoundUser.Id == nil {
			break
		}

		return e.complexity.EventRoundUser.Id(childComplexity), true

	case "EventRoundUser.ranking":
		if e.complexity.EventRoundUser.Ranking == nil {
			break
		}

		return e.complexity.EventRoundUser.Ranking(childComplexity), true

	case "EventRoundUser.result":
		if e.complexity.EventRoundUser.Result == nil {
			break
		}

		return e.complexity.EventRoundUser.Result(childComplexity), true

	case "EventRoundUser.updatedAt":
		if e.complexity.EventRoundUser.UpdatedAt == nil {
			break
		}

		return e.complexity.EventRoundUser.UpdatedAt(childComplexity), true

	case "EventUser.clientUserId":
		if e.complexity.EventUser.ClientUserId == nil {
			break
		}

		return e.complexity.EventUser.ClientUserId(childComplexity), true

	case "EventUser.createdAt":
		if e.complexity.EventUser.CreatedAt == nil {
			break
		}

		return e.complexity.EventUser.CreatedAt(childComplexity), true

	case "EventUser.data":
		if e.complexity.EventUser.Data == nil {
			break
		}

		return e.complexity.EventUser.Data(childComplexity), true

	case "EventUser.eventId":
		if e.complexity.EventUser.EventId == nil {
			break
		}

		return e.complexity.EventUser.EventId(childComplexity), true

	case "EventUser.id":
		if e.complexity.EventUser.Id == nil {
			break
		}

		return e.complexity.EventUser.Id(childComplexity), true

	case "EventUser.ranking":
		if e.complexity.EventUser.Ranking == nil {
			break
		}

		return e.complexity.EventUser.Ranking(childComplexity), true

	case "EventUser.score":
		if e.complexity.EventUser.Score == nil {
			break
		}

		return e.complexity.EventUser.Score(childComplexity), true

	case "EventUser.updatedAt":
		if e.complexity.EventUser.UpdatedAt == nil {
			break
		}

		return e.complexity.EventUser.UpdatedAt(childComplexity), true

	case "EventUserResponse.error":
		if e.complexity.EventUserResponse.Error == nil {
			break
		}

		return e.complexity.EventUserResponse.Error(childComplexity), true

	case "EventUserResponse.success":
		if e.complexity.EventUserResponse.Success == nil {
			break
		}

		return e.complexity.EventUserResponse.Success(childComplexity), true

	case "GetArenaResponse.arena":
		if e.complexity.GetArenaResponse.Arena == nil {
			break
		}

		return e.complexity.GetArenaResponse.Arena(childComplexity), true

	case "GetArenaResponse.error":
		if e.complexity.GetArenaResponse.Error == nil {
			break
		}

		return e.complexity.GetArenaResponse.Error(childComplexity), true

	case "GetArenaResponse.success":
		if e.complexity.GetArenaResponse.Success == nil {
			break
		}

		return e.complexity.GetArenaResponse.Success(childComplexity), true

	case "GetArenasResponse.arenas":
		if e.complexity.GetArenasResponse.Arenas == nil {
			break
		}

		return e.complexity.GetArenasResponse.Arenas(childComplexity), true

	case "GetArenasResponse.success":
		if e.complexity.GetArenasResponse.Success == nil {
			break
		}

		return e.complexity.GetArenasResponse.Success(childComplexity), true

	case "GetEventResponse.error":
		if e.complexity.GetEventResponse.Error == nil {
			break
		}

		return e.complexity.GetEventResponse.Error(childComplexity), true

	case "GetEventResponse.event":
		if e.complexity.GetEventResponse.Event == nil {
			break
		}

		return e.complexity.GetEventResponse.Event(childComplexity), true

	case "GetEventResponse.leaderboard":
		if e.complexity.GetEventResponse.Leaderboard == nil {
			break
		}

		return e.complexity.GetEventResponse.Leaderboard(childComplexity), true

	case "GetEventResponse.success":
		if e.complexity.GetEventResponse.Success == nil {
			break
		}

		return e.complexity.GetEventResponse.Success(childComplexity), true

	case "GetEventRoundResponse.error":
		if e.complexity.GetEventRoundResponse.Error == nil {
			break
		}

		return e.complexity.GetEventRoundResponse.Error(childComplexity), true

	case "GetEventRoundResponse.results":
		if e.complexity.GetEventRoundResponse.Results == nil {
			break
		}

		return e.complexity.GetEventRoundResponse.Results(childComplexity), true

	case "GetEventRoundResponse.round":
		if e.complexity.GetEventRoundResponse.Round == nil {
			break
		}

		return e.complexity.GetEventRoundResponse.Round(childComplexity), true

	case "GetEventRoundResponse.success":
		if e.complexity.GetEventRoundResponse.Success == nil {
			break
		}

		return e.complexity.GetEventRoundResponse.Success(childComplexity), true

	case "GetEventUserResponse.error":
		if e.complexity.GetEventUserResponse.Error == nil {
			break
		}

		return e.complexity.GetEventUserResponse.Error(childComplexity), true

	case "GetEventUserResponse.results":
		if e.complexity.GetEventUserResponse.Results == nil {
			break
		}

		return e.complexity.GetEventUserResponse.Results(childComplexity), true

	case "GetEventUserResponse.success":
		if e.complexity.GetEventUserResponse.Success == nil {
			break
		}

		return e.complexity.GetEventUserResponse.Success(childComplexity), true

	case "GetEventUserResponse.user":
		if e.complexity.GetEventUserResponse.User == nil {
			break
		}

		return e.complexity.GetEventUserResponse.User(childComplexity), true

	case "GetItemResponse.error":
		if e.complexity.GetItemResponse.Error == nil {
			break
		}

		return e.complexity.GetItemResponse.Error(childComplexity), true

	case "GetItemResponse.item":
		if e.complexity.GetItemResponse.Item == nil {
			break
		}

		return e.complexity.GetItemResponse.Item(childComplexity), true

	case "GetItemResponse.success":
		if e.complexity.GetItemResponse.Success == nil {
			break
		}

		return e.complexity.GetItemResponse.Success(childComplexity), true

	case "GetItemsResponse.items":
		if e.complexity.GetItemsResponse.Items == nil {
			break
		}

		return e.complexity.GetItemsResponse.Items(childComplexity), true

	case "GetItemsResponse.success":
		if e.complexity.GetItemsResponse.Success == nil {
			break
		}

		return e.complexity.GetItemsResponse.Success(childComplexity), true

	case "GetMatchResponse.error":
		if e.complexity.GetMatchResponse.Error == nil {
			break
		}

		return e.complexity.GetMatchResponse.Error(childComplexity), true

	case "GetMatchResponse.match":
		if e.complexity.GetMatchResponse.Match == nil {
			break
		}

		return e.complexity.GetMatchResponse.Match(childComplexity), true

	case "GetMatchResponse.success":
		if e.complexity.GetMatchResponse.Success == nil {
			break
		}

		return e.complexity.GetMatchResponse.Success(childComplexity), true

	case "GetMatchesResponse.matches":
		if e.complexity.GetMatchesResponse.Matches == nil {
			break
		}

		return e.complexity.GetMatchesResponse.Matches(childComplexity), true

	case "GetMatchesResponse.success":
		if e.complexity.GetMatchesResponse.Success == nil {
			break
		}

		return e.complexity.GetMatchesResponse.Success(childComplexity), true

	case "GetMatchmakingTicketResponse.error":
		if e.complexity.GetMatchmakingTicketResponse.Error == nil {
			break
		}

		return e.complexity.GetMatchmakingTicketResponse.Error(childComplexity), true

	case "GetMatchmakingTicketResponse.matchmakingTicket":
		if e.complexity.GetMatchmakingTicketResponse.MatchmakingTicket == nil {
			break
		}

		return e.complexity.GetMatchmakingTicketResponse.MatchmakingTicket(childComplexity), true

	case "GetMatchmakingTicketResponse.success":
		if e.complexity.GetMatchmakingTicketResponse.Success == nil {
			break
		}

		return e.complexity.GetMatchmakingTicketResponse.Success(childComplexity), true

	case "GetMatchmakingTicketsResponse.error":
		if e.complexity.GetMatchmakingTicketsResponse.Error == nil {
			break
		}

		return e.complexity.GetMatchmakingTicketsResponse.Error(childComplexity), true

	case "GetMatchmakingTicketsResponse.matchmakingTickets":
		if e.complexity.GetMatchmakingTicketsResponse.MatchmakingTickets == nil {
			break
		}

		return e.complexity.GetMatchmakingTicketsResponse.MatchmakingTickets(childComplexity), true

	case "GetMatchmakingTicketsResponse.success":
		if e.complexity.GetMatchmakingTicketsResponse.Success == nil {
			break
		}

		return e.complexity.GetMatchmakingTicketsResponse.Success(childComplexity), true

	case "GetMatchmakingUserResponse.error":
		if e.complexity.GetMatchmakingUserResponse.Error == nil {
			break
		}

		return e.complexity.GetMatchmakingUserResponse.Error(childComplexity), true

	case "GetMatchmakingUserResponse.matchmakingUser":
		if e.complexity.GetMatchmakingUserResponse.MatchmakingUser == nil {
			break
		}

		return e.complexity.GetMatchmakingUserResponse.MatchmakingUser(childComplexity), true

	case "GetMatchmakingUserResponse.success":
		if e.complexity.GetMatchmakingUserResponse.Success == nil {
			break
		}

		return e.complexity.GetMatchmakingUserResponse.Success(childComplexity), true

	case "GetMatchmakingUsersResponse.matchmakingUsers":
		if e.complexity.GetMatchmakingUsersResponse.MatchmakingUsers == nil {
			break
		}

		return e.complexity.GetMatchmakingUsersResponse.MatchmakingUsers(childComplexity), true

	case "GetMatchmakingUsersResponse.success":
		if e.complexity.GetMatchmakingUsersResponse.Success == nil {
			break
		}

		return e.complexity.GetMatchmakingUsersResponse.Success(childComplexity), true

	case "GetRecordResponse.error":
		if e.complexity.GetRecordResponse.Error == nil {
			break
		}

		return e.complexity.GetRecordResponse.Error(childComplexity), true

	case "GetRecordResponse.record":
		if e.complexity.GetRecordResponse.Record == nil {
			break
		}

		return e.complexity.GetRecordResponse.Record(childComplexity), true

	case "GetRecordResponse.success":
		if e.complexity.GetRecordResponse.Success == nil {
			break
		}

		return e.complexity.GetRecordResponse.Success(childComplexity), true

	case "GetRecordsResponse.error":
		if e.complexity.GetRecordsResponse.Error == nil {
			break
		}

		return e.complexity.GetRecordsResponse.Error(childComplexity), true

	case "GetRecordsResponse.records":
		if e.complexity.GetRecordsResponse.Records == nil {
			break
		}

		return e.complexity.GetRecordsResponse.Records(childComplexity), true

	case "GetRecordsResponse.success":
		if e.complexity.GetRecordsResponse.Success == nil {
			break
		}

		return e.complexity.GetRecordsResponse.Success(childComplexity), true

	case "GetTaskResponse.error":
		if e.complexity.GetTaskResponse.Error == nil {
			break
		}

		return e.complexity.GetTaskResponse.Error(childComplexity), true

	case "GetTaskResponse.success":
		if e.complexity.GetTaskResponse.Success == nil {
			break
		}

		return e.complexity.GetTaskResponse.Success(childComplexity), true

	case "GetTaskResponse.task":
		if e.complexity.GetTaskResponse.Task == nil {
			break
		}

		return e.complexity.GetTaskResponse.Task(childComplexity), true

	case "GetTasksResponse.success":
		if e.complexity.GetTasksResponse.Success == nil {
			break
		}

		return e.complexity.GetTasksResponse.Success(childComplexity), true

	case "GetTasksResponse.tasks":
		if e.complexity.GetTasksResponse.Tasks == nil {
			break
		}

		return e.complexity.GetTasksResponse.Tasks(childComplexity), true

	case "GetTeamMemberResponse.error":
		if e.complexity.GetTeamMemberResponse.Error == nil {
			break
		}

		return e.complexity.GetTeamMemberResponse.Error(childComplexity), true

	case "GetTeamMemberResponse.member":
		if e.complexity.GetTeamMemberResponse.Member == nil {
			break
		}

		return e.complexity.GetTeamMemberResponse.Member(childComplexity), true

	case "GetTeamMemberResponse.success":
		if e.complexity.GetTeamMemberResponse.Success == nil {
			break
		}

		return e.complexity.GetTeamMemberResponse.Success(childComplexity), true

	case "GetTeamResponse.error":
		if e.complexity.GetTeamResponse.Error == nil {
			break
		}

		return e.complexity.GetTeamResponse.Error(childComplexity), true

	case "GetTeamResponse.success":
		if e.complexity.GetTeamResponse.Success == nil {
			break
		}

		return e.complexity.GetTeamResponse.Success(childComplexity), true

	case "GetTeamResponse.team":
		if e.complexity.GetTeamResponse.Team == nil {
			break
		}

		return e.complexity.GetTeamResponse.Team(childComplexity), true

	case "GetTeamsResponse.success":
		if e.complexity.GetTeamsResponse.Success == nil {
			break
		}

		return e.complexity.GetTeamsResponse.Success(childComplexity), true

	case "GetTeamsResponse.teams":
		if e.complexity.GetTeamsResponse.Teams == nil {
			break
		}

		return e.complexity.GetTeamsResponse.Teams(childComplexity), true

	case "GetTournamentUserResponse.error":
		if e.complexity.GetTournamentUserResponse.Error == nil {
			break
		}

		return e.complexity.GetTournamentUserResponse.Error(childComplexity), true

	case "GetTournamentUserResponse.success":
		if e.complexity.GetTournamentUserResponse.Success == nil {
			break
		}

		return e.complexity.GetTournamentUserResponse.Success(childComplexity), true

	case "GetTournamentUserResponse.tournamentUser":
		if e.complexity.GetTournamentUserResponse.TournamentUser == nil {
			break
		}

		return e.complexity.GetTournamentUserResponse.TournamentUser(childComplexity), true

	case "GetTournamentUsersResponse.error":
		if e.complexity.GetTournamentUsersResponse.Error == nil {
			break
		}

		return e.complexity.GetTournamentUsersResponse.Error(childComplexity), true

	case "GetTournamentUsersResponse.success":
		if e.complexity.GetTournamentUsersResponse.Success == nil {
			break
		}

		return e.complexity.GetTournamentUsersResponse.Success(childComplexity), true

	case "GetTournamentUsersResponse.tournamentUsers":
		if e.complexity.GetTournamentUsersResponse.TournamentUsers == nil {
			break
		}

		return e.complexity.GetTournamentUsersResponse.TournamentUsers(childComplexity), true

	case "Item.createdAt":
		if e.complexity.Item.CreatedAt == nil {
			break
		}

		return e.complexity.Item.CreatedAt(childComplexity), true

	case "Item.data":
		if e.complexity.Item.Data == nil {
			break
		}

		return e.complexity.Item.Data(childComplexity), true

	case "Item.expiresAt":
		if e.complexity.Item.ExpiresAt == nil {
			break
		}

		return e.complexity.Item.ExpiresAt(childComplexity), true

	case "Item.id":
		if e.complexity.Item.Id == nil {
			break
		}

		return e.complexity.Item.Id(childComplexity), true

	case "Item.type":
		if e.complexity.Item.Type == nil {
			break
		}

		return e.complexity.Item.Type(childComplexity), true

	case "Item.updatedAt":
		if e.complexity.Item.UpdatedAt == nil {
			break
		}

		return e.complexity.Item.UpdatedAt(childComplexity), true

	case "ItemResponse.error":
		if e.complexity.ItemResponse.Error == nil {
			break
		}

		return e.complexity.ItemResponse.Error(childComplexity), true

	case "ItemResponse.success":
		if e.complexity.ItemResponse.Success == nil {
			break
		}

		return e.complexity.ItemResponse.Success(childComplexity), true

	case "JoinTeamResponse.error":
		if e.complexity.JoinTeamResponse.Error == nil {
			break
		}

		return e.complexity.JoinTeamResponse.Error(childComplexity), true

	case "JoinTeamResponse.success":
		if e.complexity.JoinTeamResponse.Success == nil {
			break
		}

		return e.complexity.JoinTeamResponse.Success(childComplexity), true

	case "LeaveTeamResponse.error":
		if e.complexity.LeaveTeamResponse.Error == nil {
			break
		}

		return e.complexity.LeaveTeamResponse.Error(childComplexity), true

	case "LeaveTeamResponse.success":
		if e.complexity.LeaveTeamResponse.Success == nil {
			break
		}

		return e.complexity.LeaveTeamResponse.Success(childComplexity), true

	case "Match.arena":
		if e.complexity.Match.Arena == nil {
			break
		}

		return e.complexity.Match.Arena(childComplexity), true

	case "Match.createdAt":
		if e.complexity.Match.CreatedAt == nil {
			break
		}

		return e.complexity.Match.CreatedAt(childComplexity), true

	case "Match.data":
		if e.complexity.Match.Data == nil {
			break
		}

		return e.complexity.Match.Data(childComplexity), true

	case "Match.endedAt":
		if e.complexity.Match.EndedAt == nil {
			break
		}

		return e.complexity.Match.EndedAt(childComplexity), true

	case "Match.id":
		if e.complexity.Match.Id == nil {
			break
		}

		return e.complexity.Match.Id(childComplexity), true

	case "Match.lockedAt":
		if e.complexity.Match.LockedAt == nil {
			break
		}

		return e.complexity.Match.LockedAt(childComplexity), true

	case "Match.privateServerId":
		if e.complexity.Match.PrivateServerId == nil {
			break
		}

		return e.complexity.Match.PrivateServerId(childComplexity), true

	case "Match.startedAt":
		if e.complexity.Match.StartedAt == nil {
			break
		}

		return e.complexity.Match.StartedAt(childComplexity), true

	case "Match.status":
		if e.complexity.Match.Status == nil {
			break
		}

		return e.complexity.Match.Status(childComplexity), true

	case "Match.tickets":
		if e.complexity.Match.Tickets == nil {
			break
		}

		return e.complexity.Match.Tickets(childComplexity), true

	case "Match.updatedAt":
		if e.complexity.Match.UpdatedAt == nil {
			break
		}

		return e.complexity.Match.UpdatedAt(childComplexity), true

	case "MatchmakingTicket.arenas":
		if e.complexity.MatchmakingTicket.Arenas == nil {
			break
		}

		return e.complexity.MatchmakingTicket.Arenas(childComplexity), true

	case "MatchmakingTicket.createdAt":
		if e.complexity.MatchmakingTicket.CreatedAt == nil {
			break
		}

		return e.complexity.MatchmakingTicket.CreatedAt(childComplexity), true

	case "MatchmakingTicket.data":
		if e.complexity.MatchmakingTicket.Data == nil {
			break
		}

		return e.complexity.MatchmakingTicket.Data(childComplexity), true

	case "MatchmakingTicket.id":
		if e.complexity.MatchmakingTicket.Id == nil {
			break
		}

		return e.complexity.MatchmakingTicket.Id(childComplexity), true

	case "MatchmakingTicket.matchId":
		if e.complexity.MatchmakingTicket.MatchId == nil {
			break
		}

		return e.complexity.MatchmakingTicket.MatchId(childComplexity), true

	case "MatchmakingTicket.matchmakingUsers":
		if e.complexity.MatchmakingTicket.MatchmakingUsers == nil {
			break
		}

		return e.complexity.MatchmakingTicket.MatchmakingUsers(childComplexity), true

	case "MatchmakingTicket.status":
		if e.complexity.MatchmakingTicket.Status == nil {
			break
		}

		return e.complexity.MatchmakingTicket.Status(childComplexity), true

	case "MatchmakingTicket.updatedAt":
		if e.complexity.MatchmakingTicket.UpdatedAt == nil {
			break
		}

		return e.complexity.MatchmakingTicket.UpdatedAt(childComplexity), true

	case "MatchmakingUser.clientUserId":
		if e.complexity.MatchmakingUser.ClientUserId == nil {
			break
		}

		return e.complexity.MatchmakingUser.ClientUserId(childComplexity), true

	case "MatchmakingUser.createdAt":
		if e.complexity.MatchmakingUser.CreatedAt == nil {
			break
		}

		return e.complexity.MatchmakingUser.CreatedAt(childComplexity), true

	case "MatchmakingUser.data":
		if e.complexity.MatchmakingUser.Data == nil {
			break
		}

		return e.complexity.MatchmakingUser.Data(childComplexity), true

	case "MatchmakingUser.elo":
		if e.complexity.MatchmakingUser.Elo == nil {
			break
		}

		return e.complexity.MatchmakingUser.Elo(childComplexity), true

	case "MatchmakingUser.id":
		if e.complexity.MatchmakingUser.Id == nil {
			break
		}

		return e.complexity.MatchmakingUser.Id(childComplexity), true

	case "MatchmakingUser.updatedAt":
		if e.complexity.MatchmakingUser.UpdatedAt == nil {
			break
		}

		return e.complexity.MatchmakingUser.UpdatedAt(childComplexity), true

	case "Mutation.AddEventResult":
		if e.complexity.Mutation.AddEventResult == nil {
			break
		}

		args, err := ec.field_Mutation_AddEventResult_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEventResult(childComplexity, args["input"].(*api.AddEventResultRequest)), true

	case "Mutation.CompleteTask":
		if e.complexity.Mutation.CompleteTask == nil {
			break
		}

		args, err := ec.field_Mutation_CompleteTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CompleteTask(childComplexity, args["input"].(*api.TaskRequest)), true

	case "Mutation.CreateArena":
		if e.complexity.Mutation.CreateArena == nil {
			break
		}

		args, err := ec.field_Mutation_CreateArena_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateArena(childComplexity, args["input"].(*api.CreateArenaRequest)), true

	case "Mutation.CreateEvent":
		if e.complexity.Mutation.CreateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_CreateEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEvent(childComplexity, args["input"].(*api.CreateEventRequest)), true

	case "Mutation.CreateEventRound":
		if e.complexity.Mutation.CreateEventRound == nil {
			break
		}

		args, err := ec.field_Mutation_CreateEventRound_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEventRound(childComplexity, args["input"].(*api.CreateEventRoundRequest)), true

	case "Mutation.CreateItem":
		if e.complexity.Mutation.CreateItem == nil {
			break
		}

		args, err := ec.field_Mutation_CreateItem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateItem(childComplexity, args["input"].(*api.CreateItemRequest)), true

	case "Mutation.CreateMatchmakingTicket":
		if e.complexity.Mutation.CreateMatchmakingTicket == nil {
			break
		}

		args, err := ec.field_Mutation_CreateMatchmakingTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatchmakingTicket(childComplexity, args["input"].(*api.CreateMatchmakingTicketRequest)), true

	case "Mutation.CreateMatchmakingUser":
		if e.complexity.Mutation.CreateMatchmakingUser == nil {
			break
		}

		args, err := ec.field_Mutation_CreateMatchmakingUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatchmakingUser(childComplexity, args["input"].(*api.CreateMatchmakingUserRequest)), true

	case "Mutation.CreateRecord":
		if e.complexity.Mutation.CreateRecord == nil {
			break
		}

		args, err := ec.field_Mutation_CreateRecord_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRecord(childComplexity, args["input"].(*api.CreateRecordRequest)), true

	case "Mutation.CreateTask":
		if e.complexity.Mutation.CreateTask == nil {
			break
		}

		args, err := ec.field_Mutation_CreateTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTask(childComplexity, args["input"].(*api.CreateTaskRequest)), true

	case "Mutation.CreateTeam":
		if e.complexity.Mutation.CreateTeam == nil {
			break
		}

		args, err := ec.field_Mutation_CreateTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTeam(childComplexity, args["input"].(*api.CreateTeamRequest)), true

	case "Mutation.CreateTournamentUser":
		if e.complexity.Mutation.CreateTournamentUser == nil {
			break
		}

		args, err := ec.field_Mutation_CreateTournamentUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTournamentUser(childComplexity, args["input"].(*api.CreateTournamentUserRequest)), true

	case "Mutation.DeleteEvent":
		if e.complexity.Mutation.DeleteEvent == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEvent(childComplexity, args["input"].(*api.EventRequest)), true

	case "Mutation.DeleteEventUser":
		if e.complexity.Mutation.DeleteEventUser == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteEventUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEventUser(childComplexity, args["input"].(*api.EventUserRequest)), true

	case "Mutation.DeleteItem":
		if e.complexity.Mutation.DeleteItem == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteItem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteItem(childComplexity, args["input"].(*api.ItemRequest)), true

	case "Mutation.DeleteMatch":
		if e.complexity.Mutation.DeleteMatch == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteMatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMatch(childComplexity, args["input"].(*api.MatchRequest)), true

	case "Mutation.DeleteMatchmakingTicket":
		if e.complexity.Mutation.DeleteMatchmakingTicket == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteMatchmakingTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMatchmakingTicket(childComplexity, args["input"].(*api.MatchmakingTicketRequest)), true

	case "Mutation.DeleteMatchmakingUser":
		if e.complexity.Mutation.DeleteMatchmakingUser == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteMatchmakingUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMatchmakingUser(childComplexity, args["input"].(*api.MatchmakingUserRequest)), true

	case "Mutation.DeleteRecord":
		if e.complexity.Mutation.DeleteRecord == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteRecord_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRecord(childComplexity, args["input"].(*api.RecordRequest)), true

	case "Mutation.DeleteTask":
		if e.complexity.Mutation.DeleteTask == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTask(childComplexity, args["input"].(*api.TaskRequest)), true

	case "Mutation.DeleteTeam":
		if e.complexity.Mutation.DeleteTeam == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTeam(childComplexity, args["input"].(*api.TeamRequest)), true

	case "Mutation.DeleteTournamentUser":
		if e.complexity.Mutation.DeleteTournamentUser == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteTournamentUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTournamentUser(childComplexity, args["input"].(*api.TournamentUserRequest)), true

	case "Mutation.EndMatch":
		if e.complexity.Mutation.EndMatch == nil {
			break
		}

		args, err := ec.field_Mutation_EndMatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EndMatch(childComplexity, args["input"].(*api.EndMatchRequest)), true

	case "Mutation.JoinTeam":
		if e.complexity.Mutation.JoinTeam == nil {
			break
		}

		args, err := ec.field_Mutation_JoinTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.JoinTeam(childComplexity, args["input"].(*api.JoinTeamRequest)), true

	case "Mutation.LeaveTeam":
		if e.complexity.Mutation.LeaveTeam == nil {
			break
		}

		args, err := ec.field_Mutation_LeaveTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LeaveTeam(childComplexity, args["input"].(*api.TeamMemberRequest)), true

	case "Mutation.RemoveEventResult":
		if e.complexity.Mutation.RemoveEventResult == nil {
			break
		}

		args, err := ec.field_Mutation_RemoveEventResult_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveEventResult(childComplexity, args["input"].(*api.EventRoundUserRequest)), true

	case "Mutation.SetMatchPrivateServer":
		if e.complexity.Mutation.SetMatchPrivateServer == nil {
			break
		}

		args, err := ec.field_Mutation_SetMatchPrivateServer_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetMatchPrivateServer(childComplexity, args["input"].(*api.SetMatchPrivateServerRequest)), true

	case "Mutation.StartMatch":
		if e.complexity.Mutation.StartMatch == nil {
			break
		}

		args, err := ec.field_Mutation_StartMatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StartMatch(childComplexity, args["input"].(*api.StartMatchRequest)), true

	case "Mutation.UpdateArena":
		if e.complexity.Mutation.UpdateArena == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateArena_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateArena(childComplexity, args["input"].(*api.UpdateArenaRequest)), true

	case "Mutation.UpdateEvent":
		if e.complexity.Mutation.UpdateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEvent(childComplexity, args["input"].(*api.UpdateEventRequest)), true

	case "Mutation.UpdateEventRound":
		if e.complexity.Mutation.UpdateEventRound == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateEventRound_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventRound(childComplexity, args["input"].(*api.UpdateEventRoundRequest)), true

	case "Mutation.UpdateEventUser":
		if e.complexity.Mutation.UpdateEventUser == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateEventUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventUser(childComplexity, args["input"].(*api.UpdateEventUserRequest)), true

	case "Mutation.UpdateItem":
		if e.complexity.Mutation.UpdateItem == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateItem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateItem(childComplexity, args["input"].(*api.UpdateItemRequest)), true

	case "Mutation.UpdateMatch":
		if e.complexity.Mutation.UpdateMatch == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateMatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatch(childComplexity, args["input"].(*api.UpdateMatchRequest)), true

	case "Mutation.UpdateMatchmakingTicket":
		if e.complexity.Mutation.UpdateMatchmakingTicket == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateMatchmakingTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatchmakingTicket(childComplexity, args["input"].(*api.UpdateMatchmakingTicketRequest)), true

	case "Mutation.UpdateMatchmakingUser":
		if e.complexity.Mutation.UpdateMatchmakingUser == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateMatchmakingUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatchmakingUser(childComplexity, args["input"].(*api.UpdateMatchmakingUserRequest)), true

	case "Mutation.UpdateRecord":
		if e.complexity.Mutation.UpdateRecord == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateRecord_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRecord(childComplexity, args["input"].(*api.UpdateRecordRequest)), true

	case "Mutation.UpdateTask":
		if e.complexity.Mutation.UpdateTask == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTask(childComplexity, args["input"].(*api.UpdateTaskRequest)), true

	case "Mutation.UpdateTeam":
		if e.complexity.Mutation.UpdateTeam == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTeam(childComplexity, args["input"].(*api.UpdateTeamRequest)), true

	case "Mutation.UpdateTeamMember":
		if e.complexity.Mutation.UpdateTeamMember == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateTeamMember_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTeamMember(childComplexity, args["input"].(*api.UpdateTeamMemberRequest)), true

	case "Mutation.UpdateTournamentUser":
		if e.complexity.Mutation.UpdateTournamentUser == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateTournamentUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTournamentUser(childComplexity, args["input"].(*api.UpdateTournamentUserRequest)), true

	case "Mutation.Webhook":
		if e.complexity.Mutation.Webhook == nil {
			break
		}

		args, err := ec.field_Mutation_Webhook_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Webhook(childComplexity, args["input"].(*api.WebhookRequest)), true

	case "Query.GetArena":
		if e.complexity.Query.GetArena == nil {
			break
		}

		args, err := ec.field_Query_GetArena_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetArena(childComplexity, args["input"].(*api.ArenaRequest)), true

	case "Query.GetArenas":
		if e.complexity.Query.GetArenas == nil {
			break
		}

		args, err := ec.field_Query_GetArenas_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetArenas(childComplexity, args["input"].(*api.Pagination)), true

	case "Query.GetEvent":
		if e.complexity.Query.GetEvent == nil {
			break
		}

		args, err := ec.field_Query_GetEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetEvent(childComplexity, args["input"].(*api.GetEventRequest)), true

	case "Query.GetEventRound":
		if e.complexity.Query.GetEventRound == nil {
			break
		}

		args, err := ec.field_Query_GetEventRound_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetEventRound(childComplexity, args["input"].(*api.GetEventRoundRequest)), true

	case "Query.GetEventUser":
		if e.complexity.Query.GetEventUser == nil {
			break
		}

		args, err := ec.field_Query_GetEventUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetEventUser(childComplexity, args["input"].(*api.GetEventUserRequest)), true

	case "Query.GetItem":
		if e.complexity.Query.GetItem == nil {
			break
		}

		args, err := ec.field_Query_GetItem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetItem(childComplexity, args["input"].(*api.ItemRequest)), true

	case "Query.GetItems":
		if e.complexity.Query.GetItems == nil {
			break
		}

		args, err := ec.field_Query_GetItems_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetItems(childComplexity, args["input"].(*api.GetItemsRequest)), true

	case "Query.GetMatch":
		if e.complexity.Query.GetMatch == nil {
			break
		}

		args, err := ec.field_Query_GetMatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMatch(childComplexity, args["input"].(*api.GetMatchRequest)), true

	case "Query.GetMatches":
		if e.complexity.Query.GetMatches == nil {
			break
		}

		args, err := ec.field_Query_GetMatches_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMatches(childComplexity, args["input"].(*api.GetMatchesRequest)), true

	case "Query.GetMatchmakingTicket":
		if e.complexity.Query.GetMatchmakingTicket == nil {
			break
		}

		args, err := ec.field_Query_GetMatchmakingTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMatchmakingTicket(childComplexity, args["input"].(*api.GetMatchmakingTicketRequest)), true

	case "Query.GetMatchmakingTickets":
		if e.complexity.Query.GetMatchmakingTickets == nil {
			break
		}

		args, err := ec.field_Query_GetMatchmakingTickets_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMatchmakingTickets(childComplexity, args["input"].(*api.GetMatchmakingTicketsRequest)), true

	case "Query.GetMatchmakingUser":
		if e.complexity.Query.GetMatchmakingUser == nil {
			break
		}

		args, err := ec.field_Query_GetMatchmakingUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMatchmakingUser(childComplexity, args["input"].(*api.MatchmakingUserRequest)), true

	case "Query.GetMatchmakingUsers":
		if e.complexity.Query.GetMatchmakingUsers == nil {
			break
		}

		args, err := ec.field_Query_GetMatchmakingUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMatchmakingUsers(childComplexity, args["input"].(*api.Pagination)), true

	case "Query.GetRecord":
		if e.complexity.Query.GetRecord == nil {
			break
		}

		args, err := ec.field_Query_GetRecord_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetRecord(childComplexity, args["input"].(*api.RecordRequest)), true

	case "Query.GetRecords":
		if e.complexity.Query.GetRecords == nil {
			break
		}

		args, err := ec.field_Query_GetRecords_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetRecords(childComplexity, args["input"].(*api.GetRecordsRequest)), true

	case "Query.GetTask":
		if e.complexity.Query.GetTask == nil {
			break
		}

		args, err := ec.field_Query_GetTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTask(childComplexity, args["input"].(*api.TaskRequest)), true

	case "Query.GetTasks":
		if e.complexity.Query.GetTasks == nil {
			break
		}

		args, err := ec.field_Query_GetTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTasks(childComplexity, args["input"].(*api.GetTasksRequest)), true

	case "Query.GetTeam":
		if e.complexity.Query.GetTeam == nil {
			break
		}

		args, err := ec.field_Query_GetTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTeam(childComplexity, args["input"].(*api.GetTeamRequest)), true

	case "Query.GetTeamMember":
		if e.complexity.Query.GetTeamMember == nil {
			break
		}

		args, err := ec.field_Query_GetTeamMember_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTeamMember(childComplexity, args["input"].(*api.TeamMemberRequest)), true

	case "Query.GetTeams":
		if e.complexity.Query.GetTeams == nil {
			break
		}

		args, err := ec.field_Query_GetTeams_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTeams(childComplexity, args["input"].(*api.GetTeamsRequest)), true

	case "Query.GetTournamentUser":
		if e.complexity.Query.GetTournamentUser == nil {
			break
		}

		args, err := ec.field_Query_GetTournamentUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTournamentUser(childComplexity, args["input"].(*api.TournamentUserRequest)), true

	case "Query.GetTournamentUsers":
		if e.complexity.Query.GetTournamentUsers == nil {
			break
		}

		args, err := ec.field_Query_GetTournamentUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTournamentUsers(childComplexity, args["input"].(*api.GetTournamentUsersRequest)), true

	case "Query.SearchTeams":
		if e.complexity.Query.SearchTeams == nil {
			break
		}

		args, err := ec.field_Query_SearchTeams_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchTeams(childComplexity, args["input"].(*api.SearchTeamsRequest)), true

	case "Record.createdAt":
		if e.complexity.Record.CreatedAt == nil {
			break
		}

		return e.complexity.Record.CreatedAt(childComplexity), true

	case "Record.data":
		if e.complexity.Record.Data == nil {
			break
		}

		return e.complexity.Record.Data(childComplexity), true

	case "Record.id":
		if e.complexity.Record.Id == nil {
			break
		}

		return e.complexity.Record.Id(childComplexity), true

	case "Record.name":
		if e.complexity.Record.Name == nil {
			break
		}

		return e.complexity.Record.Name(childComplexity), true

	case "Record.ranking":
		if e.complexity.Record.Ranking == nil {
			break
		}

		return e.complexity.Record.Ranking(childComplexity), true

	case "Record.record":
		if e.complexity.Record.Record == nil {
			break
		}

		return e.complexity.Record.Record(childComplexity), true

	case "Record.updatedAt":
		if e.complexity.Record.UpdatedAt == nil {
			break
		}

		return e.complexity.Record.UpdatedAt(childComplexity), true

	case "Record.userId":
		if e.complexity.Record.UserId == nil {
			break
		}

		return e.complexity.Record.UserId(childComplexity), true

	case "RemoveEventResultResponse.error":
		if e.complexity.RemoveEventResultResponse.Error == nil {
			break
		}

		return e.complexity.RemoveEventResultResponse.Error(childComplexity), true

	case "RemoveEventResultResponse.success":
		if e.complexity.RemoveEventResultResponse.Success == nil {
			break
		}

		return e.complexity.RemoveEventResultResponse.Success(childComplexity), true

	case "SearchTeamsResponse.error":
		if e.complexity.SearchTeamsResponse.Error == nil {
			break
		}

		return e.complexity.SearchTeamsResponse.Error(childComplexity), true

	case "SearchTeamsResponse.success":
		if e.complexity.SearchTeamsResponse.Success == nil {
			break
		}

		return e.complexity.SearchTeamsResponse.Success(childComplexity), true

	case "SearchTeamsResponse.teams":
		if e.complexity.SearchTeamsResponse.Teams == nil {
			break
		}

		return e.complexity.SearchTeamsResponse.Teams(childComplexity), true

	case "SetMatchPrivateServerResponse.error":
		if e.complexity.SetMatchPrivateServerResponse.Error == nil {
			break
		}

		return e.complexity.SetMatchPrivateServerResponse.Error(childComplexity), true

	case "SetMatchPrivateServerResponse.privateServerId":
		if e.complexity.SetMatchPrivateServerResponse.PrivateServerId == nil {
			break
		}

		return e.complexity.SetMatchPrivateServerResponse.PrivateServerId(childComplexity), true

	case "SetMatchPrivateServerResponse.success":
		if e.complexity.SetMatchPrivateServerResponse.Success == nil {
			break
		}

		return e.complexity.SetMatchPrivateServerResponse.Success(childComplexity), true

	case "StartMatchResponse.error":
		if e.complexity.StartMatchResponse.Error == nil {
			break
		}

		return e.complexity.StartMatchResponse.Error(childComplexity), true

	case "StartMatchResponse.success":
		if e.complexity.StartMatchResponse.Success == nil {
			break
		}

		return e.complexity.StartMatchResponse.Success(childComplexity), true

	case "Task.completedAt":
		if e.complexity.Task.CompletedAt == nil {
			break
		}

		return e.complexity.Task.CompletedAt(childComplexity), true

	case "Task.createdAt":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true

	case "Task.data":
		if e.complexity.Task.Data == nil {
			break
		}

		return e.complexity.Task.Data(childComplexity), true

	case "Task.expiresAt":
		if e.complexity.Task.ExpiresAt == nil {
			break
		}

		return e.complexity.Task.ExpiresAt(childComplexity), true

	case "Task.id":
		if e.complexity.Task.Id == nil {
			break
		}

		return e.complexity.Task.Id(childComplexity), true

	case "Task.type":
		if e.complexity.Task.Type == nil {
			break
		}

		return e.complexity.Task.Type(childComplexity), true

	case "Task.updatedAt":
		if e.complexity.Task.UpdatedAt == nil {
			break
		}

		return e.complexity.Task.UpdatedAt(childComplexity), true

	case "TaskResponse.error":
		if e.complexity.TaskResponse.Error == nil {
			break
		}

		return e.complexity.TaskResponse.Error(childComplexity), true

	case "TaskResponse.success":
		if e.complexity.TaskResponse.Success == nil {
			break
		}

		return e.complexity.TaskResponse.Success(childComplexity), true

	case "Team.createdAt":
		if e.complexity.Team.CreatedAt == nil {
			break
		}

		return e.complexity.Team.CreatedAt(childComplexity), true

	case "Team.data":
		if e.complexity.Team.Data == nil {
			break
		}

		return e.complexity.Team.Data(childComplexity), true

	case "Team.id":
		if e.complexity.Team.Id == nil {
			break
		}

		return e.complexity.Team.Id(childComplexity), true

	case "Team.members":
		if e.complexity.Team.Members == nil {
			break
		}

		return e.complexity.Team.Members(childComplexity), true

	case "Team.name":
		if e.complexity.Team.Name == nil {
			break
		}

		return e.complexity.Team.Name(childComplexity), true

	case "Team.ranking":
		if e.complexity.Team.Ranking == nil {
			break
		}

		return e.complexity.Team.Ranking(childComplexity), true

	case "Team.score":
		if e.complexity.Team.Score == nil {
			break
		}

		return e.complexity.Team.Score(childComplexity), true

	case "Team.updatedAt":
		if e.complexity.Team.UpdatedAt == nil {
			break
		}

		return e.complexity.Team.UpdatedAt(childComplexity), true

	case "TeamMember.data":
		if e.complexity.TeamMember.Data == nil {
			break
		}

		return e.complexity.TeamMember.Data(childComplexity), true

	case "TeamMember.id":
		if e.complexity.TeamMember.Id == nil {
			break
		}

		return e.complexity.TeamMember.Id(childComplexity), true

	case "TeamMember.joinedAt":
		if e.complexity.TeamMember.JoinedAt == nil {
			break
		}

		return e.complexity.TeamMember.JoinedAt(childComplexity), true

	case "TeamMember.teamId":
		if e.complexity.TeamMember.TeamId == nil {
			break
		}

		return e.complexity.TeamMember.TeamId(childComplexity), true

	case "TeamMember.updatedAt":
		if e.complexity.TeamMember.UpdatedAt == nil {
			break
		}

		return e.complexity.TeamMember.UpdatedAt(childComplexity), true

	case "TeamMember.userId":
		if e.complexity.TeamMember.UserId == nil {
			break
		}

		return e.complexity.TeamMember.UserId(childComplexity), true

	case "TeamResponse.error":
		if e.complexity.TeamResponse.Error == nil {
			break
		}

		return e.complexity.TeamResponse.Error(childComplexity), true

	case "TeamResponse.success":
		if e.complexity.TeamResponse.Success == nil {
			break
		}

		return e.complexity.TeamResponse.Success(childComplexity), true

	case "TournamentUser.createdAt":
		if e.complexity.TournamentUser.CreatedAt == nil {
			break
		}

		return e.complexity.TournamentUser.CreatedAt(childComplexity), true

	case "TournamentUser.data":
		if e.complexity.TournamentUser.Data == nil {
			break
		}

		return e.complexity.TournamentUser.Data(childComplexity), true

	case "TournamentUser.id":
		if e.complexity.TournamentUser.Id == nil {
			break
		}

		return e.complexity.TournamentUser.Id(childComplexity), true

	case "TournamentUser.interval":
		if e.complexity.TournamentUser.Interval == nil {
			break
		}

		return e.complexity.TournamentUser.Interval(childComplexity), true

	case "TournamentUser.ranking":
		if e.complexity.TournamentUser.Ranking == nil {
			break
		}

		return e.complexity.TournamentUser.Ranking(childComplexity), true

	case "TournamentUser.score":
		if e.complexity.TournamentUser.Score == nil {
			break
		}

		return e.complexity.TournamentUser.Score(childComplexity), true

	case "TournamentUser.tournament":
		if e.complexity.TournamentUser.Tournament == nil {
			break
		}

		return e.complexity.TournamentUser.Tournament(childComplexity), true

	case "TournamentUser.tournamentStartedAt":
		if e.complexity.TournamentUser.TournamentStartedAt == nil {
			break
		}

		return e.complexity.TournamentUser.TournamentStartedAt(childComplexity), true

	case "TournamentUser.updatedAt":
		if e.complexity.TournamentUser.UpdatedAt == nil {
			break
		}

		return e.complexity.TournamentUser.UpdatedAt(childComplexity), true

	case "TournamentUser.userId":
		if e.complexity.TournamentUser.UserId == nil {
			break
		}

		return e.complexity.TournamentUser.UserId(childComplexity), true

	case "TournamentUserResponse.error":
		if e.complexity.TournamentUserResponse.Error == nil {
			break
		}

		return e.complexity.TournamentUserResponse.Error(childComplexity), true

	case "TournamentUserResponse.success":
		if e.complexity.TournamentUserResponse.Success == nil {
			break
		}

		return e.complexity.TournamentUserResponse.Success(childComplexity), true

	case "UpdateArenaResponse.error":
		if e.complexity.UpdateArenaResponse.Error == nil {
			break
		}

		return e.complexity.UpdateArenaResponse.Error(childComplexity), true

	case "UpdateArenaResponse.success":
		if e.complexity.UpdateArenaResponse.Success == nil {
			break
		}

		return e.complexity.UpdateArenaResponse.Success(childComplexity), true

	case "UpdateEventResponse.error":
		if e.complexity.UpdateEventResponse.Error == nil {
			break
		}

		return e.complexity.UpdateEventResponse.Error(childComplexity), true

	case "UpdateEventResponse.success":
		if e.complexity.UpdateEventResponse.Success == nil {
			break
		}

		return e.complexity.UpdateEventResponse.Success(childComplexity), true

	case "UpdateEventRoundResponse.error":
		if e.complexity.UpdateEventRoundResponse.Error == nil {
			break
		}

		return e.complexity.UpdateEventRoundResponse.Error(childComplexity), true

	case "UpdateEventRoundResponse.success":
		if e.complexity.UpdateEventRoundResponse.Success == nil {
			break
		}

		return e.complexity.UpdateEventRoundResponse.Success(childComplexity), true

	case "UpdateEventUserResponse.error":
		if e.complexity.UpdateEventUserResponse.Error == nil {
			break
		}

		return e.complexity.UpdateEventUserResponse.Error(childComplexity), true

	case "UpdateEventUserResponse.success":
		if e.complexity.UpdateEventUserResponse.Success == nil {
			break
		}

		return e.complexity.UpdateEventUserResponse.Success(childComplexity), true

	case "UpdateItemResponse.error":
		if e.complexity.UpdateItemResponse.Error == nil {
			break
		}

		return e.complexity.UpdateItemResponse.Error(childComplexity), true

	case "UpdateItemResponse.success":
		if e.complexity.UpdateItemResponse.Success == nil {
			break
		}

		return e.complexity.UpdateItemResponse.Success(childComplexity), true

	case "UpdateMatchResponse.error":
		if e.complexity.UpdateMatchResponse.Error == nil {
			break
		}

		return e.complexity.UpdateMatchResponse.Error(childComplexity), true

	case "UpdateMatchResponse.success":
		if e.complexity.UpdateMatchResponse.Success == nil {
			break
		}

		return e.complexity.UpdateMatchResponse.Success(childComplexity), true

	case "UpdateMatchmakingTicketResponse.error":
		if e.complexity.UpdateMatchmakingTicketResponse.Error == nil {
			break
		}

		return e.complexity.UpdateMatchmakingTicketResponse.Error(childComplexity), true

	case "UpdateMatchmakingTicketResponse.success":
		if e.complexity.UpdateMatchmakingTicketResponse.Success == nil {
			break
		}

		return e.complexity.UpdateMatchmakingTicketResponse.Success(childComplexity), true

	case "UpdateMatchmakingUserResponse.error":
		if e.complexity.UpdateMatchmakingUserResponse.Error == nil {
			break
		}

		return e.complexity.UpdateMatchmakingUserResponse.Error(childComplexity), true

	case "UpdateMatchmakingUserResponse.success":
		if e.complexity.UpdateMatchmakingUserResponse.Success == nil {
			break
		}

		return e.complexity.UpdateMatchmakingUserResponse.Success(childComplexity), true

	case "UpdateRecordResponse.error":
		if e.complexity.UpdateRecordResponse.Error == nil {
			break
		}

		return e.complexity.UpdateRecordResponse.Error(childComplexity), true

	case "UpdateRecordResponse.success":
		if e.complexity.UpdateRecordResponse.Success == nil {
			break
		}

		return e.complexity.UpdateRecordResponse.Success(childComplexity), true

	case "UpdateTaskResponse.error":
		if e.complexity.UpdateTaskResponse.Error == nil {
			break
		}

		return e.complexity.UpdateTaskResponse.Error(childComplexity), true

	case "UpdateTaskResponse.success":
		if e.complexity.UpdateTaskResponse.Success == nil {
			break
		}

		return e.complexity.UpdateTaskResponse.Success(childComplexity), true

	case "UpdateTeamMemberResponse.error":
		if e.complexity.UpdateTeamMemberResponse.Error == nil {
			break
		}

		return e.complexity.UpdateTeamMemberResponse.Error(childComplexity), true

	case "UpdateTeamMemberResponse.success":
		if e.complexity.UpdateTeamMemberResponse.Success == nil {
			break
		}

		return e.complexity.UpdateTeamMemberResponse.Success(childComplexity), true

	case "UpdateTeamResponse.error":
		if e.complexity.UpdateTeamResponse.Error == nil {
			break
		}

		return e.complexity.UpdateTeamResponse.Error(childComplexity), true

	case "UpdateTeamResponse.success":
		if e.complexity.UpdateTeamResponse.Success == nil {
			break
		}

		return e.complexity.UpdateTeamResponse.Success(childComplexity), true

	case "UpdateTournamentUserResponse.error":
		if e.complexity.UpdateTournamentUserResponse.Error == nil {
			break
		}

		return e.complexity.UpdateTournamentUserResponse.Error(childComplexity), true

	case "UpdateTournamentUserResponse.success":
		if e.complexity.UpdateTournamentUserResponse.Success == nil {
			break
		}

		return e.complexity.UpdateTournamentUserResponse.Success(childComplexity), true

	case "WebhookResponse.body":
		if e.complexity.WebhookResponse.Body == nil {
			break
		}

		return e.complexity.WebhookResponse.Body(childComplexity), true

	case "WebhookResponse.headers":
		if e.complexity.WebhookResponse.Headers == nil {
			break
		}

		return e.complexity.WebhookResponse.Headers(childComplexity), true

	case "WebhookResponse.status":
		if e.complexity.WebhookResponse.Status == nil {
			break
		}

		return e.complexity.WebhookResponse.Status(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddEventResultRequest,
		ec.unmarshalInputArenaRequest,
		ec.unmarshalInputCreateArenaRequest,
		ec.unmarshalInputCreateEventRequest,
		ec.unmarshalInputCreateEventRound,
		ec.unmarshalInputCreateEventRoundRequest,
		ec.unmarshalInputCreateItemRequest,
		ec.unmarshalInputCreateMatchmakingTicketRequest,
		ec.unmarshalInputCreateMatchmakingUserRequest,
		ec.unmarshalInputCreateRecordRequest,
		ec.unmarshalInputCreateTaskRequest,
		ec.unmarshalInputCreateTeamRequest,
		ec.unmarshalInputCreateTournamentUserRequest,
		ec.unmarshalInputEndMatchRequest,
		ec.unmarshalInputEventRequest,
		ec.unmarshalInputEventRoundRequest,
		ec.unmarshalInputEventRoundUserRequest,
		ec.unmarshalInputEventUserRequest,
		ec.unmarshalInputGetEventRequest,
		ec.unmarshalInputGetEventRoundRequest,
		ec.unmarshalInputGetEventUserRequest,
		ec.unmarshalInputGetItemsRequest,
		ec.unmarshalInputGetMatchRequest,
		ec.unmarshalInputGetMatchesRequest,
		ec.unmarshalInputGetMatchmakingTicketRequest,
		ec.unmarshalInputGetMatchmakingTicketsRequest,
		ec.unmarshalInputGetRecordsRequest,
		ec.unmarshalInputGetTasksRequest,
		ec.unmarshalInputGetTeamRequest,
		ec.unmarshalInputGetTeamsRequest,
		ec.unmarshalInputGetTournamentUsersRequest,
		ec.unmarshalInputItemRequest,
		ec.unmarshalInputJoinTeamRequest,
		ec.unmarshalInputMatchRequest,
		ec.unmarshalInputMatchmakingTicketRequest,
		ec.unmarshalInputMatchmakingUserRequest,
		ec.unmarshalInputNameUserId,
		ec.unmarshalInputPagination,
		ec.unmarshalInputRecordRequest,
		ec.unmarshalInputSearchTeamsRequest,
		ec.unmarshalInputSetMatchPrivateServerRequest,
		ec.unmarshalInputStartMatchRequest,
		ec.unmarshalInputTaskRequest,
		ec.unmarshalInputTeamMemberRequest,
		ec.unmarshalInputTeamRequest,
		ec.unmarshalInputTournamentIntervalUserId,
		ec.unmarshalInputTournamentUserRequest,
		ec.unmarshalInputUpdateArenaRequest,
		ec.unmarshalInputUpdateEventRequest,
		ec.unmarshalInputUpdateEventRoundRequest,
		ec.unmarshalInputUpdateEventUserRequest,
		ec.unmarshalInputUpdateItemRequest,
		ec.unmarshalInputUpdateMatchRequest,
		ec.unmarshalInputUpdateMatchmakingTicketRequest,
		ec.unmarshalInputUpdateMatchmakingUserRequest,
		ec.unmarshalInputUpdateRecordRequest,
		ec.unmarshalInputUpdateTaskRequest,
		ec.unmarshalInputUpdateTeamMemberRequest,
		ec.unmarshalInputUpdateTeamRequest,
		ec.unmarshalInputUpdateTournamentUserRequest,
		ec.unmarshalInputWebhookRequest,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../api/event.graphql", Input: `extend type Query {
	" Get an event by ID or name. Also returns a leaderboard of event users. "
	GetEvent(input: GetEventRequest): GetEventResponse! @doc(category: "Event")
	" Get an event round by ID, or by event object and round name. Also returns leaderboard for the round. If a round name is not provided, the current round is returned."
	GetEventRound(input: GetEventRoundRequest): GetEventRoundResponse! @doc(category: "Event")
	" Get an event user by ID, or by event object and user ID. Also returns the user's results for each round."
	GetEventUser(input: GetEventUserRequest): GetEventUserResponse! @doc(category: "Event")
}

extend type Mutation {
	" Create a new event. "
	CreateEvent(input: CreateEventRequest): CreateEventResponse! @doc(category: "Event")
	" Update an existing event, identified by ID or name. "
	UpdateEvent(input: UpdateEventRequest): UpdateEventResponse! @doc(category: "Event")
	" Delete an event by ID or name. "
	DeleteEvent(input: EventRequest): EventResponse! @doc(category: "Event")
	" Create a new event round by providing an event object and round data. "
	CreateEventRound(input: CreateEventRoundRequest): CreateEventRoundResponse! @doc(category: "Event")
	" Update an existing event round, identified by ID, or event object and round name. "
	UpdateEventRound(input: UpdateEventRoundRequest): UpdateEventRoundResponse! @doc(category: "Event")
	" Update an existing event user, identified by ID, or event object and user ID. "
	UpdateEventUser(input: UpdateEventUserRequest): UpdateEventUserResponse! @doc(category: "Event")
	" Delete an event user by ID, or event object and user ID. "
	DeleteEventUser(input: EventUserRequest): EventUserResponse! @doc(category: "Event")
	" Add a result to the event for a user, identified by ID. The result is added to the current round. "
	AddEventResult(input: AddEventResultRequest): AddEventResultResponse! @doc(category: "Event")
	" Remove a result for a user in an event round, identified by ID, or event user object and round name. If the round name is not provided, the current round is used. "
	RemoveEventResult(input: EventRoundUserRequest): RemoveEventResultResponse! @doc(category: "Event")
}

" Input type for creating an event round. The difference between the endedAt fields of the different rounds signifies the start and end of the round. The scoring field is an array of integers that represent the score for each rank. The first element is the score for the first rank, the second element is the score for the second rank, and so on."
input CreateEventRound @doc(category: "Event") {
	name: String!
	data: Struct!
	endedAt: Timestamp!
	scoring: [Uint64!]!
}

" Input type for creating an event. The rounds field is an array of CreateEventRound objects."
input CreateEventRequest @doc(category: "Event") {
	name: String!
	data: Struct!
	startedAt: Timestamp!
	rounds: [CreateEventRound]!
}

" Response type for creating an event. "
type CreateEventResponse @doc(category: "Event") {
	success: Boolean!
	id: Uint64
	error: CreateEventError!
}

" Possible errors when creating an event. "
enum CreateEventError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	DATA_REQUIRED
	STARTED_AT_REQUIRED
	STARTED_AT_IN_THE_PAST
	ROUNDS_REQUIRED
	TOO_MANY_ROUNDS
	ROUND_NAME_TOO_SHORT
	ROUND_NAME_TOO_LONG
	ROUND_DATA_REQUIRED
	ROUND_ENDED_AT_REQUIRED
	ROUND_ENDED_AT_BEFORE_STARTED_AT
	ROUND_SCORING_REQUIRED
	ALREADY_EXISTS
	DUPLICATE_ROUND_NAME
	DUPLICATE_ROUND_ENDED_AT
}

" The event object is used to identify an event by ID or name. "
input EventRequest @doc(category: "Event") {
	id: Uint64
	name: String
}

" Input type for getting an event. The pagination field is used to paginate the leaderboard."
input GetEventRequest @doc(category: "Event") {
	event: EventRequest!
	pagination: Pagination
}

" Response type for getting an event. "
type GetEventResponse @doc(category: "Event") {
	success: Boolean!
	event: Event
	leaderboard: [EventUser]!
	error: GetEventError!
}

" Possible errors when getting an event. "
enum GetEventError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	NOT_FOUND
}

" Input type for updating an event. "
input UpdateEventRequest @doc(category: "Event") {
	event: EventRequest!
	data: Struct!
}

" Response type for updating an event. "
type UpdateEventResponse @doc(category: "Event") {
	success: Boolean!
	error: UpdateEventError!
}

" Possible errors when updating an event. "
enum UpdateEventError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	DATA_REQUIRED
	NOT_FOUND
}

" Response type for deleting an event. "
type EventResponse @doc(category: "Event") {
	success: Boolean!
	error: EventError!
}

" Possible errors when deleting an event. "
enum EventError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	NOT_FOUND
}

" Input type for creating an event round. "
input CreateEventRoundRequest @doc(category: "Event") {
	event: EventRequest!
	round: CreateEventRound!
}

" Response type for creating an event round. "
type CreateEventRoundResponse @doc(category: "Event") {
	success: Boolean!
	id: Uint64
	error: CreateEventRoundError!
}

" Possible errors when creating an event round. "
enum CreateEventRoundError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	ROUND_REQUIRED
	ROUND_NAME_TOO_SHORT
	ROUND_NAME_TOO_LONG
	ROUND_DATA_REQUIRED
	ROUND_ENDED_AT_REQUIRED
	ROUND_ENDED_AT_IN_THE_PAST
	ROUND_ENDED_AT_BEFORE_EVENT_STARTED_AT
	ROUND_SCORING_REQUIRED
	NOT_FOUND
	DUPLICATE_ROUND_NAME
	DUPLICATE_ROUND_ENDED_AT
}

" Input type for getting an event round. If the round name is not provided, the current round is used. "
input EventRoundRequest @doc(category: "Event") {
	id: Uint64
	event: EventRequest
	roundName: String
}

" Input type for getting an event round. The pagination field is used to paginate the leaderboard."
input GetEventRoundRequest @doc(category: "Event") {
	round: EventRoundRequest!
	pagination: Pagination
}

" Response type for getting an event round. "
type GetEventRoundResponse @doc(category: "Event") {
	success: Boolean!
	round: EventRound
	results: [EventRoundUser]!
	error: GetEventRoundError!
}

" Possible errors when getting an event round. "
enum GetEventRoundError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	EVENT_ROUND_OR_ID_REQUIRED
	NOT_FOUND
}

" Input type for updating an event round. "
input UpdateEventRoundRequest @doc(category: "Event") {
	round: EventRoundRequest!
	data: Struct
	scoring: [Uint64!]
}

" Response type for updating an event round. "
type UpdateEventRoundResponse @doc(category: "Event") {
	success: Boolean!
	error: UpdateEventRoundError!
}

" Possible errors when updating an event round. "
enum UpdateEventRoundError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	EVENT_ROUND_OR_ID_REQUIRED
	NO_UPDATE_SPECIFIED
	NOT_FOUND
}

" Input type for getting an event user. "
input EventUserRequest @doc(category: "Event") {
	id: Uint64
	event: EventRequest
	clientUserId: Uint64
}

" Input type for getting an event user. "
input GetEventUserRequest @doc(category: "Event") {
	user: EventUserRequest!
	pagination: Pagination
}

" Response type for getting an event user. "
type GetEventUserResponse @doc(category: "Event") {
	success: Boolean!
	user: EventUser
	results: [EventRoundUser]!
	error: GetEventUserError!
}

" Possible errors when getting an event user. "
enum GetEventUserError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	CLIENT_USER_ID_REQUIRED
	EVENT_USER_OR_ID_REQUIRED
	NOT_FOUND
}

" Input type for updating an event user. "
input UpdateEventUserRequest @doc(category: "Event") {
	user: EventUserRequest!
	data: Struct!
}

" Response type for updating an event user. "
type UpdateEventUserResponse @doc(category: "Event") {
	success: Boolean!
	error: UpdateEventUserError!
}

" Possible errors when updating an event user. "
enum UpdateEventUserError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	CLIENT_USER_ID_REQUIRED
	EVENT_USER_OR_ID_REQUIRED
	DATA_REQUIRED
	NOT_FOUND
}

" Response type for deleting an event user. "
type EventUserResponse @doc(category: "Event") {
	success: Boolean!
	error: EventUserError!
}

" Possible errors when deleting an event user. "
enum EventUserError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	CLIENT_USER_ID_REQUIRED
	NOT_FOUND
}

" Input type for adding an event result. The result field is the time, score, or other value that the user achieved in the event, ranked from low to high. The userData field is a Struct that can contain any additional data that should be stored with the event user object. The roundUserData field is a Struct that can contain any additional data that should be stored with the user result for the round. If the event user already exists the data field will be updated. If the user already has a result for the round, the result and data fields will be updated. "
input AddEventResultRequest @doc(category: "Event") {
	event: EventRequest!
	clientUserId: Uint64!
	result: Uint64!
	userData: Struct!
	roundUserData: Struct!
}

" Response type for adding an event result. "
type AddEventResultResponse @doc(category: "Event") {
	success: Boolean!
	error: AddEventResultError!
}

" Possible errors when adding an event result. "
enum AddEventResultError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	CLIENT_USER_ID_REQUIRED
	RESULT_REQUIRED
	USER_DATA_REQUIRED
	ROUND_USER_DATA_REQUIRED
	NOT_FOUND
	EVENT_ENDED
}

" Input type for removing an event result. "
input EventRoundUserRequest @doc(category: "Event") {
	id: Uint64!
}

" Response type for removing an event result. "
type RemoveEventResultResponse @doc(category: "Event") {
	success: Boolean!
	error: RemoveEventResultError!
}

" Possible errors when removing an event result. "
enum RemoveEventResultError @doc(category: "Event") {
	NONE
	ID_REQUIRED
	NOT_FOUND
	EVENT_ENDED
}

" Type representing an event. The current round is the round that is currently active, it will be the first round if the event has not started yet, or if all rounds have ended it will be null. "
type Event @doc(category: "Event") {
	id: Uint64!
	name: String!
	currentRoundId: Uint64
	currentRoundName: String
	data: Struct!
	rounds: [EventRound]!
	startedAt: Timestamp!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" Type representing an event round. "
type EventRound @doc(category: "Event") {
	id: Uint64!
	eventId: Uint64!
	name: String!
	scoring: [Uint64!]!
	data: Struct!
	endedAt: Timestamp!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" Type representing an event user. "
type EventUser @doc(category: "Event") {
	id: Uint64!
	eventId: Uint64!
	clientUserId: Uint64!
	score: Uint64!
	ranking: Uint64!
	data: Struct!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" Type representing an event round user. "
type EventRoundUser @doc(category: "Event") {
	id: Uint64!
	eventUserId: Uint64!
	clientUserId: Uint64!
	eventRoundId: Uint64!
	result: Uint64!
	ranking: Uint64!
	data: Struct!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/item.graphql", Input: `extend type Query {
	" Get an item by ID and type. "
	GetItem(input: ItemRequest): GetItemResponse! @doc(category: "Item")
	" Get a list of items based on type and pagination options. "
	GetItems(input: GetItemsRequest): GetItemsResponse! @doc(category: "Item")
}

extend type Mutation {
	" Create a new item with the specified ID, type, data, and optional expiration date. "
	CreateItem(input: CreateItemRequest): CreateItemResponse! @doc(category: "Item")
	" Update an existing item with the specified ID, type, data, and optional expiration date. "
	UpdateItem(input: UpdateItemRequest): UpdateItemResponse! @doc(category: "Item")
	" Delete an item by ID and type. "
	DeleteItem(input: ItemRequest): ItemResponse! @doc(category: "Item")
}

" Input object for creating a new item. An expiration date can be specified, but it is optional. You are free to use any value as an ID, but an ID and Type combination must be unique in the system. "
input CreateItemRequest @doc(category: "Item") {
	id: ID!
	type: String!
	data: Struct!
	expiresAt: Timestamp
}

" Response object for creating an item. "
type CreateItemResponse @doc(category: "Item") {
	success: Boolean!
	error: CreateItemError!
}

" Possible errors when creating an item. "
enum CreateItemError @doc(category: "Item") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	DATA_REQUIRED
	ALREADY_EXISTS
}

" Input object for requesting an item by ID and type. "
input ItemRequest @doc(category: "Item") {
	id: ID!
	type: String!
}

" Response object for getting an item. "
type GetItemResponse @doc(category: "Item") {
	success: Boolean!
	item: Item
	error: GetItemError!
}

" Possible errors when getting an item. "
enum GetItemError @doc(category: "Item") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
}

" Input object for requesting a list of items based on type and pagination options. "
input GetItemsRequest @doc(category: "Item") {
	type: String
	pagination: Pagination
}

" Response object for getting a list of items. "
type GetItemsResponse @doc(category: "Item") {
	success: Boolean!
	items: [Item]!
}

" Response object for item-related operations. "
type ItemResponse @doc(category: "Item") {
	success: Boolean!
	error: ItemError!
}

" Possible errors related to items. "
enum ItemError @doc(category: "Item") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
}

" Input object for updating an item. "
input UpdateItemRequest @doc(category: "Item") {
	item: ItemRequest!
	data: Struct!
}

" Response object for updating an item. "
type UpdateItemResponse @doc(category: "Item") {
	success: Boolean!
	error: UpdateItemError!
}

" Possible errors when updating an item. "
enum UpdateItemError @doc(category: "Item") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
	DATA_REQUIRED
}

" Represents an item. "
type Item @doc(category: "Item") {
	id: ID!
	type: String!
	data: Struct!
	expiresAt: Timestamp
	createdAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/matchmaking.graphql", Input: `extend type Query {
	" Get an arena by ID, or name. "
	GetArena(input: ArenaRequest): GetArenaResponse! @doc(category: "Matchmaking")
	" Get a list of arenas based on name and pagination options. "
	GetArenas(input: Pagination): GetArenasResponse! @doc(category: "Matchmaking")
	" Get a matchmaking user by ID, or client user ID. "
	GetMatchmakingUser(input: MatchmakingUserRequest): GetMatchmakingUserResponse! @doc(category: "Matchmaking")
	" Get a list of matchmaking users based on client user ID and pagination options. "
	GetMatchmakingUsers(input: Pagination): GetMatchmakingUsersResponse! @doc(category: "Matchmaking")
	" Get a matchmaking ticket by ID, or matchmaking user. "
	GetMatchmakingTicket(input: GetMatchmakingTicketRequest): GetMatchmakingTicketResponse! @doc(category: "Matchmaking")
	" Get a list of matchmaking tickets based on match ID, matchmaking user, status, and pagination options. "
	GetMatchmakingTickets(input: GetMatchmakingTicketsRequest): GetMatchmakingTicketsResponse! @doc(category: "Matchmaking")
	" Get a match by ID, or matchmaking ticket. "
	GetMatch(input: GetMatchRequest): GetMatchResponse! @doc(category: "Matchmaking")
	" Get a list of matches based on arena, matchmaking user, status, and pagination options. "
	GetMatches(input: GetMatchesRequest): GetMatchesResponse! @doc(category: "Matchmaking")
}

extend type Mutation {
	" Create a new arena with the specified name, min players, max players per ticket, max players, and data. "
	CreateArena(input: CreateArenaRequest): CreateArenaResponse! @doc(category: "Matchmaking")
	" Update an existing arena with the specified ID, name, min players, max players per ticket, max players, and data. "
	UpdateArena(input: UpdateArenaRequest): UpdateArenaResponse! @doc(category: "Matchmaking")
	" Create a new matchmaking user with the specified client user ID and data. "
	CreateMatchmakingUser(input: CreateMatchmakingUserRequest): CreateMatchmakingUserResponse! @doc(category: "Matchmaking")
	" Update an existing matchmaking user's data with the specified ID and client user ID. "
	UpdateMatchmakingUser(input: UpdateMatchmakingUserRequest): UpdateMatchmakingUserResponse! @doc(category: "Matchmaking")
	" Delete a matchmaking user by ID, or client user ID. If the user is currently in a matchmaking ticket, it cannot be deleted. Instead the ticket will need to be deleted first. "
	DeleteMatchmakingUser(input: MatchmakingUserRequest): DeleteMatchmakingUserResponse! @doc(category: "Matchmaking")
	" Create a new matchmaking ticket with the specified matchmaking users, arenas, and data. "
	CreateMatchmakingTicket(input: CreateMatchmakingTicketRequest): CreateMatchmakingTicketResponse! @doc(category: "Matchmaking")
	" Update an existing matchmaking ticket with the specified ID, or matchmaking user, and data. "
	UpdateMatchmakingTicket(input: UpdateMatchmakingTicketRequest): UpdateMatchmakingTicketResponse! @doc(category: "Matchmaking")
	" Delete a matchmaking ticket by ID, or matchmaking user. This will also delete the users associated with the ticket. If this ticket has been matched to a match, it cannot be deleted. Instead the match will need to be deleted. "
	DeleteMatchmakingTicket(input: MatchmakingTicketRequest): DeleteMatchmakingTicketResponse! @doc(category: "Matchmaking")
	" Start a match by ID, or matchmaking ticket. "
	StartMatch(input: StartMatchRequest): StartMatchResponse! @doc(category: "Matchmaking")
	" End a match by ID, or matchmaking ticket. "
	EndMatch(input: EndMatchRequest): EndMatchResponse! @doc(category: "Matchmaking")
	" Update an existing match with the specified ID, or matchmaking ticket, and data. "
	UpdateMatch(input: UpdateMatchRequest): UpdateMatchResponse! @doc(category: "Matchmaking")
	" Set the private server of the match. Once this is set it cannot be changed, to prevent race conditions from the server. "
	SetMatchPrivateServer(input: SetMatchPrivateServerRequest): SetMatchPrivateServerResponse! @doc(category: "Matchmaking")
	" Delete a match by ID, or matchmaking ticket. This will delete all the tickets and users associated with the match. "
	DeleteMatch(input: MatchRequest): DeleteMatchResponse! @doc(category: "Matchmaking")
}

" Input object for creating a new arena. "
input CreateArenaRequest @doc(category: "Matchmaking") {
	name: String!
	minPlayers: Uint32!
	maxPlayersPerTicket: Uint32!
	maxPlayers: Uint32!
	data: Struct!
}

" Response object for creating an arena. "
type CreateArenaResponse @doc(category: "Matchmaking") {
	success: Boolean!
	id: Uint64
	error: CreateArenaError!
}

" Possible errors when creating an arena. "
enum CreateArenaError @doc(category: "Matchmaking") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	MIN_PLAYERS_REQUIRED
	MAX_PLAYERS_PER_TICKET_REQUIRED
	MAX_PLAYERS_REQUIRED
	MIN_PLAYERS_CANNOT_BE_GREATER_THAN_MAX_PLAYERS
	MAX_PLAYERS_PER_TICKET_CANNOT_BE_GREATER_THAN_MAX_PLAYERS
	DATA_REQUIRED
	ALREADY_EXISTS
}

" Input object for requesting an arena by ID, or name. "
input ArenaRequest @doc(category: "Matchmaking") {
	id: Uint64
	name: String
}

" Response object for getting an arena. "
type GetArenaResponse @doc(category: "Matchmaking") {
	success: Boolean!
	arena: Arena
	error: GetArenaError!
}

" Possible errors when getting an arena. "
enum GetArenaError @doc(category: "Matchmaking") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ARENA_ID_OR_NAME_REQUIRED
	NOT_FOUND
}

" Response object for getting a list of arenas. "
type GetArenasResponse @doc(category: "Matchmaking") {
	success: Boolean!
	arenas: [Arena]
}

" Input object for updating an existing arena. "
input UpdateArenaRequest @doc(category: "Matchmaking") {
	arena: ArenaRequest!
	minPlayers: Uint32
	maxPlayersPerTicket: Uint32
	maxPlayers: Uint32
	data: Struct
}

" Response object for updating an arena. "
type UpdateArenaResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: UpdateArenaError!
}

" Possible errors when updating an arena. "
enum UpdateArenaError @doc(category: "Matchmaking") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ARENA_ID_OR_NAME_REQUIRED
	NO_UPDATE_SPECIFIED
	IF_CAPACITY_CHANGED_MUST_CHANGE_ALL_PLAYERS
	MIN_PLAYERS_CANNOT_BE_GREATER_THAN_MAX_PLAYERS
	MAX_PLAYERS_PER_TICKET_CANNOT_BE_GREATER_THAN_MAX_PLAYERS
	ARENA_CURRENTLY_IN_USE
	NOT_FOUND
}

" Input object for creating a new matchmaking user. The elo that is set is the default elo for the user across all arenas. "
input CreateMatchmakingUserRequest @doc(category: "Matchmaking") {
	clientUserId: Uint64!
	elo: Int64!
	data: Struct!
}

" Response object for creating a matchmaking user. "
type CreateMatchmakingUserResponse @doc(category: "Matchmaking") {
	success: Boolean!
	id: Uint64
	error: CreateMatchmakingUserError!
}

" Possible errors when creating a matchmaking user. "
enum CreateMatchmakingUserError @doc(category: "Matchmaking") {
	NONE
	CLIENT_USER_ID_REQUIRED
	DATA_REQUIRED
	ALREADY_EXISTS
}

" Input object for requesting a matchmaking user by ID, or client user ID. "
input MatchmakingUserRequest @doc(category: "Matchmaking") {
	id: Uint64
	clientUserId: Uint64
}

" Response object for getting a matchmaking user. "
type GetMatchmakingUserResponse @doc(category: "Matchmaking") {
	success: Boolean!
	matchmakingUser: MatchmakingUser
	error: GetMatchmakingUserError!
}

" Possible errors when getting a matchmaking user. "
enum GetMatchmakingUserError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	NOT_FOUND
}

" Response object for getting a list of matchmaking users. "
type GetMatchmakingUsersResponse @doc(category: "Matchmaking") {
	success: Boolean!
	matchmakingUsers: [MatchmakingUser]
}

" Input object for updating an existing matchmaking user. "
input UpdateMatchmakingUserRequest @doc(category: "Matchmaking") {
	matchmakingUser: MatchmakingUserRequest!
	data: Struct
}

" Response object for updating a matchmaking user. "
type UpdateMatchmakingUserResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: UpdateMatchmakingUserError!
}

" Response object for deleting a matchmaking user. "
type DeleteMatchmakingUserResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: DeleteMatchmakingUserError!
}

" Possible errors when deleting a matchmaking user. "
enum DeleteMatchmakingUserError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	NOT_FOUND
	USER_CURRENTLY_IN_TICKET
	USER_CURRENTLY_IN_MATCH
}

" Possible errors when updating a matchmaking user. "
enum UpdateMatchmakingUserError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	DATA_REQUIRED
	NOT_FOUND
}

" Input object for creating a new matchmaking ticket. "
input CreateMatchmakingTicketRequest @doc(category: "Matchmaking") {
	matchmakingUsers: [MatchmakingUserRequest]!
	arenas: [ArenaRequest]!
	data: Struct!
}

" Response object for creating a matchmaking ticket. "
type CreateMatchmakingTicketResponse @doc(category: "Matchmaking") {
	success: Boolean!
	id: Uint64
	error: CreateMatchmakingTicketError!
}

" Possible errors when creating a matchmaking ticket. "
enum CreateMatchmakingTicketError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_USERS_REQUIRED
	ARENAS_REQUIRED
	DATA_REQUIRED
	TOO_MANY_PLAYERS
	USER_NOT_FOUND
	ARENA_NOT_FOUND
	USER_ALREADY_IN_TICKET
}

" Input object for requesting a matchmaking ticket by ID, or matchmaking user. "
input MatchmakingTicketRequest @doc(category: "Matchmaking") {
	id: Uint64
	matchmakingUser: MatchmakingUserRequest
}

" Input object for requesting a matchmaking ticket by ID, or matchmaking user. "
input GetMatchmakingTicketRequest @doc(category: "Matchmaking") {
	matchmakingTicket: MatchmakingTicketRequest!
	userPagination: Pagination
	arenaPagination: Pagination
}

" Response object for getting a matchmaking ticket. "
type GetMatchmakingTicketResponse @doc(category: "Matchmaking") {
	success: Boolean!
	matchmakingTicket: MatchmakingTicket
	error: GetMatchmakingTicketError!
}

" Possible errors when getting a matchmaking ticket. "
enum GetMatchmakingTicketError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	NOT_FOUND
}

" Input object for requesting a list of matchmaking tickets based on match ID, matchmaking user, status, and pagination options. "
input GetMatchmakingTicketsRequest @doc(category: "Matchmaking") {
	matchId: Uint64
	matchmakingUser: MatchmakingUserRequest
	statuses: [MatchmakingTicketStatus]
	pagination: Pagination
	userPagination: Pagination
	arenaPagination: Pagination
}

" Response object for getting a list of matchmaking tickets. "
type GetMatchmakingTicketsResponse @doc(category: "Matchmaking") {
	success: Boolean!
	matchmakingTickets: [MatchmakingTicket]
	error: GetMatchmakingTicketsError!
}

" Possible errors when getting a list of matchmaking tickets. "
enum GetMatchmakingTicketsError @doc(category: "Matchmaking") {
	NONE
	MATCH_NOT_FOUND
	USER_NOT_FOUND
}

" Input object for updating an existing matchmaking ticket. "
input UpdateMatchmakingTicketRequest @doc(category: "Matchmaking") {
	matchmakingTicket: MatchmakingTicketRequest!
	data: Struct!
}

" Response object for updating a matchmaking ticket. "
type UpdateMatchmakingTicketResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: UpdateMatchmakingTicketError!
}

" Possible errors when updating a matchmaking ticket. "
enum UpdateMatchmakingTicketError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	DATA_REQUIRED
	NOT_FOUND
}

" Response object for deleting a matchmaking ticket. "
type DeleteMatchmakingTicketResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: DeleteMatchmakingTicketError!
}

" Possible errors when deleting a matchmaking ticket. "
enum DeleteMatchmakingTicketError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	NOT_FOUND
	TICKET_CURRENTLY_IN_MATCH
}

" Input object for requesting a match by ID, or matchmaking ticket. "
input MatchRequest @doc(category: "Matchmaking") {
	id: Uint64
	matchmakingTicket: MatchmakingTicketRequest
}

" Input object for starting a match. "
input StartMatchRequest @doc(category: "Matchmaking") {
	match: MatchRequest!
	startTime: Timestamp!
}

" Response object for starting a match. "
type StartMatchResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: StartMatchError!
}

" Possible errors when starting a match. "
enum StartMatchError @doc(category: "Matchmaking") {
	NONE
	MATCH_ID_OR_MATCHMAKING_TICKET_REQUIRED
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	START_TIME_REQUIRED
	INVALID_START_TIME
	START_TIME_TOO_SOON
	NOT_FOUND
	NOT_ENOUGH_PLAYERS_TO_START
	ALREADY_HAS_START_TIME
	PRIVATE_SERVER_NOT_SET
}

" Input object for ending a match. "
input EndMatchRequest @doc(category: "Matchmaking") {
	match: MatchRequest!
	endTime: Timestamp!
}

" Response object for ending a match. "
type EndMatchResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: EndMatchError!
}

" Possible errors when ending a match. "
enum EndMatchError @doc(category: "Matchmaking") {
	NONE
	MATCH_ID_OR_MATCHMAKING_TICKET_REQUIRED
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	END_TIME_REQUIRED
	NOT_FOUND
	ALREADY_ENDED
	END_TIME_BEFORE_START_TIME
	START_TIME_NOT_SET
}

" Input object for requesting a match by ID, or matchmaking ticket. And pagination options for tickets and users. "
input GetMatchRequest @doc(category: "Matchmaking") {
	match: MatchRequest!
	ticketPagination: Pagination
	userPagination: Pagination
	arenaPagination: Pagination
}

" Response object for getting a match. "
type GetMatchResponse @doc(category: "Matchmaking") {
	success: Boolean!
	match: Match
	error: GetMatchError!
}

" Possible errors when getting a match. "
enum GetMatchError @doc(category: "Matchmaking") {
	NONE
	MATCH_ID_OR_MATCHMAKING_TICKET_REQUIRED
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	NOT_FOUND
}

" Input object for requesting a list of matches based on arena, matchmaking user, status, and pagination options. "
input GetMatchesRequest @doc(category: "Matchmaking") {
	arena: ArenaRequest
	matchmakingUser: MatchmakingUserRequest
	statuses: [MatchStatus]
	pagination: Pagination
	ticketPagination: Pagination
	userPagination: Pagination
	arenaPagination: Pagination
}

" Response object for getting a list of matches. "
type GetMatchesResponse @doc(category: "Matchmaking") {
	success: Boolean!
	matches: [Match]
}

" Input object for updating an existing match. "
input UpdateMatchRequest @doc(category: "Matchmaking") {
	match: MatchRequest!
	data: Struct!
}

" Response object for updating a match. "
type UpdateMatchResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: UpdateMatchError!
}

" Possible errors when updating a match. "
enum UpdateMatchError @doc(category: "Matchmaking") {
	NONE
	MATCH_ID_OR_MATCHMAKING_TICKET_REQUIRED
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	DATA_REQUIRED
	NOT_FOUND
}

" Input object for setting the private server of the match. "
input SetMatchPrivateServerRequest @doc(category: "Matchmaking") {
	match: MatchRequest!
	privateServerId: String!
}

" Response object for setting the private server of the match. If we receive a 'NONE' error or a 'PRIVATE_SERVER_ALREADY_SET' error, then a private server ID will be returned. "
type SetMatchPrivateServerResponse @doc(category: "Matchmaking") {
	success: Boolean!
	privateServerId: String
	error: SetMatchPrivateServerError!
}

" Possible errors when setting the private server of the match. "
enum SetMatchPrivateServerError @doc(category: "Matchmaking") {
	NONE
	MATCH_ID_OR_MATCHMAKING_TICKET_REQUIRED
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	PRIVATE_SERVER_ID_REQUIRED
	PRIVATE_SERVER_ALREADY_SET
	NOT_FOUND
}

" Response object for deleting a match. "
type DeleteMatchResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: DeleteMatchError!
}

" Possible errors when deleting a match. "
enum DeleteMatchError @doc(category: "Matchmaking") {
	NONE
	MATCH_ID_OR_MATCHMAKING_TICKET_REQUIRED
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	NOT_FOUND
}

" An arena. "
type Arena @doc(category: "Matchmaking") {
	id: Uint64!
	name: String!
	minPlayers: Uint32!
	maxPlayersPerTicket: Uint32!
	maxPlayers: Uint32!
	data: Struct!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" A matchmaking user. Users are not long lived, they are created at the same time as a matchmaking ticket usually, but can be deleted as long as they are not yet part of a ticket. After that the only way to delete a user is to delete the ticket they are in. "
type MatchmakingUser @doc(category: "Matchmaking") {
	id: Uint64!
	clientUserId: Uint64!
	data: Struct!
	elo: Int64!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" Possible statuses for a matchmaking ticket. Pending means it's waiting to be matched. Matched means it's matched with other tickets, the match may have started or may not have. Ended means the match has ended. "
enum MatchmakingTicketStatus @doc(category: "Matchmaking") {
	PENDING
	MATCHED
	ENDED
}

" A matchmaking ticket. This is where users are grouped together into parties, and then matched with other tickets. These tickets will exist until they are deleted prior to being matched with a match, or the match is deleted. "
type MatchmakingTicket @doc(category: "Matchmaking") {
	id: Uint64!
	matchmakingUsers: [MatchmakingUser]!
	arenas: [Arena]!
	matchId: Uint64
	status: MatchmakingTicketStatus!
	data: Struct!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" Possible statuses for a match. Pending means it's waiting to be started. Started means it's currently being played. Ended means the match has ended. "
enum MatchStatus @doc(category: "Matchmaking") {
	PENDING
	STARTED
	ENDED
}

" A match. This is where tickets are matched together and played. "
type Match @doc(category: "Matchmaking") {
	id: Uint64!
	arena: Arena!
	tickets: [MatchmakingTicket]!
	privateServerId: String
	status: MatchStatus!
	data: Struct!
	lockedAt: Timestamp
	startedAt: Timestamp
	endedAt: Timestamp
	createdAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/record.graphql", Input: `extend type Query {
	" Get a record by ID, or name and user ID. "
	GetRecord(input: RecordRequest): GetRecordResponse! @doc(category: "Record")
	" Get a list of records based on name, user ID, and pagination options. "
	GetRecords(input: GetRecordsRequest): GetRecordsResponse! @doc(category: "Record")
}

extend type Mutation {
	" Create a new record with the specified name, user ID, record, and data. "
	CreateRecord(input: CreateRecordRequest): CreateRecordResponse! @doc(category: "Record")
	" Update an existing record with the specified ID, name and user ID, record, and data. "
	UpdateRecord(input: UpdateRecordRequest): UpdateRecordResponse! @doc(category: "Record")
	" Delete a record by ID, or name and user ID. "
	DeleteRecord(input: RecordRequest): DeleteRecordResponse! @doc(category: "Record")
}

" Input object for creating a new record. "
input CreateRecordRequest @doc(category: "Record") {
	name: String!
	userId: Uint64!
	record: Uint64!
	data: Struct!
}

" Response object for creating a record. "
type CreateRecordResponse @doc(category: "Record") {
	success: Boolean!
	id: Uint64
	error: CreateRecordError!
}

" Possible errors when creating a record. "
enum CreateRecordError @doc(category: "Record") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	USER_ID_REQUIRED
	RECORD_REQUIRED
	DATA_REQUIRED
	RECORD_EXISTS
}

" Input object for requesting a record by name and user ID. "
input NameUserId @doc(category: "Record") {
	name: String!
	userId: Uint64!
}

" Input object for requesting a record by ID, or name and user ID. "
input RecordRequest @doc(category: "Record") {
	id: Uint64
	nameUserId: NameUserId
}

" Response object for getting a record. "
type GetRecordResponse @doc(category: "Record") {
	success: Boolean!
	record: Record
	error: GetRecordError!
}

" Possible errors when getting a record. "
enum GetRecordError @doc(category: "Record") {
	NONE
	ID_OR_NAME_USER_ID_REQUIRED
	NOT_FOUND
	NAME_TOO_SHORT
	NAME_TOO_LONG
	USER_ID_REQUIRED
}

" Input object for requesting a list of records based on name, user ID, and pagination options. "
input GetRecordsRequest @doc(category: "Record") {
	name: String
	userId: Uint64
	pagination: Pagination
}

" Response object for getting a list of records. "
type GetRecordsResponse @doc(category: "Record") {
	success: Boolean!
	records: [Record]!
	error: GetRecordsError!
}

" Possible errors when getting a list of records. "
enum GetRecordsError @doc(category: "Record") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
}

" Input object for updating an existing record. "
input UpdateRecordRequest @doc(category: "Record") {
	request: RecordRequest!
	record: Uint64
	data: Struct
}

" Response object for updating a record. "
type UpdateRecordResponse @doc(category: "Record") {
	success: Boolean!
	error: UpdateRecordError!
}

" Possible errors when updating a record. "
enum UpdateRecordError @doc(category: "Record") {
	NONE
	ID_OR_NAME_USER_ID_REQUIRED
	NOT_FOUND
	NAME_TOO_SHORT
	NAME_TOO_LONG
	USER_ID_REQUIRED
	NO_UPDATE_SPECIFIED
}

" Response object for deleting a record. "
type DeleteRecordResponse @doc(category: "Record") {
	success: Boolean!
	error: DeleteRecordError!
}

" Possible errors when deleting a record. "
enum DeleteRecordError @doc(category: "Record") {
	NONE
	ID_OR_NAME_USER_ID_REQUIRED
	NOT_FOUND
	NAME_TOO_SHORT
	NAME_TOO_LONG
	USER_ID_REQUIRED
}

" The record object, ranked by record lowest to highest for each record name. "
type Record @doc(category: "Record") {
	id: Uint64!
	name: String!
	userId: Uint64!
	record: Uint64!
	ranking: Uint64!
	data: Struct!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/task.graphql", Input: `extend type Query {
	" Get an task by ID and type. "
	GetTask(input: TaskRequest): GetTaskResponse! @doc(category: "Task")
	" Get a list of tasks based on type and pagination options. "
	GetTasks(input: GetTasksRequest): GetTasksResponse! @doc(category: "Task")
}

extend type Mutation {
	" Create a new task with the specified ID, type, data, and optional expiration date. "
	CreateTask(input: CreateTaskRequest): CreateTaskResponse! @doc(category: "Task")
	" Update an existing task with the specified ID, type, data, and optional expiration date. "
	UpdateTask(input: UpdateTaskRequest): UpdateTaskResponse! @doc(category: "Task")
	" Complete an task by ID and type. "
	CompleteTask(input: TaskRequest): CompleteTaskResponse! @doc(category: "Task")
	" Delete an task by ID and type. "
	DeleteTask(input: TaskRequest): TaskResponse! @doc(category: "Task")
}

" Input object for creating a new task. An expiration date can be specified, but it is optional. You are free to use any value as an ID, but an ID and Type combination must be unique in the system. "
input CreateTaskRequest @doc(category: "Task") {
	id: ID!
	type: String!
	data: Struct!
	expiresAt: Timestamp
}

" Response object for creating an task. "
type CreateTaskResponse @doc(category: "Task") {
	success: Boolean!
	error: CreateTaskError!
}

" Possible errors when creating an task. "
enum CreateTaskError @doc(category: "Task") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	DATA_REQUIRED
	ALREADY_EXISTS
}

" Input object for requesting an task by ID and type. "
input TaskRequest @doc(category: "Task") {
	id: ID!
	type: String!
}

" Response object for getting an task. "
type GetTaskResponse @doc(category: "Task") {
	success: Boolean!
	task: Task
	error: GetTaskError!
}

" Possible errors when getting an task. "
enum GetTaskError @doc(category: "Task") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
}

" Input object for requesting a list of tasks based on type and pagination options. Can also filter by completion status. "
input GetTasksRequest @doc(category: "Task") {
	type: String
	completed: Boolean
	pagination: Pagination
}

" Response object for getting a list of tasks. "
type GetTasksResponse @doc(category: "Task") {
	success: Boolean!
	tasks: [Task]!
}

" Response object for task-related operations. "
type TaskResponse @doc(category: "Task") {
	success: Boolean!
	error: TaskError!
}

" Possible errors related to tasks. "
enum TaskError @doc(category: "Task") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
}

" Input object for updating an task. "
input UpdateTaskRequest @doc(category: "Task") {
	task: TaskRequest!
	data: Struct!
}

" Response object for updating an task. "
type UpdateTaskResponse @doc(category: "Task") {
	success: Boolean!
	error: UpdateTaskError!
}

" Response object for completing a task. "
type CompleteTaskResponse @doc(category: "Task") {
	success: Boolean!
	error: CompleteTaskError!
}

" Possible errors when completing an task. "
enum CompleteTaskError @doc(category: "Task") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
	ALREADY_COMPLETED
}

" Possible errors when updating an task. "
enum UpdateTaskError @doc(category: "Task") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
	DATA_REQUIRED
}

" Represents an task. "
type Task @doc(category: "Task") {
	id: ID!
	type: String!
	data: Struct!
	expiresAt: Timestamp
	completedAt: Timestamp
	createdAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/team.graphql", Input: `extend type Query {
	" Get a team by id, name, or member. "
	GetTeam(input: GetTeamRequest): GetTeamResponse! @doc(category: "Team")
	" Get a list of teams based on pagination options. "
	GetTeams(input: GetTeamsRequest): GetTeamsResponse! @doc(category: "Team")
	" Get a team member by id or user ID. "
	GetTeamMember(input: TeamMemberRequest): GetTeamMemberResponse! @doc(category: "Team")
	" Search for teams based on a query string. "
	SearchTeams(input: SearchTeamsRequest): SearchTeamsResponse! @doc(category: "Team")
}

extend type Mutation {
	" Create a new team with the specified name, firstMemberId, score, data, and first member data. "
	CreateTeam(input: CreateTeamRequest): CreateTeamResponse! @doc(category: "Team")
	" Update an existing team's data and/or score. "
	UpdateTeam(input: UpdateTeamRequest): UpdateTeamResponse! @doc(category: "Team")
	" Delete a team by id, name, or member. "
	DeleteTeam(input: TeamRequest): TeamResponse! @doc(category: "Team")
	" Join a team with the specified team, user id, and data. "
	JoinTeam(input: JoinTeamRequest): JoinTeamResponse! @doc(category: "Team")
	" Leave a team by id or user id. "
	LeaveTeam(input: TeamMemberRequest): LeaveTeamResponse! @doc(category: "Team")
	" Update a team member's data. "
	UpdateTeamMember(input: UpdateTeamMemberRequest): UpdateTeamMemberResponse! @doc(category: "Team")
}

" Input object for creating a new team. "
input CreateTeamRequest @doc(category: "Team") {
	name: String!
	score: Int64
	firstMemberUserId: Uint64!
	data: Struct!
	firstMemberData: Struct!
}

" Response object for creating a team. "
type CreateTeamResponse @doc(category: "Team") {
	success: Boolean!
	id: Uint64
	error: CreateTeamError!
}

" Possible errors when creating a team. "
enum CreateTeamError @doc(category: "Team") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	FIRST_MEMBER_USER_ID_REQUIRED
	DATA_REQUIRED
	FIRST_MEMBER_DATA_REQUIRED
	NAME_TAKEN
	FIRST_MEMBER_ALREADY_IN_A_TEAM
}

" Input object for requesting a team by id, name or member. "
input TeamRequest @doc(category: "Team") {
	id: Uint64
	name: String
	member: TeamMemberRequest
}

" Input object for getting a team with pagination options for the team members. "
input GetTeamRequest @doc(category: "Team") {
	team: TeamRequest!
	pagination: Pagination
}

" Response object for team-related operations. "
type GetTeamResponse @doc(category: "Team") {
	success: Boolean!
	team: Team
	error: GetTeamError!
}

" Possible errors when getting a team. "
enum GetTeamError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	NAME_TOO_SHORT
	NAME_TOO_LONG
	NOT_FOUND
}

" Input object for getting a list of teams and their members. "
input GetTeamsRequest @doc(category: "Team") {
	pagination: Pagination
	memberPagination: Pagination
}

" Response object for getting a list of teams and their members. "
type GetTeamsResponse @doc(category: "Team") {
	success: Boolean!
	teams: [Team]!
}

" Input object for requesting a team member by id or user id. "
input TeamMemberRequest @doc(category: "Team") {
	id: Uint64
	userId: Uint64
}

" Response object for getting a team member. "
type GetTeamMemberResponse @doc(category: "Team") {
	success: Boolean!
	member: TeamMember
	error: GetTeamMemberError!
}

" Possible errors when getting a team member. "
enum GetTeamMemberError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	NOT_FOUND
}

" Input object for searching for teams based on a query string. "
input SearchTeamsRequest @doc(category: "Team") {
	query: String!
	pagination: Pagination
	memberPagination: Pagination
}

" Response object for searching for teams. "
type SearchTeamsResponse @doc(category: "Team") {
	success: Boolean!
	teams: [Team]!
	error: SearchTeamsError!
}

" Possible errors when searching for teams. "
enum SearchTeamsError @doc(category: "Team") {
	NONE
	QUERY_TOO_SHORT
	QUERY_TOO_LONG
}

" Input object for deleting a team. "
input UpdateTeamRequest @doc(category: "Team") {
	team: TeamRequest!
	data: Struct
	score: Int64
	incrementScore: Boolean
}

" Response object for updating a team. "
type UpdateTeamResponse @doc(category: "Team") {
	success: Boolean!
	error: UpdateTeamError!
}

" Possible errors when updating a team. "
enum UpdateTeamError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	NAME_TOO_SHORT
	NAME_TOO_LONG
	NO_UPDATE_SPECIFIED
	INCREMENT_SCORE_NOT_SPECIFIED
	NOT_FOUND
}

" Response object for a team-related operation. "
type TeamResponse @doc(category: "Team") {
	success: Boolean!
	error: TeamError!
}

" Possible errors when deleting a team. "
enum TeamError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	NAME_TOO_SHORT
	NAME_TOO_LONG
	NOT_FOUND
}

" Input object for deleting a team. "
input JoinTeamRequest @doc(category: "Team") {
	team: TeamRequest!
	userId: Uint64!
	data: Struct!
}

" Response object for joining a team. "
type JoinTeamResponse @doc(category: "Team") {
	success: Boolean!
	error: JoinTeamError!
}

" Possible errors when joining a team. "
enum JoinTeamError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	NAME_TOO_SHORT
	NAME_TOO_LONG
	USER_ID_REQUIRED
	DATA_REQUIRED
	NOT_FOUND
	TEAM_FULL
	ALREADY_IN_A_TEAM
}

" Response object for leaving a team. "
type LeaveTeamResponse @doc(category: "Team") {
	success: Boolean!
	error: LeaveTeamError!
}

" Possible errors when leaving a team. "
enum LeaveTeamError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	NOT_FOUND
}

" Input object for updating a team member. "
input UpdateTeamMemberRequest @doc(category: "Team") {
	member: TeamMemberRequest!
	data: Struct!
}

" Response object for updating a team member. "
type UpdateTeamMemberResponse @doc(category: "Team") {
	success: Boolean!
	error: UpdateTeamMemberError!
}

" Possible errors when updating a team member. "
enum UpdateTeamMemberError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	DATA_REQUIRED
	NOT_FOUND
}

" A team in the system. The ranking is based on the score highest to lowest. "
type Team @doc(category: "Team") {
	id: Uint64!
	name: String!
	score: Int64!
	ranking: Uint64!
	members: [TeamMember]!
	data: Struct!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" A member of a team. "
type TeamMember @doc(category: "Team") {
	id: Uint64!
	userId: Uint64!
	teamId: Uint64!
	data: Struct!
	joinedAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/tournament.graphql", Input: `extend type Query {
	" Get a tournament user by ID, or tournament, interval, and user ID. "
	GetTournamentUser(input: TournamentUserRequest): GetTournamentUserResponse! @doc(category: "Tournament")
	" Get a list of tournament users based on tournament, interval, and user ID. "
	GetTournamentUsers(input: GetTournamentUsersRequest): GetTournamentUsersResponse! @doc(category: "Tournament")
}

extend type Mutation {
	" Create a new tournament user with the specified tournament, interval, user ID, score, and data. "
	CreateTournamentUser(input: CreateTournamentUserRequest): CreateTournamentUserResponse! @doc(category: "Tournament")
	" Update an existing tournament user with the specified tournament, interval, user ID, score, data, and increment score. "
	UpdateTournamentUser(input: UpdateTournamentUserRequest): UpdateTournamentUserResponse! @doc(category: "Tournament")
	" Delete a tournament user by ID, or tournament, interval, and user ID. "
	DeleteTournamentUser(input: TournamentUserRequest): TournamentUserResponse! @doc(category: "Tournament")
}

" Input object for creating a new tournament user. "
input CreateTournamentUserRequest @doc(category: "Tournament") {
	tournament: String!
	interval: TournamentInterval!
	userId: Uint64!
	score: Int64
	data: Struct!
}

" Response object for creating a tournament user. "
type CreateTournamentUserResponse @doc(category: "Tournament") {
	success: Boolean!
	id: Uint64
	error: CreateTournamentUserError!
}

" Possible errors when creating a tournament user. "
enum CreateTournamentUserError @doc(category: "Tournament") {
	NONE
	TOURNAMENT_NAME_TOO_SHORT
	TOURNAMENT_NAME_TOO_LONG
	USER_ID_REQUIRED
	DATA_REQUIRED
	ALREADY_EXISTS
}

" Different intervals for tournaments. The tournament interval is used to determine how often a tournament is reset."
enum TournamentInterval @doc(category: "Tournament") {
	DAILY
	WEEKLY
	MONTHLY
	UNLIMITED
}

" Input object for requesting a tournament user by tournament, interval, and user ID. "
input TournamentIntervalUserId @doc(category: "Tournament") {
	tournament: String!
	interval: TournamentInterval!
	userId: Uint64!
}

" Input object for requesting a tournament user by ID, or tournament, interval, and user ID. "
input TournamentUserRequest @doc(category: "Tournament") {
	id: Uint64
	tournamentIntervalUserId: TournamentIntervalUserId
}

" Response object for getting a tournament user. "
type GetTournamentUserResponse @doc(category: "Tournament") {
	success: Boolean!
	tournamentUser: TournamentUser
	error: GetTournamentUserError!
}

" Possible errors when getting a tournament user. "
enum GetTournamentUserError @doc(category: "Tournament") {
	NONE
	ID_OR_TOURNAMENT_INTERVAL_USER_ID_REQUIRED
	TOURNAMENT_NAME_TOO_SHORT
	TOURNAMENT_NAME_TOO_LONG
	USER_ID_REQUIRED
	NOT_FOUND
}

" Response object for requesting a tournament user without returning object. "
type TournamentUserResponse @doc(category: "Tournament") {
	success: Boolean!
	error: TournamentUserError!
}

" Possible errors when requesting a tournament user without returning object. "
enum TournamentUserError @doc(category: "Tournament") {
	NONE
	ID_OR_TOURNAMENT_INTERVAL_USER_ID_REQUIRED
	TOURNAMENT_NAME_TOO_SHORT
	TOURNAMENT_NAME_TOO_LONG
	USER_ID_REQUIRED
	NOT_FOUND
}

" Input object for requesting a list of tournament users based on tournament, interval, and user ID. "
input GetTournamentUsersRequest @doc(category: "Tournament") {
	tournament: String
	interval: TournamentInterval!
	userId: Uint64
	pagination: Pagination
}

" Response object for getting a list of tournament users. "
type GetTournamentUsersResponse @doc(category: "Tournament") {
	success: Boolean!
	tournamentUsers: [TournamentUser]!
	error: GetTournamentUsersError!
}

" Possible errors when getting a list of tournament users. "
enum GetTournamentUsersError @doc(category: "Tournament") {
	NONE
	TOURNAMENT_NAME_TOO_SHORT
	TOURNAMENT_NAME_TOO_LONG
}

" Input object for updating a tournament user. Increment score flag is used to determine if the score should be incremented by the specified score. "
input UpdateTournamentUserRequest @doc(category: "Tournament") {
	tournament: TournamentUserRequest!
	data: Struct
	score: Int64
	incrementScore: Boolean
}

" Response object for updating a tournament user. "
type UpdateTournamentUserResponse @doc(category: "Tournament") {
	success: Boolean!
	error: UpdateTournamentUserError!
}

" Possible errors when updating a tournament user. "
enum UpdateTournamentUserError @doc(category: "Tournament") {
	NONE
	ID_OR_TOURNAMENT_INTERVAL_USER_ID_REQUIRED
	TOURNAMENT_NAME_TOO_SHORT
	TOURNAMENT_NAME_TOO_LONG
	USER_ID_REQUIRED
	NOT_FOUND
	NO_UPDATE_SPECIFIED
	INCREMENT_SCORE_NOT_SPECIFIED
}

" Type representing a tournament user. Tournaments are created by creating a the first tournament user with a specific tournament, interval, and user ID. "
type TournamentUser @doc(category: "Tournament") {
	id: Uint64!
	tournament: String!
	userId: Uint64!
	interval: TournamentInterval!
	score: Int64!
	ranking: Uint64!
	data: Struct!
	tournamentStartedAt: Timestamp!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/types.graphql", Input: `" A directive to categorize sections of the API documentation. "
directive @doc(category: String) on FIELD_DEFINITION | OBJECT | INPUT_OBJECT | ENUM | SCALAR

" A directive to add examples to fields, arguments, input fields, and enum values. "
directive @example(value: String) on OBJECT | INPUT_OBJECT | INTERFACE | FIELD_DEFINITION | ARGUMENT_DEFINITION | SCALAR

" A struct type defines a JSON object. "
scalar Struct @doc(category: "Common")

" A 32-bit unsigned integer. "
scalar Uint32 @doc(category: "Common")

" A 64-bit unsigned integer. "
scalar Uint64 @doc(category: "Common")

" A 64-bit signed integer. "
scalar Int64 @doc(category: "Common")

" A string representing a timestamp in RFC3339 (nano) format. "
scalar Timestamp @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339") @doc(category: "Common") @example(value: "2023-10-01T12:00:00Z")

" The root query type. "
type Query

" The root mutation type."
type Mutation

" Input object for pagination. The max field is the maximum number of items to return, and the page field is the page number to return. "
input Pagination @doc(category: "Common") {
	max: Uint32
	page: Uint64
}
`, BuiltIn: false},
	{Name: "../../api/webhook.graphql", Input: `extend type Mutation {
	" Send a webhook using the api as a proxy. "
	Webhook(input: WebhookRequest): WebhookResponse! @doc(category: "Webhook")
}

" Input object for sending a webhook. "
input WebhookRequest @doc(category: "Webhook") {
	uri: String!
	method: String!
	headers: Struct!
	body: Struct!
}

" Response object for sending a webhook. "
type WebhookResponse @doc(category: "Webhook") {
	status: Uint32!
	headers: Struct!
	body: Struct!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_doc_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_doc_argsCategory(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["category"] = arg0
	return args, nil
}
func (ec *executionContext) dir_doc_argsCategory(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["category"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
	if tmp, ok := rawArgs["category"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) dir_example_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_example_argsValue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["value"] = arg0
	return args, nil
}
func (ec *executionContext) dir_example_argsValue(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["value"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
	if tmp, ok := rawArgs["value"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_AddEventResult_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_AddEventResult_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_AddEventResult_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.AddEventResultRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.AddEventResultRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOAddEventResultRequest2githubcomMorhafAlshiblycoandaapiAddEventResultRequest(ctx, tmp)
	}

	var zeroVal *api.AddEventResultRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CompleteTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CompleteTask_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CompleteTask_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TaskRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TaskRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTaskRequest2githubcomMorhafAlshiblycoandaapiTaskRequest(ctx, tmp)
	}

	var zeroVal *api.TaskRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateArena_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateArena_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateArena_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateArenaRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateArenaRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateArenaRequest2githubcomMorhafAlshiblycoandaapiCreateArenaRequest(ctx, tmp)
	}

	var zeroVal *api.CreateArenaRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateEventRound_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateEventRound_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateEventRound_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateEventRoundRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateEventRoundRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateEventRoundRequest2githubcomMorhafAlshiblycoandaapiCreateEventRoundRequest(ctx, tmp)
	}

	var zeroVal *api.CreateEventRoundRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateEvent_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateEvent_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateEventRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateEventRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateEventRequest2githubcomMorhafAlshiblycoandaapiCreateEventRequest(ctx, tmp)
	}

	var zeroVal *api.CreateEventRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateItem_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateItem_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateItem_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateItemRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateItemRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateItemRequest2githubcomMorhafAlshiblycoandaapiCreateItemRequest(ctx, tmp)
	}

	var zeroVal *api.CreateItemRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateMatchmakingTicket_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateMatchmakingTicket_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateMatchmakingTicket_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateMatchmakingTicketRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateMatchmakingTicketRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateMatchmakingTicketRequest2githubcomMorhafAlshiblycoandaapiCreateMatchmakingTicketRequest(ctx, tmp)
	}

	var zeroVal *api.CreateMatchmakingTicketRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateMatchmakingUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateMatchmakingUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateMatchmakingUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateMatchmakingUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateMatchmakingUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiCreateMatchmakingUserRequest(ctx, tmp)
	}

	var zeroVal *api.CreateMatchmakingUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateRecord_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateRecord_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateRecord_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateRecordRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateRecordRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateRecordRequest2githubcomMorhafAlshiblycoandaapiCreateRecordRequest(ctx, tmp)
	}

	var zeroVal *api.CreateRecordRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateTask_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateTask_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateTaskRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateTaskRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateTaskRequest2githubcomMorhafAlshiblycoandaapiCreateTaskRequest(ctx, tmp)
	}

	var zeroVal *api.CreateTaskRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateTeamRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateTeamRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateTeamRequest2githubcomMorhafAlshiblycoandaapiCreateTeamRequest(ctx, tmp)
	}

	var zeroVal *api.CreateTeamRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateTournamentUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateTournamentUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateTournamentUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateTournamentUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateTournamentUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateTournamentUserRequest2githubcomMorhafAlshiblycoandaapiCreateTournamentUserRequest(ctx, tmp)
	}

	var zeroVal *api.CreateTournamentUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteEventUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteEventUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteEventUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.EventUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.EventUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOEventUserRequest2githubcomMorhafAlshiblycoandaapiEventUserRequest(ctx, tmp)
	}

	var zeroVal *api.EventUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteEvent_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteEvent_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.EventRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.EventRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOEventRequest2githubcomMorhafAlshiblycoandaapiEventRequest(ctx, tmp)
	}

	var zeroVal *api.EventRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteItem_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteItem_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteItem_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.ItemRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.ItemRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOItemRequest2githubcomMorhafAlshiblycoandaapiItemRequest(ctx, tmp)
	}

	var zeroVal *api.ItemRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteMatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteMatch_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteMatch_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.MatchRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.MatchRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOMatchRequest2githubcomMorhafAlshiblycoandaapiMatchRequest(ctx, tmp)
	}

	var zeroVal *api.MatchRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteMatchmakingTicket_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteMatchmakingTicket_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteMatchmakingTicket_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.MatchmakingTicketRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.MatchmakingTicketRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOMatchmakingTicketRequest2githubcomMorhafAlshiblycoandaapiMatchmakingTicketRequest(ctx, tmp)
	}

	var zeroVal *api.MatchmakingTicketRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteMatchmakingUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteMatchmakingUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteMatchmakingUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.MatchmakingUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.MatchmakingUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiMatchmakingUserRequest(ctx, tmp)
	}

	var zeroVal *api.MatchmakingUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteRecord_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteRecord_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteRecord_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.RecordRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.RecordRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalORecordRequest2githubcomMorhafAlshiblycoandaapiRecordRequest(ctx, tmp)
	}

	var zeroVal *api.RecordRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteTask_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteTask_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TaskRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TaskRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTaskRequest2githubcomMorhafAlshiblycoandaapiTaskRequest(ctx, tmp)
	}

	var zeroVal *api.TaskRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TeamRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TeamRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTeamRequest2githubcomMorhafAlshiblycoandaapiTeamRequest(ctx, tmp)
	}

	var zeroVal *api.TeamRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteTournamentUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteTournamentUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteTournamentUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TournamentUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TournamentUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTournamentUserRequest2githubcomMorhafAlshiblycoandaapiTournamentUserRequest(ctx, tmp)
	}

	var zeroVal *api.TournamentUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_EndMatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_EndMatch_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_EndMatch_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.EndMatchRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.EndMatchRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOEndMatchRequest2githubcomMorhafAlshiblycoandaapiEndMatchRequest(ctx, tmp)
	}

	var zeroVal *api.EndMatchRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_JoinTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_JoinTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_JoinTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.JoinTeamRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.JoinTeamRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOJoinTeamRequest2githubcomMorhafAlshiblycoandaapiJoinTeamRequest(ctx, tmp)
	}

	var zeroVal *api.JoinTeamRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_LeaveTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_LeaveTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_LeaveTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TeamMemberRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TeamMemberRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTeamMemberRequest2githubcomMorhafAlshiblycoandaapiTeamMemberRequest(ctx, tmp)
	}

	var zeroVal *api.TeamMemberRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_RemoveEventResult_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_RemoveEventResult_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_RemoveEventResult_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.EventRoundUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.EventRoundUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOEventRoundUserRequest2githubcomMorhafAlshiblycoandaapiEventRoundUserRequest(ctx, tmp)
	}

	var zeroVal *api.EventRoundUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_SetMatchPrivateServer_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_SetMatchPrivateServer_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_SetMatchPrivateServer_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.SetMatchPrivateServerRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.SetMatchPrivateServerRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOSetMatchPrivateServerRequest2githubcomMorhafAlshiblycoandaapiSetMatchPrivateServerRequest(ctx, tmp)
	}

	var zeroVal *api.SetMatchPrivateServerRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_StartMatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_StartMatch_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_StartMatch_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.StartMatchRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.StartMatchRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOStartMatchRequest2githubcomMorhafAlshiblycoandaapiStartMatchRequest(ctx, tmp)
	}

	var zeroVal *api.StartMatchRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateArena_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateArena_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateArena_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateArenaRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateArenaRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateArenaRequest2githubcomMorhafAlshiblycoandaapiUpdateArenaRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateArenaRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateEventRound_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateEventRound_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateEventRound_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateEventRoundRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateEventRoundRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateEventRoundRequest2githubcomMorhafAlshiblycoandaapiUpdateEventRoundRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateEventRoundRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateEventUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateEventUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateEventUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateEventUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateEventUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateEventUserRequest2githubcomMorhafAlshiblycoandaapiUpdateEventUserRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateEventUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateEvent_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateEvent_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateEventRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateEventRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateEventRequest2githubcomMorhafAlshiblycoandaapiUpdateEventRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateEventRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateItem_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateItem_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateItem_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateItemRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateItemRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateItemRequest2githubcomMorhafAlshiblycoandaapiUpdateItemRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateItemRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateMatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateMatch_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateMatch_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateMatchRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateMatchRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateMatchRequest2githubcomMorhafAlshiblycoandaapiUpdateMatchRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateMatchRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateMatchmakingTicket_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateMatchmakingTicket_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateMatchmakingTicket_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateMatchmakingTicketRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateMatchmakingTicketRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateMatchmakingTicketRequest2githubcomMorhafAlshiblycoandaapiUpdateMatchmakingTicketRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateMatchmakingTicketRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateMatchmakingUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateMatchmakingUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateMatchmakingUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateMatchmakingUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateMatchmakingUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiUpdateMatchmakingUserRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateMatchmakingUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateRecord_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateRecord_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateRecord_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateRecordRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateRecordRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateRecordRequest2githubcomMorhafAlshiblycoandaapiUpdateRecordRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateRecordRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateTask_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateTask_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateTaskRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateTaskRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateTaskRequest2githubcomMorhafAlshiblycoandaapiUpdateTaskRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateTaskRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateTeamMember_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateTeamMember_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateTeamMember_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateTeamMemberRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateTeamMemberRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateTeamMemberRequest2githubcomMorhafAlshiblycoandaapiUpdateTeamMemberRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateTeamMemberRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateTeamRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateTeamRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateTeamRequest2githubcomMorhafAlshiblycoandaapiUpdateTeamRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateTeamRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateTournamentUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateTournamentUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateTournamentUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateTournamentUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateTournamentUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateTournamentUserRequest2githubcomMorhafAlshiblycoandaapiUpdateTournamentUserRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateTournamentUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_Webhook_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_Webhook_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_Webhook_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.WebhookRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.WebhookRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOWebhookRequest2githubcomMorhafAlshiblycoandaapiWebhookRequest(ctx, tmp)
	}

	var zeroVal *api.WebhookRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetArena_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetArena_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetArena_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.ArenaRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.ArenaRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOArenaRequest2githubcomMorhafAlshiblycoandaapiArenaRequest(ctx, tmp)
	}

	var zeroVal *api.ArenaRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetArenas_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetArenas_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetArenas_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.Pagination, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.Pagination
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, tmp)
	}

	var zeroVal *api.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetEventRound_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetEventRound_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetEventRound_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetEventRoundRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetEventRoundRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetEventRoundRequest2githubcomMorhafAlshiblycoandaapiGetEventRoundRequest(ctx, tmp)
	}

	var zeroVal *api.GetEventRoundRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetEventUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetEventUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetEventUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetEventUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetEventUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetEventUserRequest2githubcomMorhafAlshiblycoandaapiGetEventUserRequest(ctx, tmp)
	}

	var zeroVal *api.GetEventUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetEvent_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetEvent_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetEventRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetEventRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetEventRequest2githubcomMorhafAlshiblycoandaapiGetEventRequest(ctx, tmp)
	}

	var zeroVal *api.GetEventRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetItem_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetItem_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetItem_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.ItemRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.ItemRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOItemRequest2githubcomMorhafAlshiblycoandaapiItemRequest(ctx, tmp)
	}

	var zeroVal *api.ItemRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetItems_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetItems_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetItems_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetItemsRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetItemsRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetItemsRequest2githubcomMorhafAlshiblycoandaapiGetItemsRequest(ctx, tmp)
	}

	var zeroVal *api.GetItemsRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetMatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetMatch_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetMatch_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetMatchRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetMatchRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetMatchRequest2githubcomMorhafAlshiblycoandaapiGetMatchRequest(ctx, tmp)
	}

	var zeroVal *api.GetMatchRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetMatches_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetMatches_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetMatches_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetMatchesRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetMatchesRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetMatchesRequest2githubcomMorhafAlshiblycoandaapiGetMatchesRequest(ctx, tmp)
	}

	var zeroVal *api.GetMatchesRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetMatchmakingTicket_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetMatchmakingTicket_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetMatchmakingTicket_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetMatchmakingTicketRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetMatchmakingTicketRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetMatchmakingTicketRequest2githubcomMorhafAlshiblycoandaapiGetMatchmakingTicketRequest(ctx, tmp)
	}

	var zeroVal *api.GetMatchmakingTicketRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetMatchmakingTickets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetMatchmakingTickets_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetMatchmakingTickets_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetMatchmakingTicketsRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetMatchmakingTicketsRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetMatchmakingTicketsRequest2githubcomMorhafAlshiblycoandaapiGetMatchmakingTicketsRequest(ctx, tmp)
	}

	var zeroVal *api.GetMatchmakingTicketsRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetMatchmakingUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetMatchmakingUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetMatchmakingUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.MatchmakingUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.MatchmakingUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiMatchmakingUserRequest(ctx, tmp)
	}

	var zeroVal *api.MatchmakingUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetMatchmakingUsers_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetMatchmakingUsers_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetMatchmakingUsers_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.Pagination, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.Pagination
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, tmp)
	}

	var zeroVal *api.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetRecord_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetRecord_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetRecord_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.RecordRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.RecordRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalORecordRequest2githubcomMorhafAlshiblycoandaapiRecordRequest(ctx, tmp)
	}

	var zeroVal *api.RecordRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetRecords_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetRecords_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetRecords_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetRecordsRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetRecordsRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetRecordsRequest2githubcomMorhafAlshiblycoandaapiGetRecordsRequest(ctx, tmp)
	}

	var zeroVal *api.GetRecordsRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTask_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTask_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TaskRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TaskRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTaskRequest2githubcomMorhafAlshiblycoandaapiTaskRequest(ctx, tmp)
	}

	var zeroVal *api.TaskRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTasks_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTasks_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetTasksRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetTasksRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetTasksRequest2githubcomMorhafAlshiblycoandaapiGetTasksRequest(ctx, tmp)
	}

	var zeroVal *api.GetTasksRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTeamMember_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTeamMember_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTeamMember_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TeamMemberRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TeamMemberRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTeamMemberRequest2githubcomMorhafAlshiblycoandaapiTeamMemberRequest(ctx, tmp)
	}

	var zeroVal *api.TeamMemberRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetTeamRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetTeamRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetTeamRequest2githubcomMorhafAlshiblycoandaapiGetTeamRequest(ctx, tmp)
	}

	var zeroVal *api.GetTeamRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTeams_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTeams_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTeams_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetTeamsRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetTeamsRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetTeamsRequest2githubcomMorhafAlshiblycoandaapiGetTeamsRequest(ctx, tmp)
	}

	var zeroVal *api.GetTeamsRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTournamentUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTournamentUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTournamentUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TournamentUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TournamentUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTournamentUserRequest2githubcomMorhafAlshiblycoandaapiTournamentUserRequest(ctx, tmp)
	}

	var zeroVal *api.TournamentUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTournamentUsers_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTournamentUsers_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTournamentUsers_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetTournamentUsersRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetTournamentUsersRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetTournamentUsersRequest2githubcomMorhafAlshiblycoandaapiGetTournamentUsersRequest(ctx, tmp)
	}

	var zeroVal *api.GetTournamentUsersRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_SearchTeams_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_SearchTeams_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_SearchTeams_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.SearchTeamsRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.SearchTeamsRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOSearchTeamsRequest2githubcomMorhafAlshiblycoandaapiSearchTeamsRequest(ctx, tmp)
	}

	var zeroVal *api.SearchTeamsRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AddEventResultResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.AddEventResultResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddEventResultResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddEventResultResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddEventResultResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddEventResultResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.AddEventResultResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddEventResultResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.AddEventResultResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.AddEventResultError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.AddEventResultError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.AddEventResultError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.AddEventResultError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.AddEventResultError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.AddEventResultError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AddEventResultError)
	fc.Result = res
	return ec.marshalNAddEventResultError2githubcomMorhafAlshiblycoandainternalbffmodelAddEventResultError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddEventResultResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddEventResultResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AddEventResultError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_id(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_name(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_minPlayers(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_minPlayers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MinPlayers, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint32); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_minPlayers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_maxPlayersPerTicket(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_maxPlayersPerTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MaxPlayersPerTicket, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint32); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_maxPlayersPerTicket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_maxPlayers(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_maxPlayers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MaxPlayers, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint32); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_maxPlayers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_data(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompleteTaskResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CompleteTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompleteTaskResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompleteTaskResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompleteTaskResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompleteTaskResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CompleteTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompleteTaskResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CompleteTaskResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal model.CompleteTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CompleteTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal model.CompleteTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CompleteTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CompleteTaskError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CompleteTaskError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CompleteTaskError)
	fc.Result = res
	return ec.marshalNCompleteTaskError2githubcomMorhafAlshiblycoandainternalbffmodelCompleteTaskError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompleteTaskResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompleteTaskResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CompleteTaskError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateArenaResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateArenaResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateArenaResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateArenaResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateArenaResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateArenaResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateArenaResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateArenaResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateArenaResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateArenaResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateArenaResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.CreateArenaError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateArenaError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.CreateArenaError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateArenaError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateArenaError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateArenaError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateArenaError)
	fc.Result = res
	return ec.marshalNCreateArenaError2githubcomMorhafAlshiblycoandainternalbffmodelCreateArenaError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateArenaResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateArenaResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateArenaError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateEventResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateEventResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateEventResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateEventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateEventResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateEventResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateEventResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateEventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateEventResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateEventResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateEventResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.CreateEventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateEventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.CreateEventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateEventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateEventError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateEventError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateEventError)
	fc.Result = res
	return ec.marshalNCreateEventError2githubcomMorhafAlshiblycoandainternalbffmodelCreateEventError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateEventResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateEventResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateEventError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateEventRoundResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateEventRoundResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateEventRoundResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateEventRoundResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateEventRoundResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateEventRoundResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateEventRoundResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateEventRoundResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateEventRoundResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateEventRoundResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateEventRoundResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.CreateEventRoundError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateEventRoundError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.CreateEventRoundError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateEventRoundError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateEventRoundError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateEventRoundError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateEventRoundError)
	fc.Result = res
	return ec.marshalNCreateEventRoundError2githubcomMorhafAlshiblycoandainternalbffmodelCreateEventRoundError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateEventRoundResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateEventRoundResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateEventRoundError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateItemResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateItemResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateItemResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateItemResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateItemResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateItemResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateItemResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal model.CreateItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal model.CreateItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateItemError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateItemError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateItemError)
	fc.Result = res
	return ec.marshalNCreateItemError2githubcomMorhafAlshiblycoandainternalbffmodelCreateItemError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateItemResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateItemResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateItemError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMatchmakingTicketResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMatchmakingTicketResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMatchmakingTicketResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMatchmakingTicketResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMatchmakingTicketResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMatchmakingTicketResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMatchmakingTicketResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMatchmakingTicketResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateMatchmakingTicketResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.CreateMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.CreateMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateMatchmakingTicketError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateMatchmakingTicketError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateMatchmakingTicketError)
	fc.Result = res
	return ec.marshalNCreateMatchmakingTicketError2githubcomMorhafAlshiblycoandainternalbffmodelCreateMatchmakingTicketError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMatchmakingTicketResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateMatchmakingTicketError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMatchmakingUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMatchmakingUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMatchmakingUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMatchmakingUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMatchmakingUserResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMatchmakingUserResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMatchmakingUserResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMatchmakingUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMatchmakingUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMatchmakingUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateMatchmakingUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.CreateMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.CreateMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateMatchmakingUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateMatchmakingUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateMatchmakingUserError)
	fc.Result = res
	return ec.marshalNCreateMatchmakingUserError2githubcomMorhafAlshiblycoandainternalbffmodelCreateMatchmakingUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMatchmakingUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMatchmakingUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateMatchmakingUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateRecordResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateRecordResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateRecordResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateRecordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateRecordResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateRecordResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateRecordResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateRecordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateRecordResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateRecordResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateRecordResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal model.CreateRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal model.CreateRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateRecordError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateRecordError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateRecordError)
	fc.Result = res
	return ec.marshalNCreateRecordError2githubcomMorhafAlshiblycoandainternalbffmodelCreateRecordError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateRecordResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateRecordResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateRecordError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTaskResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTaskResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTaskResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTaskResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTaskResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTaskResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateTaskResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal model.CreateTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal model.CreateTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateTaskError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateTaskError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateTaskError)
	fc.Result = res
	return ec.marshalNCreateTaskError2githubcomMorhafAlshiblycoandainternalbffmodelCreateTaskError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTaskResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTaskResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateTaskError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTeamResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTeamResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTeamResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTeamResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTeamResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTeamResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTeamResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTeamResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateTeamResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.CreateTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.CreateTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateTeamError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateTeamError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateTeamError)
	fc.Result = res
	return ec.marshalNCreateTeamError2githubcomMorhafAlshiblycoandainternalbffmodelCreateTeamError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTeamResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTeamResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateTeamError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTournamentUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTournamentUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTournamentUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTournamentUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTournamentUserResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTournamentUserResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTournamentUserResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTournamentUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTournamentUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTournamentUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateTournamentUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal model.CreateTournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateTournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal model.CreateTournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateTournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateTournamentUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateTournamentUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateTournamentUserError)
	fc.Result = res
	return ec.marshalNCreateTournamentUserError2githubcomMorhafAlshiblycoandainternalbffmodelCreateTournamentUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTournamentUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTournamentUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateTournamentUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteMatchResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.DeleteMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteMatchResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteMatchResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteMatchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteMatchResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.DeleteMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteMatchResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.DeleteMatchResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.DeleteMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.DeleteMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DeleteMatchError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.DeleteMatchError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DeleteMatchError)
	fc.Result = res
	return ec.marshalNDeleteMatchError2githubcomMorhafAlshiblycoandainternalbffmodelDeleteMatchError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteMatchResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteMatchResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeleteMatchError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteMatchmakingTicketResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.DeleteMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteMatchmakingTicketResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteMatchmakingTicketResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteMatchmakingTicketResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.DeleteMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteMatchmakingTicketResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.DeleteMatchmakingTicketResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.DeleteMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.DeleteMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DeleteMatchmakingTicketError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.DeleteMatchmakingTicketError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DeleteMatchmakingTicketError)
	fc.Result = res
	return ec.marshalNDeleteMatchmakingTicketError2githubcomMorhafAlshiblycoandainternalbffmodelDeleteMatchmakingTicketError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteMatchmakingTicketResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeleteMatchmakingTicketError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteMatchmakingUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.DeleteMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteMatchmakingUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteMatchmakingUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteMatchmakingUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteMatchmakingUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.DeleteMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteMatchmakingUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.DeleteMatchmakingUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.DeleteMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.DeleteMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DeleteMatchmakingUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.DeleteMatchmakingUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DeleteMatchmakingUserError)
	fc.Result = res
	return ec.marshalNDeleteMatchmakingUserError2githubcomMorhafAlshiblycoandainternalbffmodelDeleteMatchmakingUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteMatchmakingUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteMatchmakingUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeleteMatchmakingUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteRecordResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.DeleteRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteRecordResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteRecordResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteRecordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteRecordResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.DeleteRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteRecordResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.DeleteRecordResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal model.DeleteRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal model.DeleteRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DeleteRecordError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.DeleteRecordError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DeleteRecordError)
	fc.Result = res
	return ec.marshalNDeleteRecordError2githubcomMorhafAlshiblycoandainternalbffmodelDeleteRecordError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteRecordResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteRecordResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeleteRecordError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EndMatchResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.EndMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EndMatchResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EndMatchResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EndMatchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EndMatchResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.EndMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EndMatchResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.EndMatchResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.EndMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.EndMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.EndMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.EndMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.EndMatchError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.EndMatchError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EndMatchError)
	fc.Result = res
	return ec.marshalNEndMatchError2githubcomMorhafAlshiblycoandainternalbffmodelEndMatchError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EndMatchResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EndMatchResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EndMatchError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_id(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_name(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_currentRoundId(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_currentRoundId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CurrentRoundId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_currentRoundId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_currentRoundName(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_currentRoundName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CurrentRoundName, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_currentRoundName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_data(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_rounds(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_rounds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Rounds, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventRound
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventRound
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventRound
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventRound
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.EventRound); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.EventRound`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.EventRound)
	fc.Result = res
	return ec.marshalNEventRound2githubcomMorhafAlshiblycoandaapiEventRound(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_rounds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventRound_id(ctx, field)
			case "eventId":
				return ec.fieldContext_EventRound_eventId(ctx, field)
			case "name":
				return ec.fieldContext_EventRound_name(ctx, field)
			case "scoring":
				return ec.fieldContext_EventRound_scoring(ctx, field)
			case "data":
				return ec.fieldContext_EventRound_data(ctx, field)
			case "endedAt":
				return ec.fieldContext_EventRound_endedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventRound_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventRound_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventRound", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_startedAt(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.StartedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_startedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.EventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.EventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.EventResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.EventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.EventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.EventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.EventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.EventError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.EventError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventError)
	fc.Result = res
	return ec.marshalNEventError2githubcomMorhafAlshiblycoandainternalbffmodelEventError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_id(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_eventId(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_eventId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.EventId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_eventId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_name(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_scoring(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_scoring(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Scoring, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal []uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal []uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_scoring(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_data(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_endedAt(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_endedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.EndedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_endedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_id(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_eventUserId(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_eventUserId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.EventUserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_eventUserId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_clientUserId(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_clientUserId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ClientUserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_clientUserId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_eventRoundId(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_eventRoundId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.EventRoundId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_eventRoundId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_result(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_result(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Result, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_result(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_ranking(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_ranking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Ranking, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_ranking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_data(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_id(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_eventId(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_eventId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.EventId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_eventId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_clientUserId(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_clientUserId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ClientUserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_clientUserId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_score(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_score(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Score, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_score(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_ranking(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_ranking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Ranking, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_ranking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_data(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.EventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.EventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.EventUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.EventUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.EventUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.EventUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.EventUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.EventUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.EventUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventUserError)
	fc.Result = res
	return ec.marshalNEventUserError2githubcomMorhafAlshiblycoandainternalbffmodelEventUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetArenaResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetArenaResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetArenaResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetArenaResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetArenaResponse_arena(ctx context.Context, field graphql.CollectedField, obj *api.GetArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetArenaResponse_arena(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Arena, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Arena); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Arena`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Arena)
	fc.Result = res
	return ec.marshalOArena2githubcomMorhafAlshiblycoandaapiArena(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetArenaResponse_arena(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetArenaResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Arena_id(ctx, field)
			case "name":
				return ec.fieldContext_Arena_name(ctx, field)
			case "minPlayers":
				return ec.fieldContext_Arena_minPlayers(ctx, field)
			case "maxPlayersPerTicket":
				return ec.fieldContext_Arena_maxPlayersPerTicket(ctx, field)
			case "maxPlayers":
				return ec.fieldContext_Arena_maxPlayers(ctx, field)
			case "data":
				return ec.fieldContext_Arena_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Arena_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Arena_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Arena", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetArenaResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetArenaResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetArenaResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetArenaError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetArenaError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetArenaError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetArenaError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetArenaError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetArenaError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetArenaError)
	fc.Result = res
	return ec.marshalNGetArenaError2githubcomMorhafAlshiblycoandainternalbffmodelGetArenaError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetArenaResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetArenaResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetArenaError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetArenasResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetArenasResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetArenasResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetArenasResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetArenasResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetArenasResponse_arenas(ctx context.Context, field graphql.CollectedField, obj *api.GetArenasResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetArenasResponse_arenas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Arenas, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Arena); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Arena`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*api.Arena)
	fc.Result = res
	return ec.marshalOArena2githubcomMorhafAlshiblycoandaapiArena(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetArenasResponse_arenas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetArenasResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Arena_id(ctx, field)
			case "name":
				return ec.fieldContext_Arena_name(ctx, field)
			case "minPlayers":
				return ec.fieldContext_Arena_minPlayers(ctx, field)
			case "maxPlayersPerTicket":
				return ec.fieldContext_Arena_maxPlayersPerTicket(ctx, field)
			case "maxPlayers":
				return ec.fieldContext_Arena_maxPlayers(ctx, field)
			case "data":
				return ec.fieldContext_Arena_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Arena_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Arena_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Arena", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventResponse_event(ctx context.Context, field graphql.CollectedField, obj *api.GetEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventResponse_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Event, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.Event
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Event
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.Event
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Event
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Event); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Event`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Event)
	fc.Result = res
	return ec.marshalOEvent2githubcomMorhafAlshiblycoandaapiEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventResponse_event(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "currentRoundId":
				return ec.fieldContext_Event_currentRoundId(ctx, field)
			case "currentRoundName":
				return ec.fieldContext_Event_currentRoundName(ctx, field)
			case "data":
				return ec.fieldContext_Event_data(ctx, field)
			case "rounds":
				return ec.fieldContext_Event_rounds(ctx, field)
			case "startedAt":
				return ec.fieldContext_Event_startedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventResponse_leaderboard(ctx context.Context, field graphql.CollectedField, obj *api.GetEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventResponse_leaderboard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Leaderboard, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.EventUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.EventUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.EventUser)
	fc.Result = res
	return ec.marshalNEventUser2githubcomMorhafAlshiblycoandaapiEventUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventResponse_leaderboard(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventUser_id(ctx, field)
			case "eventId":
				return ec.fieldContext_EventUser_eventId(ctx, field)
			case "clientUserId":
				return ec.fieldContext_EventUser_clientUserId(ctx, field)
			case "score":
				return ec.fieldContext_EventUser_score(ctx, field)
			case "ranking":
				return ec.fieldContext_EventUser_ranking(ctx, field)
			case "data":
				return ec.fieldContext_EventUser_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetEventResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.GetEventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetEventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.GetEventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetEventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetEventError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetEventError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetEventError)
	fc.Result = res
	return ec.marshalNGetEventError2githubcomMorhafAlshiblycoandainternalbffmodelGetEventError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetEventError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventRoundResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventRoundResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventRoundResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventRoundResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventRoundResponse_round(ctx context.Context, field graphql.CollectedField, obj *api.GetEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventRoundResponse_round(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Round, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventRound
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventRound
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventRound
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventRound
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.EventRound); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRound`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.EventRound)
	fc.Result = res
	return ec.marshalOEventRound2githubcomMorhafAlshiblycoandaapiEventRound(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventRoundResponse_round(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventRoundResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventRound_id(ctx, field)
			case "eventId":
				return ec.fieldContext_EventRound_eventId(ctx, field)
			case "name":
				return ec.fieldContext_EventRound_name(ctx, field)
			case "scoring":
				return ec.fieldContext_EventRound_scoring(ctx, field)
			case "data":
				return ec.fieldContext_EventRound_data(ctx, field)
			case "endedAt":
				return ec.fieldContext_EventRound_endedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventRound_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventRound_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventRound", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventRoundResponse_results(ctx context.Context, field graphql.CollectedField, obj *api.GetEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventRoundResponse_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Results, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.EventRoundUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.EventRoundUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.EventRoundUser)
	fc.Result = res
	return ec.marshalNEventRoundUser2githubcomMorhafAlshiblycoandaapiEventRoundUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventRoundResponse_results(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventRoundResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventRoundUser_id(ctx, field)
			case "eventUserId":
				return ec.fieldContext_EventRoundUser_eventUserId(ctx, field)
			case "clientUserId":
				return ec.fieldContext_EventRoundUser_clientUserId(ctx, field)
			case "eventRoundId":
				return ec.fieldContext_EventRoundUser_eventRoundId(ctx, field)
			case "result":
				return ec.fieldContext_EventRoundUser_result(ctx, field)
			case "ranking":
				return ec.fieldContext_EventRoundUser_ranking(ctx, field)
			case "data":
				return ec.fieldContext_EventRoundUser_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventRoundUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventRoundUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventRoundUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventRoundResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventRoundResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetEventRoundResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.GetEventRoundError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetEventRoundError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.GetEventRoundError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetEventRoundError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetEventRoundError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetEventRoundError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetEventRoundError)
	fc.Result = res
	return ec.marshalNGetEventRoundError2githubcomMorhafAlshiblycoandainternalbffmodelGetEventRoundError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventRoundResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventRoundResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetEventRoundError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetEventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventUserResponse_user(ctx context.Context, field graphql.CollectedField, obj *api.GetEventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventUserResponse_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.User, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.EventUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.EventUser)
	fc.Result = res
	return ec.marshalOEventUser2githubcomMorhafAlshiblycoandaapiEventUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventUserResponse_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventUser_id(ctx, field)
			case "eventId":
				return ec.fieldContext_EventUser_eventId(ctx, field)
			case "clientUserId":
				return ec.fieldContext_EventUser_clientUserId(ctx, field)
			case "score":
				return ec.fieldContext_EventUser_score(ctx, field)
			case "ranking":
				return ec.fieldContext_EventUser_ranking(ctx, field)
			case "data":
				return ec.fieldContext_EventUser_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventUserResponse_results(ctx context.Context, field graphql.CollectedField, obj *api.GetEventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventUserResponse_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Results, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.EventRoundUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.EventRoundUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.EventRoundUser)
	fc.Result = res
	return ec.marshalNEventRoundUser2githubcomMorhafAlshiblycoandaapiEventRoundUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventUserResponse_results(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventRoundUser_id(ctx, field)
			case "eventUserId":
				return ec.fieldContext_EventRoundUser_eventUserId(ctx, field)
			case "clientUserId":
				return ec.fieldContext_EventRoundUser_clientUserId(ctx, field)
			case "eventRoundId":
				return ec.fieldContext_EventRoundUser_eventRoundId(ctx, field)
			case "result":
				return ec.fieldContext_EventRoundUser_result(ctx, field)
			case "ranking":
				return ec.fieldContext_EventRoundUser_ranking(ctx, field)
			case "data":
				return ec.fieldContext_EventRoundUser_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventRoundUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventRoundUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventRoundUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetEventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetEventUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.GetEventUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetEventUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.GetEventUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetEventUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetEventUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetEventUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetEventUserError)
	fc.Result = res
	return ec.marshalNGetEventUserError2githubcomMorhafAlshiblycoandainternalbffmodelGetEventUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetEventUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetItemResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetItemResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetItemResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetItemResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetItemResponse_item(ctx context.Context, field graphql.CollectedField, obj *api.GetItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetItemResponse_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Item, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *api.Item
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Item
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *api.Item
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Item
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Item); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Item`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Item)
	fc.Result = res
	return ec.marshalOItem2githubcomMorhafAlshiblycoandaapiItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetItemResponse_item(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetItemResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "data":
				return ec.fieldContext_Item_data(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Item_expiresAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetItemResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetItemResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetItemResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal model.GetItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal model.GetItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetItemError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetItemError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetItemError)
	fc.Result = res
	return ec.marshalNGetItemError2githubcomMorhafAlshiblycoandainternalbffmodelGetItemError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetItemResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetItemResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetItemError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetItemsResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetItemsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetItemsResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetItemsResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetItemsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetItemsResponse_items(ctx context.Context, field graphql.CollectedField, obj *api.GetItemsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetItemsResponse_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Items, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal []*api.Item
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Item
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal []*api.Item
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Item
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Item); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Item`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.Item)
	fc.Result = res
	return ec.marshalNItem2githubcomMorhafAlshiblycoandaapiItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetItemsResponse_items(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetItemsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "data":
				return ec.fieldContext_Item_data(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Item_expiresAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchResponse_match(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchResponse_match(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Match, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.Match
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Match
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.Match
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Match
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Match); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Match`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Match)
	fc.Result = res
	return ec.marshalOMatch2githubcomMorhafAlshiblycoandaapiMatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchResponse_match(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Match_id(ctx, field)
			case "arena":
				return ec.fieldContext_Match_arena(ctx, field)
			case "tickets":
				return ec.fieldContext_Match_tickets(ctx, field)
			case "privateServerId":
				return ec.fieldContext_Match_privateServerId(ctx, field)
			case "status":
				return ec.fieldContext_Match_status(ctx, field)
			case "data":
				return ec.fieldContext_Match_data(ctx, field)
			case "lockedAt":
				return ec.fieldContext_Match_lockedAt(ctx, field)
			case "startedAt":
				return ec.fieldContext_Match_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Match_endedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Match_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Match_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Match", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetMatchResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetMatchError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetMatchError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetMatchError)
	fc.Result = res
	return ec.marshalNGetMatchError2githubcomMorhafAlshiblycoandainternalbffmodelGetMatchError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetMatchError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchesResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchesResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchesResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchesResponse_matches(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchesResponse_matches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Matches, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.Match
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Match
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.Match
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Match
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Match); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Match`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*api.Match)
	fc.Result = res
	return ec.marshalOMatch2githubcomMorhafAlshiblycoandaapiMatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchesResponse_matches(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Match_id(ctx, field)
			case "arena":
				return ec.fieldContext_Match_arena(ctx, field)
			case "tickets":
				return ec.fieldContext_Match_tickets(ctx, field)
			case "privateServerId":
				return ec.fieldContext_Match_privateServerId(ctx, field)
			case "status":
				return ec.fieldContext_Match_status(ctx, field)
			case "data":
				return ec.fieldContext_Match_data(ctx, field)
			case "lockedAt":
				return ec.fieldContext_Match_lockedAt(ctx, field)
			case "startedAt":
				return ec.fieldContext_Match_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Match_endedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Match_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Match_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Match", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingTicketResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingTicketResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingTicketResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingTicketResponse_matchmakingTicket(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingTicketResponse_matchmakingTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchmakingTicket, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.MatchmakingTicket
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.MatchmakingTicket
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.MatchmakingTicket
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.MatchmakingTicket
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.MatchmakingTicket); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingTicket`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.MatchmakingTicket)
	fc.Result = res
	return ec.marshalOMatchmakingTicket2githubcomMorhafAlshiblycoandaapiMatchmakingTicket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingTicketResponse_matchmakingTicket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchmakingTicket_id(ctx, field)
			case "matchmakingUsers":
				return ec.fieldContext_MatchmakingTicket_matchmakingUsers(ctx, field)
			case "arenas":
				return ec.fieldContext_MatchmakingTicket_arenas(ctx, field)
			case "matchId":
				return ec.fieldContext_MatchmakingTicket_matchId(ctx, field)
			case "status":
				return ec.fieldContext_MatchmakingTicket_status(ctx, field)
			case "data":
				return ec.fieldContext_MatchmakingTicket_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchmakingTicket_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchmakingTicket_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchmakingTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingTicketResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingTicketResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetMatchmakingTicketResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetMatchmakingTicketError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetMatchmakingTicketError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetMatchmakingTicketError)
	fc.Result = res
	return ec.marshalNGetMatchmakingTicketError2githubcomMorhafAlshiblycoandainternalbffmodelGetMatchmakingTicketError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingTicketResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetMatchmakingTicketError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingTicketsResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingTicketsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingTicketsResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingTicketsResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingTicketsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingTicketsResponse_matchmakingTickets(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingTicketsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingTicketsResponse_matchmakingTickets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchmakingTickets, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.MatchmakingTicket); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.MatchmakingTicket`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*api.MatchmakingTicket)
	fc.Result = res
	return ec.marshalOMatchmakingTicket2githubcomMorhafAlshiblycoandaapiMatchmakingTicket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingTicketsResponse_matchmakingTickets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingTicketsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchmakingTicket_id(ctx, field)
			case "matchmakingUsers":
				return ec.fieldContext_MatchmakingTicket_matchmakingUsers(ctx, field)
			case "arenas":
				return ec.fieldContext_MatchmakingTicket_arenas(ctx, field)
			case "matchId":
				return ec.fieldContext_MatchmakingTicket_matchId(ctx, field)
			case "status":
				return ec.fieldContext_MatchmakingTicket_status(ctx, field)
			case "data":
				return ec.fieldContext_MatchmakingTicket_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchmakingTicket_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchmakingTicket_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchmakingTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingTicketsResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingTicketsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingTicketsResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetMatchmakingTicketsResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchmakingTicketsError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchmakingTicketsError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchmakingTicketsError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchmakingTicketsError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetMatchmakingTicketsError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetMatchmakingTicketsError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetMatchmakingTicketsError)
	fc.Result = res
	return ec.marshalNGetMatchmakingTicketsError2githubcomMorhafAlshiblycoandainternalbffmodelGetMatchmakingTicketsError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingTicketsResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingTicketsResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetMatchmakingTicketsError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingUserResponse_matchmakingUser(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingUserResponse_matchmakingUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchmakingUser, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.MatchmakingUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.MatchmakingUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.MatchmakingUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.MatchmakingUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.MatchmakingUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.MatchmakingUser)
	fc.Result = res
	return ec.marshalOMatchmakingUser2githubcomMorhafAlshiblycoandaapiMatchmakingUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingUserResponse_matchmakingUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchmakingUser_id(ctx, field)
			case "clientUserId":
				return ec.fieldContext_MatchmakingUser_clientUserId(ctx, field)
			case "data":
				return ec.fieldContext_MatchmakingUser_data(ctx, field)
			case "elo":
				return ec.fieldContext_MatchmakingUser_elo(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchmakingUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchmakingUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchmakingUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetMatchmakingUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetMatchmakingUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetMatchmakingUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetMatchmakingUserError)
	fc.Result = res
	return ec.marshalNGetMatchmakingUserError2githubcomMorhafAlshiblycoandainternalbffmodelGetMatchmakingUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetMatchmakingUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingUsersResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingUsersResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingUsersResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingUsersResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingUsersResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingUsersResponse_matchmakingUsers(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingUsersResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingUsersResponse_matchmakingUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchmakingUsers, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.MatchmakingUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.MatchmakingUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*api.MatchmakingUser)
	fc.Result = res
	return ec.marshalOMatchmakingUser2githubcomMorhafAlshiblycoandaapiMatchmakingUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingUsersResponse_matchmakingUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingUsersResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchmakingUser_id(ctx, field)
			case "clientUserId":
				return ec.fieldContext_MatchmakingUser_clientUserId(ctx, field)
			case "data":
				return ec.fieldContext_MatchmakingUser_data(ctx, field)
			case "elo":
				return ec.fieldContext_MatchmakingUser_elo(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchmakingUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchmakingUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchmakingUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetRecordResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetRecordResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetRecordResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetRecordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetRecordResponse_record(ctx context.Context, field graphql.CollectedField, obj *api.GetRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetRecordResponse_record(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Record, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *api.Record
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Record
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *api.Record
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Record
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Record); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Record`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Record)
	fc.Result = res
	return ec.marshalORecord2githubcomMorhafAlshiblycoandaapiRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetRecordResponse_record(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetRecordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Record_id(ctx, field)
			case "name":
				return ec.fieldContext_Record_name(ctx, field)
			case "userId":
				return ec.fieldContext_Record_userId(ctx, field)
			case "record":
				return ec.fieldContext_Record_record(ctx, field)
			case "ranking":
				return ec.fieldContext_Record_ranking(ctx, field)
			case "data":
				return ec.fieldContext_Record_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Record_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Record_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Record", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetRecordResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetRecordResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetRecordResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal model.GetRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal model.GetRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetRecordError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetRecordError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetRecordError)
	fc.Result = res
	return ec.marshalNGetRecordError2githubcomMorhafAlshiblycoandainternalbffmodelGetRecordError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetRecordResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetRecordResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetRecordError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetRecordsResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetRecordsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetRecordsResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetRecordsResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetRecordsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetRecordsResponse_records(ctx context.Context, field graphql.CollectedField, obj *api.GetRecordsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetRecordsResponse_records(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Records, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal []*api.Record
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Record
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal []*api.Record
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Record
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Record); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Record`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.Record)
	fc.Result = res
	return ec.marshalNRecord2githubcomMorhafAlshiblycoandaapiRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetRecordsResponse_records(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetRecordsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Record_id(ctx, field)
			case "name":
				return ec.fieldContext_Record_name(ctx, field)
			case "userId":
				return ec.fieldContext_Record_userId(ctx, field)
			case "record":
				return ec.fieldContext_Record_record(ctx, field)
			case "ranking":
				return ec.fieldContext_Record_ranking(ctx, field)
			case "data":
				return ec.fieldContext_Record_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Record_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Record_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Record", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetRecordsResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetRecordsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetRecordsResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetRecordsResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal model.GetRecordsError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetRecordsError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal model.GetRecordsError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetRecordsError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetRecordsError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetRecordsError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetRecordsError)
	fc.Result = res
	return ec.marshalNGetRecordsError2githubcomMorhafAlshiblycoandainternalbffmodelGetRecordsError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetRecordsResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetRecordsResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetRecordsError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTaskResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTaskResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTaskResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTaskResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTaskResponse_task(ctx context.Context, field graphql.CollectedField, obj *api.GetTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTaskResponse_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Task, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.Task
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Task
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.Task
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Task
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Task); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Task`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Task)
	fc.Result = res
	return ec.marshalOTask2githubcomMorhafAlshiblycoandaapiTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTaskResponse_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTaskResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "type":
				return ec.fieldContext_Task_type(ctx, field)
			case "data":
				return ec.fieldContext_Task_data(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Task_expiresAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Task_completedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Task_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Task_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTaskResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTaskResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetTaskResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal model.GetTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal model.GetTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetTaskError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetTaskError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetTaskError)
	fc.Result = res
	return ec.marshalNGetTaskError2githubcomMorhafAlshiblycoandainternalbffmodelGetTaskError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTaskResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTaskResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetTaskError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTasksResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTasksResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTasksResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTasksResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTasksResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTasksResponse_tasks(ctx context.Context, field graphql.CollectedField, obj *api.GetTasksResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTasksResponse_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tasks, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal []*api.Task
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Task
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal []*api.Task
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Task
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Task); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Task`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.Task)
	fc.Result = res
	return ec.marshalNTask2githubcomMorhafAlshiblycoandaapiTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTasksResponse_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTasksResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "type":
				return ec.fieldContext_Task_type(ctx, field)
			case "data":
				return ec.fieldContext_Task_data(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Task_expiresAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Task_completedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Task_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Task_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamMemberResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamMemberResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamMemberResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamMemberResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamMemberResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamMemberResponse_member(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamMemberResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamMemberResponse_member(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Member, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.TeamMember
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TeamMember
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.TeamMember
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TeamMember
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.TeamMember); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamMember`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.TeamMember)
	fc.Result = res
	return ec.marshalOTeamMember2githubcomMorhafAlshiblycoandaapiTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamMemberResponse_member(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamMemberResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamMember_id(ctx, field)
			case "userId":
				return ec.fieldContext_TeamMember_userId(ctx, field)
			case "teamId":
				return ec.fieldContext_TeamMember_teamId(ctx, field)
			case "data":
				return ec.fieldContext_TeamMember_data(ctx, field)
			case "joinedAt":
				return ec.fieldContext_TeamMember_joinedAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TeamMember_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamMemberResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamMemberResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamMemberResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetTeamMemberResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.GetTeamMemberError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTeamMemberError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.GetTeamMemberError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTeamMemberError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetTeamMemberError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetTeamMemberError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetTeamMemberError)
	fc.Result = res
	return ec.marshalNGetTeamMemberError2githubcomMorhafAlshiblycoandainternalbffmodelGetTeamMemberError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamMemberResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamMemberResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetTeamMemberError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamResponse_team(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamResponse_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Team, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.Team
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Team
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.Team
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Team
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Team); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Team`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Team)
	fc.Result = res
	return ec.marshalOTeam2githubcomMorhafAlshiblycoandaapiTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamResponse_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "name":
				return ec.fieldContext_Team_name(ctx, field)
			case "score":
				return ec.fieldContext_Team_score(ctx, field)
			case "ranking":
				return ec.fieldContext_Team_ranking(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "data":
				return ec.fieldContext_Team_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Team_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Team_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetTeamResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.GetTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.GetTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetTeamError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetTeamError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetTeamError)
	fc.Result = res
	return ec.marshalNGetTeamError2githubcomMorhafAlshiblycoandainternalbffmodelGetTeamError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetTeamError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamsResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamsResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamsResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamsResponse_teams(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamsResponse_teams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Teams, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal []*api.Team
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Team
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal []*api.Team
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Team
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Team); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Team`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomMorhafAlshiblycoandaapiTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamsResponse_teams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "name":
				return ec.fieldContext_Team_name(ctx, field)
			case "score":
				return ec.fieldContext_Team_score(ctx, field)
			case "ranking":
				return ec.fieldContext_Team_ranking(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "data":
				return ec.fieldContext_Team_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Team_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Team_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTournamentUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTournamentUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTournamentUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTournamentUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTournamentUserResponse_tournamentUser(ctx context.Context, field graphql.CollectedField, obj *api.GetTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTournamentUserResponse_tournamentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TournamentUser, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.TournamentUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TournamentUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.TournamentUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TournamentUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.TournamentUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TournamentUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.TournamentUser)
	fc.Result = res
	return ec.marshalOTournamentUser2githubcomMorhafAlshiblycoandaapiTournamentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTournamentUserResponse_tournamentUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTournamentUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TournamentUser_id(ctx, field)
			case "tournament":
				return ec.fieldContext_TournamentUser_tournament(ctx, field)
			case "userId":
				return ec.fieldContext_TournamentUser_userId(ctx, field)
			case "interval":
				return ec.fieldContext_TournamentUser_interval(ctx, field)
			case "score":
				return ec.fieldContext_TournamentUser_score(ctx, field)
			case "ranking":
				return ec.fieldContext_TournamentUser_ranking(ctx, field)
			case "data":
				return ec.fieldContext_TournamentUser_data(ctx, field)
			case "tournamentStartedAt":
				return ec.fieldContext_TournamentUser_tournamentStartedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_TournamentUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TournamentUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TournamentUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTournamentUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTournamentUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetTournamentUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal model.GetTournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal model.GetTournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetTournamentUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetTournamentUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetTournamentUserError)
	fc.Result = res
	return ec.marshalNGetTournamentUserError2githubcomMorhafAlshiblycoandainternalbffmodelGetTournamentUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTournamentUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTournamentUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetTournamentUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTournamentUsersResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTournamentUsersResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTournamentUsersResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTournamentUsersResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTournamentUsersResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTournamentUsersResponse_tournamentUsers(ctx context.Context, field graphql.CollectedField, obj *api.GetTournamentUsersResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTournamentUsersResponse_tournamentUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TournamentUsers, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal []*api.TournamentUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.TournamentUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal []*api.TournamentUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.TournamentUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.TournamentUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.TournamentUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.TournamentUser)
	fc.Result = res
	return ec.marshalNTournamentUser2githubcomMorhafAlshiblycoandaapiTournamentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTournamentUsersResponse_tournamentUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTournamentUsersResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TournamentUser_id(ctx, field)
			case "tournament":
				return ec.fieldContext_TournamentUser_tournament(ctx, field)
			case "userId":
				return ec.fieldContext_TournamentUser_userId(ctx, field)
			case "interval":
				return ec.fieldContext_TournamentUser_interval(ctx, field)
			case "score":
				return ec.fieldContext_TournamentUser_score(ctx, field)
			case "ranking":
				return ec.fieldContext_TournamentUser_ranking(ctx, field)
			case "data":
				return ec.fieldContext_TournamentUser_data(ctx, field)
			case "tournamentStartedAt":
				return ec.fieldContext_TournamentUser_tournamentStartedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_TournamentUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TournamentUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TournamentUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTournamentUsersResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetTournamentUsersResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTournamentUsersResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetTournamentUsersResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal model.GetTournamentUsersError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTournamentUsersError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal model.GetTournamentUsersError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTournamentUsersError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetTournamentUsersError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetTournamentUsersError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetTournamentUsersError)
	fc.Result = res
	return ec.marshalNGetTournamentUsersError2githubcomMorhafAlshiblycoandainternalbffmodelGetTournamentUsersError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTournamentUsersResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTournamentUsersResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetTournamentUsersError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_id(ctx context.Context, field graphql.CollectedField, obj *api.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_type(ctx context.Context, field graphql.CollectedField, obj *api.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Type, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_data(ctx context.Context, field graphql.CollectedField, obj *api.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_expiresAt(ctx context.Context, field graphql.CollectedField, obj *api.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ExpiresAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_expiresAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.ItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.ItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.ItemResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal model.ItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.ItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal model.ItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.ItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.ItemError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.ItemError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemError)
	fc.Result = res
	return ec.marshalNItemError2githubcomMorhafAlshiblycoandainternalbffmodelItemError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JoinTeamResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.JoinTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JoinTeamResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JoinTeamResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JoinTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JoinTeamResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.JoinTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JoinTeamResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.JoinTeamResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.JoinTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.JoinTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.JoinTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.JoinTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.JoinTeamError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.JoinTeamError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.JoinTeamError)
	fc.Result = res
	return ec.marshalNJoinTeamError2githubcomMorhafAlshiblycoandainternalbffmodelJoinTeamError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JoinTeamResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JoinTeamResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JoinTeamError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LeaveTeamResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.LeaveTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LeaveTeamResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LeaveTeamResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LeaveTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LeaveTeamResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.LeaveTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LeaveTeamResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.LeaveTeamResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.LeaveTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.LeaveTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.LeaveTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.LeaveTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.LeaveTeamError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.LeaveTeamError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LeaveTeamError)
	fc.Result = res
	return ec.marshalNLeaveTeamError2githubcomMorhafAlshiblycoandainternalbffmodelLeaveTeamError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LeaveTeamResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LeaveTeamResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LeaveTeamError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_id(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_arena(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_arena(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Arena, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Arena); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Arena`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.Arena)
	fc.Result = res
	return ec.marshalNArena2githubcomMorhafAlshiblycoandaapiArena(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_arena(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Arena_id(ctx, field)
			case "name":
				return ec.fieldContext_Arena_name(ctx, field)
			case "minPlayers":
				return ec.fieldContext_Arena_minPlayers(ctx, field)
			case "maxPlayersPerTicket":
				return ec.fieldContext_Arena_maxPlayersPerTicket(ctx, field)
			case "maxPlayers":
				return ec.fieldContext_Arena_maxPlayers(ctx, field)
			case "data":
				return ec.fieldContext_Arena_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Arena_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Arena_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Arena", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_tickets(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_tickets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tickets, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.MatchmakingTicket); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.MatchmakingTicket`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.MatchmakingTicket)
	fc.Result = res
	return ec.marshalNMatchmakingTicket2githubcomMorhafAlshiblycoandaapiMatchmakingTicket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_tickets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchmakingTicket_id(ctx, field)
			case "matchmakingUsers":
				return ec.fieldContext_MatchmakingTicket_matchmakingUsers(ctx, field)
			case "arenas":
				return ec.fieldContext_MatchmakingTicket_arenas(ctx, field)
			case "matchId":
				return ec.fieldContext_MatchmakingTicket_matchId(ctx, field)
			case "status":
				return ec.fieldContext_MatchmakingTicket_status(ctx, field)
			case "data":
				return ec.fieldContext_MatchmakingTicket_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchmakingTicket_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchmakingTicket_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchmakingTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_privateServerId(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_privateServerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PrivateServerId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_privateServerId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_status(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Match().Status(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.MatchStatus
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.MatchStatus
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.MatchStatus
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.MatchStatus
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.MatchStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.MatchStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MatchStatus)
	fc.Result = res
	return ec.marshalNMatchStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_data(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_lockedAt(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_lockedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LockedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_lockedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_startedAt(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.StartedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_startedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_endedAt(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_endedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.EndedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_endedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_id(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_matchmakingUsers(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_matchmakingUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchmakingUsers, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.MatchmakingUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.MatchmakingUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.MatchmakingUser)
	fc.Result = res
	return ec.marshalNMatchmakingUser2githubcomMorhafAlshiblycoandaapiMatchmakingUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_matchmakingUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchmakingUser_id(ctx, field)
			case "clientUserId":
				return ec.fieldContext_MatchmakingUser_clientUserId(ctx, field)
			case "data":
				return ec.fieldContext_MatchmakingUser_data(ctx, field)
			case "elo":
				return ec.fieldContext_MatchmakingUser_elo(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchmakingUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchmakingUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchmakingUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_arenas(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_arenas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Arenas, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Arena); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Arena`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.Arena)
	fc.Result = res
	return ec.marshalNArena2githubcomMorhafAlshiblycoandaapiArena(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_arenas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Arena_id(ctx, field)
			case "name":
				return ec.fieldContext_Arena_name(ctx, field)
			case "minPlayers":
				return ec.fieldContext_Arena_minPlayers(ctx, field)
			case "maxPlayersPerTicket":
				return ec.fieldContext_Arena_maxPlayersPerTicket(ctx, field)
			case "maxPlayers":
				return ec.fieldContext_Arena_maxPlayers(ctx, field)
			case "data":
				return ec.fieldContext_Arena_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Arena_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Arena_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Arena", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_matchId(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_matchId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_matchId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_status(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.MatchmakingTicket().Status(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.MatchmakingTicketStatus
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.MatchmakingTicketStatus
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.MatchmakingTicketStatus
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.MatchmakingTicketStatus
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.MatchmakingTicketStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.MatchmakingTicketStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MatchmakingTicketStatus)
	fc.Result = res
	return ec.marshalNMatchmakingTicketStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchmakingTicketStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchmakingTicketStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_data(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingUser_id(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingUser_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingUser_clientUserId(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingUser_clientUserId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ClientUserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingUser_clientUserId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingUser_data(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingUser_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingUser_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingUser_elo(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingUser_elo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Elo, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingUser_elo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingUser_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingUser_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingUser_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingUser_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingUser_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingUser_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateEvent(rctx, fc.Args["input"].(*api.CreateEventRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.CreateEventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateEventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.CreateEventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateEventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateEventResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateEventResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateEventResponse)
	fc.Result = res
	return ec.marshalNCreateEventResponse2githubcomMorhafAlshiblycoandaapiCreateEventResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateEventResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateEventResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateEventResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateEventResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEvent(rctx, fc.Args["input"].(*api.UpdateEventRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.UpdateEventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateEventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.UpdateEventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateEventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateEventResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateEventResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateEventResponse)
	fc.Result = res
	return ec.marshalNUpdateEventResponse2githubcomMorhafAlshiblycoandaapiUpdateEventResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateEventResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateEventResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateEventResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteEvent(rctx, fc.Args["input"].(*api.EventRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.EventResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.EventResponse)
	fc.Result = res
	return ec.marshalNEventResponse2githubcomMorhafAlshiblycoandaapiEventResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_EventResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_EventResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateEventRound(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateEventRound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateEventRound(rctx, fc.Args["input"].(*api.CreateEventRoundRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.CreateEventRoundResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateEventRoundResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.CreateEventRoundResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateEventRoundResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateEventRoundResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateEventRoundResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateEventRoundResponse)
	fc.Result = res
	return ec.marshalNCreateEventRoundResponse2githubcomMorhafAlshiblycoandaapiCreateEventRoundResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateEventRound(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateEventRoundResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateEventRoundResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateEventRoundResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateEventRoundResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateEventRound_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateEventRound(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateEventRound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEventRound(rctx, fc.Args["input"].(*api.UpdateEventRoundRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.UpdateEventRoundResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateEventRoundResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.UpdateEventRoundResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateEventRoundResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateEventRoundResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateEventRoundResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateEventRoundResponse)
	fc.Result = res
	return ec.marshalNUpdateEventRoundResponse2githubcomMorhafAlshiblycoandaapiUpdateEventRoundResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateEventRound(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateEventRoundResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateEventRoundResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateEventRoundResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateEventRound_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateEventUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateEventUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEventUser(rctx, fc.Args["input"].(*api.UpdateEventUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.UpdateEventUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateEventUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.UpdateEventUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateEventUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateEventUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateEventUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateEventUserResponse)
	fc.Result = res
	return ec.marshalNUpdateEventUserResponse2githubcomMorhafAlshiblycoandaapiUpdateEventUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateEventUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateEventUserResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateEventUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateEventUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateEventUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteEventUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteEventUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteEventUser(rctx, fc.Args["input"].(*api.EventUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.EventUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.EventUserResponse)
	fc.Result = res
	return ec.marshalNEventUserResponse2githubcomMorhafAlshiblycoandaapiEventUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteEventUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_EventUserResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_EventUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteEventUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_AddEventResult(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_AddEventResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddEventResult(rctx, fc.Args["input"].(*api.AddEventResultRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.AddEventResultResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.AddEventResultResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.AddEventResultResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.AddEventResultResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.AddEventResultResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.AddEventResultResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.AddEventResultResponse)
	fc.Result = res
	return ec.marshalNAddEventResultResponse2githubcomMorhafAlshiblycoandaapiAddEventResultResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_AddEventResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_AddEventResultResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_AddEventResultResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AddEventResultResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_AddEventResult_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_RemoveEventResult(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_RemoveEventResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RemoveEventResult(rctx, fc.Args["input"].(*api.EventRoundUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.RemoveEventResultResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.RemoveEventResultResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.RemoveEventResultResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.RemoveEventResultResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.RemoveEventResultResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.RemoveEventResultResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.RemoveEventResultResponse)
	fc.Result = res
	return ec.marshalNRemoveEventResultResponse2githubcomMorhafAlshiblycoandaapiRemoveEventResultResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_RemoveEventResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_RemoveEventResultResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_RemoveEventResultResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RemoveEventResultResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_RemoveEventResult_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateItem(rctx, fc.Args["input"].(*api.CreateItemRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *api.CreateItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *api.CreateItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateItemResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateItemResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateItemResponse)
	fc.Result = res
	return ec.marshalNCreateItemResponse2githubcomMorhafAlshiblycoandaapiCreateItemResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateItemResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_CreateItemResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateItemResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateItem(rctx, fc.Args["input"].(*api.UpdateItemRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *api.UpdateItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *api.UpdateItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateItemResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateItemResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateItemResponse)
	fc.Result = res
	return ec.marshalNUpdateItemResponse2githubcomMorhafAlshiblycoandaapiUpdateItemResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateItemResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateItemResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateItemResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteItem(rctx, fc.Args["input"].(*api.ItemRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *api.ItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.ItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *api.ItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.ItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.ItemResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.ItemResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.ItemResponse)
	fc.Result = res
	return ec.marshalNItemResponse2githubcomMorhafAlshiblycoandaapiItemResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_ItemResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_ItemResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateArena(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateArena(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateArena(rctx, fc.Args["input"].(*api.CreateArenaRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.CreateArenaResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateArenaResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.CreateArenaResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateArenaResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateArenaResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateArenaResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateArenaResponse)
	fc.Result = res
	return ec.marshalNCreateArenaResponse2githubcomMorhafAlshiblycoandaapiCreateArenaResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateArena(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateArenaResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateArenaResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateArenaResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateArenaResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateArena_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateArena(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateArena(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateArena(rctx, fc.Args["input"].(*api.UpdateArenaRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateArenaResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateArenaResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateArenaResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateArenaResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateArenaResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateArenaResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateArenaResponse)
	fc.Result = res
	return ec.marshalNUpdateArenaResponse2githubcomMorhafAlshiblycoandaapiUpdateArenaResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateArena(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateArenaResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateArenaResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateArenaResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateArena_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateMatchmakingUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateMatchmakingUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateMatchmakingUser(rctx, fc.Args["input"].(*api.CreateMatchmakingUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.CreateMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.CreateMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateMatchmakingUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateMatchmakingUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateMatchmakingUserResponse)
	fc.Result = res
	return ec.marshalNCreateMatchmakingUserResponse2githubcomMorhafAlshiblycoandaapiCreateMatchmakingUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateMatchmakingUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateMatchmakingUserResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateMatchmakingUserResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateMatchmakingUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateMatchmakingUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateMatchmakingUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateMatchmakingUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateMatchmakingUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMatchmakingUser(rctx, fc.Args["input"].(*api.UpdateMatchmakingUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateMatchmakingUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateMatchmakingUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateMatchmakingUserResponse)
	fc.Result = res
	return ec.marshalNUpdateMatchmakingUserResponse2githubcomMorhafAlshiblycoandaapiUpdateMatchmakingUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateMatchmakingUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateMatchmakingUserResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateMatchmakingUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateMatchmakingUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateMatchmakingUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteMatchmakingUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteMatchmakingUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteMatchmakingUser(rctx, fc.Args["input"].(*api.MatchmakingUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.DeleteMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.DeleteMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.DeleteMatchmakingUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.DeleteMatchmakingUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.DeleteMatchmakingUserResponse)
	fc.Result = res
	return ec.marshalNDeleteMatchmakingUserResponse2githubcomMorhafAlshiblycoandaapiDeleteMatchmakingUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteMatchmakingUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteMatchmakingUserResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_DeleteMatchmakingUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteMatchmakingUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteMatchmakingUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateMatchmakingTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateMatchmakingTicket(rctx, fc.Args["input"].(*api.CreateMatchmakingTicketRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.CreateMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.CreateMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateMatchmakingTicketResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateMatchmakingTicketResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateMatchmakingTicketResponse)
	fc.Result = res
	return ec.marshalNCreateMatchmakingTicketResponse2githubcomMorhafAlshiblycoandaapiCreateMatchmakingTicketResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateMatchmakingTicketResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateMatchmakingTicketResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateMatchmakingTicketResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateMatchmakingTicketResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateMatchmakingTicket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateMatchmakingTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMatchmakingTicket(rctx, fc.Args["input"].(*api.UpdateMatchmakingTicketRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateMatchmakingTicketResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateMatchmakingTicketResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateMatchmakingTicketResponse)
	fc.Result = res
	return ec.marshalNUpdateMatchmakingTicketResponse2githubcomMorhafAlshiblycoandaapiUpdateMatchmakingTicketResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateMatchmakingTicketResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateMatchmakingTicketResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateMatchmakingTicketResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateMatchmakingTicket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteMatchmakingTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteMatchmakingTicket(rctx, fc.Args["input"].(*api.MatchmakingTicketRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.DeleteMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.DeleteMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.DeleteMatchmakingTicketResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.DeleteMatchmakingTicketResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.DeleteMatchmakingTicketResponse)
	fc.Result = res
	return ec.marshalNDeleteMatchmakingTicketResponse2githubcomMorhafAlshiblycoandaapiDeleteMatchmakingTicketResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteMatchmakingTicketResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_DeleteMatchmakingTicketResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteMatchmakingTicketResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteMatchmakingTicket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_StartMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_StartMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().StartMatch(rctx, fc.Args["input"].(*api.StartMatchRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.StartMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.StartMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.StartMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.StartMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.StartMatchResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.StartMatchResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.StartMatchResponse)
	fc.Result = res
	return ec.marshalNStartMatchResponse2githubcomMorhafAlshiblycoandaapiStartMatchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_StartMatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_StartMatchResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_StartMatchResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StartMatchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_StartMatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_EndMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_EndMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().EndMatch(rctx, fc.Args["input"].(*api.EndMatchRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.EndMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EndMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.EndMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EndMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.EndMatchResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EndMatchResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.EndMatchResponse)
	fc.Result = res
	return ec.marshalNEndMatchResponse2githubcomMorhafAlshiblycoandaapiEndMatchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_EndMatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_EndMatchResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_EndMatchResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EndMatchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_EndMatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMatch(rctx, fc.Args["input"].(*api.UpdateMatchRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateMatchResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateMatchResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateMatchResponse)
	fc.Result = res
	return ec.marshalNUpdateMatchResponse2githubcomMorhafAlshiblycoandaapiUpdateMatchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateMatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateMatchResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateMatchResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateMatchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateMatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_SetMatchPrivateServer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_SetMatchPrivateServer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetMatchPrivateServer(rctx, fc.Args["input"].(*api.SetMatchPrivateServerRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.SetMatchPrivateServerResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.SetMatchPrivateServerResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.SetMatchPrivateServerResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.SetMatchPrivateServerResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.SetMatchPrivateServerResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.SetMatchPrivateServerResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.SetMatchPrivateServerResponse)
	fc.Result = res
	return ec.marshalNSetMatchPrivateServerResponse2githubcomMorhafAlshiblycoandaapiSetMatchPrivateServerResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_SetMatchPrivateServer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_SetMatchPrivateServerResponse_success(ctx, field)
			case "privateServerId":
				return ec.fieldContext_SetMatchPrivateServerResponse_privateServerId(ctx, field)
			case "error":
				return ec.fieldContext_SetMatchPrivateServerResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SetMatchPrivateServerResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_SetMatchPrivateServer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteMatch(rctx, fc.Args["input"].(*api.MatchRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.DeleteMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.DeleteMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.DeleteMatchResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.DeleteMatchResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.DeleteMatchResponse)
	fc.Result = res
	return ec.marshalNDeleteMatchResponse2githubcomMorhafAlshiblycoandaapiDeleteMatchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteMatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteMatchResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_DeleteMatchResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteMatchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteMatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateRecord(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateRecord(rctx, fc.Args["input"].(*api.CreateRecordRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *api.CreateRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *api.CreateRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateRecordResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateRecordResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateRecordResponse)
	fc.Result = res
	return ec.marshalNCreateRecordResponse2githubcomMorhafAlshiblycoandaapiCreateRecordResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateRecordResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateRecordResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateRecordResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateRecordResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateRecord_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateRecord(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateRecord(rctx, fc.Args["input"].(*api.UpdateRecordRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *api.UpdateRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *api.UpdateRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateRecordResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateRecordResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateRecordResponse)
	fc.Result = res
	return ec.marshalNUpdateRecordResponse2githubcomMorhafAlshiblycoandaapiUpdateRecordResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateRecordResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateRecordResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateRecordResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateRecord_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteRecord(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteRecord(rctx, fc.Args["input"].(*api.RecordRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *api.DeleteRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *api.DeleteRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.DeleteRecordResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.DeleteRecordResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.DeleteRecordResponse)
	fc.Result = res
	return ec.marshalNDeleteRecordResponse2githubcomMorhafAlshiblycoandaapiDeleteRecordResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteRecordResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_DeleteRecordResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteRecordResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteRecord_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTask(rctx, fc.Args["input"].(*api.CreateTaskRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.CreateTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.CreateTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateTaskResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateTaskResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateTaskResponse)
	fc.Result = res
	return ec.marshalNCreateTaskResponse2githubcomMorhafAlshiblycoandaapiCreateTaskResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateTaskResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_CreateTaskResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateTaskResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTask(rctx, fc.Args["input"].(*api.UpdateTaskRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.UpdateTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.UpdateTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateTaskResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateTaskResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateTaskResponse)
	fc.Result = res
	return ec.marshalNUpdateTaskResponse2githubcomMorhafAlshiblycoandaapiUpdateTaskResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateTaskResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateTaskResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTaskResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CompleteTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CompleteTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CompleteTask(rctx, fc.Args["input"].(*api.TaskRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.CompleteTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CompleteTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.CompleteTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CompleteTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CompleteTaskResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CompleteTaskResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CompleteTaskResponse)
	fc.Result = res
	return ec.marshalNCompleteTaskResponse2githubcomMorhafAlshiblycoandaapiCompleteTaskResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CompleteTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CompleteTaskResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_CompleteTaskResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompleteTaskResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CompleteTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTask(rctx, fc.Args["input"].(*api.TaskRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.TaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.TaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.TaskResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TaskResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.TaskResponse)
	fc.Result = res
	return ec.marshalNTaskResponse2githubcomMorhafAlshiblycoandaapiTaskResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_TaskResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_TaskResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTeam(rctx, fc.Args["input"].(*api.CreateTeamRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.CreateTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.CreateTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateTeamResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateTeamResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateTeamResponse)
	fc.Result = res
	return ec.marshalNCreateTeamResponse2githubcomMorhafAlshiblycoandaapiCreateTeamResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateTeamResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateTeamResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateTeamResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateTeamResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTeam(rctx, fc.Args["input"].(*api.UpdateTeamRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.UpdateTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.UpdateTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateTeamResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateTeamResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateTeamResponse)
	fc.Result = res
	return ec.marshalNUpdateTeamResponse2githubcomMorhafAlshiblycoandaapiUpdateTeamResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateTeamResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateTeamResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTeamResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTeam(rctx, fc.Args["input"].(*api.TeamRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.TeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.TeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.TeamResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.TeamResponse)
	fc.Result = res
	return ec.marshalNTeamResponse2githubcomMorhafAlshiblycoandaapiTeamResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_TeamResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_TeamResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_JoinTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_JoinTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().JoinTeam(rctx, fc.Args["input"].(*api.JoinTeamRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.JoinTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.JoinTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.JoinTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.JoinTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.JoinTeamResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.JoinTeamResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.JoinTeamResponse)
	fc.Result = res
	return ec.marshalNJoinTeamResponse2githubcomMorhafAlshiblycoandaapiJoinTeamResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_JoinTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_JoinTeamResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_JoinTeamResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JoinTeamResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_JoinTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_LeaveTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_LeaveTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().LeaveTeam(rctx, fc.Args["input"].(*api.TeamMemberRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.LeaveTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.LeaveTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.LeaveTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.LeaveTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.LeaveTeamResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.LeaveTeamResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.LeaveTeamResponse)
	fc.Result = res
	return ec.marshalNLeaveTeamResponse2githubcomMorhafAlshiblycoandaapiLeaveTeamResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_LeaveTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_LeaveTeamResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_LeaveTeamResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LeaveTeamResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_LeaveTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateTeamMember(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateTeamMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTeamMember(rctx, fc.Args["input"].(*api.UpdateTeamMemberRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.UpdateTeamMemberResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTeamMemberResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.UpdateTeamMemberResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTeamMemberResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateTeamMemberResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateTeamMemberResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateTeamMemberResponse)
	fc.Result = res
	return ec.marshalNUpdateTeamMemberResponse2githubcomMorhafAlshiblycoandaapiUpdateTeamMemberResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateTeamMember(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateTeamMemberResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateTeamMemberResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTeamMemberResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateTeamMember_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateTournamentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateTournamentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTournamentUser(rctx, fc.Args["input"].(*api.CreateTournamentUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.CreateTournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateTournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.CreateTournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateTournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateTournamentUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateTournamentUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateTournamentUserResponse)
	fc.Result = res
	return ec.marshalNCreateTournamentUserResponse2githubcomMorhafAlshiblycoandaapiCreateTournamentUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateTournamentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateTournamentUserResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateTournamentUserResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateTournamentUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateTournamentUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateTournamentUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateTournamentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateTournamentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTournamentUser(rctx, fc.Args["input"].(*api.UpdateTournamentUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.UpdateTournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.UpdateTournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateTournamentUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateTournamentUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateTournamentUserResponse)
	fc.Result = res
	return ec.marshalNUpdateTournamentUserResponse2githubcomMorhafAlshiblycoandaapiUpdateTournamentUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateTournamentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateTournamentUserResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateTournamentUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTournamentUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateTournamentUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteTournamentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteTournamentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTournamentUser(rctx, fc.Args["input"].(*api.TournamentUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.TournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.TournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.TournamentUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TournamentUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.TournamentUserResponse)
	fc.Result = res
	return ec.marshalNTournamentUserResponse2githubcomMorhafAlshiblycoandaapiTournamentUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteTournamentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_TournamentUserResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_TournamentUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TournamentUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteTournamentUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Webhook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Webhook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Webhook(rctx, fc.Args["input"].(*api.WebhookRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Webhook")
			if err != nil {
				var zeroVal *api.WebhookResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.WebhookResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Webhook")
			if err != nil {
				var zeroVal *api.WebhookResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.WebhookResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.WebhookResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.WebhookResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.WebhookResponse)
	fc.Result = res
	return ec.marshalNWebhookResponse2githubcomMorhafAlshiblycoandaapiWebhookResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Webhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_WebhookResponse_status(ctx, field)
			case "headers":
				return ec.fieldContext_WebhookResponse_headers(ctx, field)
			case "body":
				return ec.fieldContext_WebhookResponse_body(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WebhookResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_Webhook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetEvent(rctx, fc.Args["input"].(*api.GetEventRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.GetEventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetEventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.GetEventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetEventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetEventResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetEventResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetEventResponse)
	fc.Result = res
	return ec.marshalNGetEventResponse2githubcomMorhafAlshiblycoandaapiGetEventResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetEventResponse_success(ctx, field)
			case "event":
				return ec.fieldContext_GetEventResponse_event(ctx, field)
			case "leaderboard":
				return ec.fieldContext_GetEventResponse_leaderboard(ctx, field)
			case "error":
				return ec.fieldContext_GetEventResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetEventResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetEventRound(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetEventRound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetEventRound(rctx, fc.Args["input"].(*api.GetEventRoundRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.GetEventRoundResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetEventRoundResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.GetEventRoundResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetEventRoundResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetEventRoundResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetEventRoundResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetEventRoundResponse)
	fc.Result = res
	return ec.marshalNGetEventRoundResponse2githubcomMorhafAlshiblycoandaapiGetEventRoundResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetEventRound(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetEventRoundResponse_success(ctx, field)
			case "round":
				return ec.fieldContext_GetEventRoundResponse_round(ctx, field)
			case "results":
				return ec.fieldContext_GetEventRoundResponse_results(ctx, field)
			case "error":
				return ec.fieldContext_GetEventRoundResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetEventRoundResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetEventRound_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetEventUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetEventUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetEventUser(rctx, fc.Args["input"].(*api.GetEventUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.GetEventUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetEventUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal *api.GetEventUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetEventUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetEventUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetEventUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetEventUserResponse)
	fc.Result = res
	return ec.marshalNGetEventUserResponse2githubcomMorhafAlshiblycoandaapiGetEventUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetEventUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetEventUserResponse_success(ctx, field)
			case "user":
				return ec.fieldContext_GetEventUserResponse_user(ctx, field)
			case "results":
				return ec.fieldContext_GetEventUserResponse_results(ctx, field)
			case "error":
				return ec.fieldContext_GetEventUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetEventUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetEventUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetItem(rctx, fc.Args["input"].(*api.ItemRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *api.GetItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *api.GetItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetItemResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetItemResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetItemResponse)
	fc.Result = res
	return ec.marshalNGetItemResponse2githubcomMorhafAlshiblycoandaapiGetItemResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetItemResponse_success(ctx, field)
			case "item":
				return ec.fieldContext_GetItemResponse_item(ctx, field)
			case "error":
				return ec.fieldContext_GetItemResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetItemResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetItems(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetItems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetItems(rctx, fc.Args["input"].(*api.GetItemsRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *api.GetItemsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetItemsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal *api.GetItemsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetItemsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetItemsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetItemsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetItemsResponse)
	fc.Result = res
	return ec.marshalNGetItemsResponse2githubcomMorhafAlshiblycoandaapiGetItemsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetItems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetItemsResponse_success(ctx, field)
			case "items":
				return ec.fieldContext_GetItemsResponse_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetItemsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetItems_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetArena(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetArena(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetArena(rctx, fc.Args["input"].(*api.ArenaRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetArenaResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetArenaResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetArenaResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetArenaResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetArenaResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetArenaResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetArenaResponse)
	fc.Result = res
	return ec.marshalNGetArenaResponse2githubcomMorhafAlshiblycoandaapiGetArenaResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetArena(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetArenaResponse_success(ctx, field)
			case "arena":
				return ec.fieldContext_GetArenaResponse_arena(ctx, field)
			case "error":
				return ec.fieldContext_GetArenaResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetArenaResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetArena_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetArenas(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetArenas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetArenas(rctx, fc.Args["input"].(*api.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetArenasResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetArenasResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetArenasResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetArenasResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetArenasResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetArenasResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetArenasResponse)
	fc.Result = res
	return ec.marshalNGetArenasResponse2githubcomMorhafAlshiblycoandaapiGetArenasResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetArenas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetArenasResponse_success(ctx, field)
			case "arenas":
				return ec.fieldContext_GetArenasResponse_arenas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetArenasResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetArenas_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetMatchmakingUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetMatchmakingUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMatchmakingUser(rctx, fc.Args["input"].(*api.MatchmakingUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetMatchmakingUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetMatchmakingUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetMatchmakingUserResponse)
	fc.Result = res
	return ec.marshalNGetMatchmakingUserResponse2githubcomMorhafAlshiblycoandaapiGetMatchmakingUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetMatchmakingUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetMatchmakingUserResponse_success(ctx, field)
			case "matchmakingUser":
				return ec.fieldContext_GetMatchmakingUserResponse_matchmakingUser(ctx, field)
			case "error":
				return ec.fieldContext_GetMatchmakingUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMatchmakingUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetMatchmakingUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetMatchmakingUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetMatchmakingUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMatchmakingUsers(rctx, fc.Args["input"].(*api.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingUsersResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingUsersResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingUsersResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingUsersResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetMatchmakingUsersResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetMatchmakingUsersResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetMatchmakingUsersResponse)
	fc.Result = res
	return ec.marshalNGetMatchmakingUsersResponse2githubcomMorhafAlshiblycoandaapiGetMatchmakingUsersResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetMatchmakingUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetMatchmakingUsersResponse_success(ctx, field)
			case "matchmakingUsers":
				return ec.fieldContext_GetMatchmakingUsersResponse_matchmakingUsers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMatchmakingUsersResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetMatchmakingUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetMatchmakingTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMatchmakingTicket(rctx, fc.Args["input"].(*api.GetMatchmakingTicketRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetMatchmakingTicketResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetMatchmakingTicketResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetMatchmakingTicketResponse)
	fc.Result = res
	return ec.marshalNGetMatchmakingTicketResponse2githubcomMorhafAlshiblycoandaapiGetMatchmakingTicketResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetMatchmakingTicketResponse_success(ctx, field)
			case "matchmakingTicket":
				return ec.fieldContext_GetMatchmakingTicketResponse_matchmakingTicket(ctx, field)
			case "error":
				return ec.fieldContext_GetMatchmakingTicketResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMatchmakingTicketResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetMatchmakingTicket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetMatchmakingTickets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetMatchmakingTickets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMatchmakingTickets(rctx, fc.Args["input"].(*api.GetMatchmakingTicketsRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingTicketsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingTicketsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingTicketsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingTicketsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetMatchmakingTicketsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetMatchmakingTicketsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetMatchmakingTicketsResponse)
	fc.Result = res
	return ec.marshalNGetMatchmakingTicketsResponse2githubcomMorhafAlshiblycoandaapiGetMatchmakingTicketsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetMatchmakingTickets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetMatchmakingTicketsResponse_success(ctx, field)
			case "matchmakingTickets":
				return ec.fieldContext_GetMatchmakingTicketsResponse_matchmakingTickets(ctx, field)
			case "error":
				return ec.fieldContext_GetMatchmakingTicketsResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMatchmakingTicketsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetMatchmakingTickets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMatch(rctx, fc.Args["input"].(*api.GetMatchRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetMatchResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetMatchResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetMatchResponse)
	fc.Result = res
	return ec.marshalNGetMatchResponse2githubcomMorhafAlshiblycoandaapiGetMatchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetMatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetMatchResponse_success(ctx, field)
			case "match":
				return ec.fieldContext_GetMatchResponse_match(ctx, field)
			case "error":
				return ec.fieldContext_GetMatchResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMatchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetMatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetMatches(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetMatches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMatches(rctx, fc.Args["input"].(*api.GetMatchesRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchesResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchesResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchesResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchesResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetMatchesResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetMatchesResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetMatchesResponse)
	fc.Result = res
	return ec.marshalNGetMatchesResponse2githubcomMorhafAlshiblycoandaapiGetMatchesResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetMatches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetMatchesResponse_success(ctx, field)
			case "matches":
				return ec.fieldContext_GetMatchesResponse_matches(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMatchesResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetMatches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetRecord(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetRecord(rctx, fc.Args["input"].(*api.RecordRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *api.GetRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *api.GetRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetRecordResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetRecordResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetRecordResponse)
	fc.Result = res
	return ec.marshalNGetRecordResponse2githubcomMorhafAlshiblycoandaapiGetRecordResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetRecordResponse_success(ctx, field)
			case "record":
				return ec.fieldContext_GetRecordResponse_record(ctx, field)
			case "error":
				return ec.fieldContext_GetRecordResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetRecordResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetRecord_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetRecords(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetRecords(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetRecords(rctx, fc.Args["input"].(*api.GetRecordsRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *api.GetRecordsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetRecordsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *api.GetRecordsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetRecordsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetRecordsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetRecordsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetRecordsResponse)
	fc.Result = res
	return ec.marshalNGetRecordsResponse2githubcomMorhafAlshiblycoandaapiGetRecordsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetRecords(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetRecordsResponse_success(ctx, field)
			case "records":
				return ec.fieldContext_GetRecordsResponse_records(ctx, field)
			case "error":
				return ec.fieldContext_GetRecordsResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetRecordsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetRecords_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTask(rctx, fc.Args["input"].(*api.TaskRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.GetTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.GetTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTaskResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTaskResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTaskResponse)
	fc.Result = res
	return ec.marshalNGetTaskResponse2githubcomMorhafAlshiblycoandaapiGetTaskResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTaskResponse_success(ctx, field)
			case "task":
				return ec.fieldContext_GetTaskResponse_task(ctx, field)
			case "error":
				return ec.fieldContext_GetTaskResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTaskResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTasks(rctx, fc.Args["input"].(*api.GetTasksRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.GetTasksResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTasksResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *api.GetTasksResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTasksResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTasksResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTasksResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTasksResponse)
	fc.Result = res
	return ec.marshalNGetTasksResponse2githubcomMorhafAlshiblycoandaapiGetTasksResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTasksResponse_success(ctx, field)
			case "tasks":
				return ec.fieldContext_GetTasksResponse_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTasksResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTeam(rctx, fc.Args["input"].(*api.GetTeamRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.GetTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.GetTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTeamResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTeamResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTeamResponse)
	fc.Result = res
	return ec.marshalNGetTeamResponse2githubcomMorhafAlshiblycoandaapiGetTeamResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTeamResponse_success(ctx, field)
			case "team":
				return ec.fieldContext_GetTeamResponse_team(ctx, field)
			case "error":
				return ec.fieldContext_GetTeamResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTeamResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTeams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTeams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTeams(rctx, fc.Args["input"].(*api.GetTeamsRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.GetTeamsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTeamsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.GetTeamsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTeamsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTeamsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTeamsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTeamsResponse)
	fc.Result = res
	return ec.marshalNGetTeamsResponse2githubcomMorhafAlshiblycoandaapiGetTeamsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTeams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTeamsResponse_success(ctx, field)
			case "teams":
				return ec.fieldContext_GetTeamsResponse_teams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTeamsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTeams_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTeamMember(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTeamMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTeamMember(rctx, fc.Args["input"].(*api.TeamMemberRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.GetTeamMemberResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTeamMemberResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.GetTeamMemberResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTeamMemberResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTeamMemberResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTeamMemberResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTeamMemberResponse)
	fc.Result = res
	return ec.marshalNGetTeamMemberResponse2githubcomMorhafAlshiblycoandaapiGetTeamMemberResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTeamMember(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTeamMemberResponse_success(ctx, field)
			case "member":
				return ec.fieldContext_GetTeamMemberResponse_member(ctx, field)
			case "error":
				return ec.fieldContext_GetTeamMemberResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTeamMemberResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTeamMember_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_SearchTeams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_SearchTeams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SearchTeams(rctx, fc.Args["input"].(*api.SearchTeamsRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.SearchTeamsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.SearchTeamsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *api.SearchTeamsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.SearchTeamsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.SearchTeamsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.SearchTeamsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.SearchTeamsResponse)
	fc.Result = res
	return ec.marshalNSearchTeamsResponse2githubcomMorhafAlshiblycoandaapiSearchTeamsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_SearchTeams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_SearchTeamsResponse_success(ctx, field)
			case "teams":
				return ec.fieldContext_SearchTeamsResponse_teams(ctx, field)
			case "error":
				return ec.fieldContext_SearchTeamsResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchTeamsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_SearchTeams_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTournamentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTournamentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTournamentUser(rctx, fc.Args["input"].(*api.TournamentUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.GetTournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.GetTournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTournamentUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTournamentUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTournamentUserResponse)
	fc.Result = res
	return ec.marshalNGetTournamentUserResponse2githubcomMorhafAlshiblycoandaapiGetTournamentUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTournamentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTournamentUserResponse_success(ctx, field)
			case "tournamentUser":
				return ec.fieldContext_GetTournamentUserResponse_tournamentUser(ctx, field)
			case "error":
				return ec.fieldContext_GetTournamentUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTournamentUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTournamentUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTournamentUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTournamentUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTournamentUsers(rctx, fc.Args["input"].(*api.GetTournamentUsersRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.GetTournamentUsersResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTournamentUsersResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.GetTournamentUsersResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTournamentUsersResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTournamentUsersResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTournamentUsersResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTournamentUsersResponse)
	fc.Result = res
	return ec.marshalNGetTournamentUsersResponse2githubcomMorhafAlshiblycoandaapiGetTournamentUsersResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTournamentUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTournamentUsersResponse_success(ctx, field)
			case "tournamentUsers":
				return ec.fieldContext_GetTournamentUsersResponse_tournamentUsers(ctx, field)
			case "error":
				return ec.fieldContext_GetTournamentUsersResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTournamentUsersResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTournamentUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_id(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_name(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_userId(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_record(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_record(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Record, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_record(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_ranking(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_ranking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Ranking, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_ranking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_data(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveEventResultResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.RemoveEventResultResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveEventResultResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveEventResultResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveEventResultResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveEventResultResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.RemoveEventResultResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveEventResultResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.RemoveEventResultResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.RemoveEventResultError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.RemoveEventResultError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.RemoveEventResultError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.RemoveEventResultError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.RemoveEventResultError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.RemoveEventResultError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RemoveEventResultError)
	fc.Result = res
	return ec.marshalNRemoveEventResultError2githubcomMorhafAlshiblycoandainternalbffmodelRemoveEventResultError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveEventResultResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveEventResultResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RemoveEventResultError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchTeamsResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.SearchTeamsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchTeamsResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchTeamsResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchTeamsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchTeamsResponse_teams(ctx context.Context, field graphql.CollectedField, obj *api.SearchTeamsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchTeamsResponse_teams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Teams, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal []*api.Team
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Team
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal []*api.Team
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Team
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Team); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Team`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomMorhafAlshiblycoandaapiTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchTeamsResponse_teams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchTeamsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "name":
				return ec.fieldContext_Team_name(ctx, field)
			case "score":
				return ec.fieldContext_Team_score(ctx, field)
			case "ranking":
				return ec.fieldContext_Team_ranking(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "data":
				return ec.fieldContext_Team_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Team_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Team_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchTeamsResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.SearchTeamsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchTeamsResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.SearchTeamsResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.SearchTeamsError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.SearchTeamsError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.SearchTeamsError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.SearchTeamsError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.SearchTeamsError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.SearchTeamsError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SearchTeamsError)
	fc.Result = res
	return ec.marshalNSearchTeamsError2githubcomMorhafAlshiblycoandainternalbffmodelSearchTeamsError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchTeamsResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchTeamsResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchTeamsError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetMatchPrivateServerResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.SetMatchPrivateServerResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetMatchPrivateServerResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetMatchPrivateServerResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetMatchPrivateServerResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetMatchPrivateServerResponse_privateServerId(ctx context.Context, field graphql.CollectedField, obj *api.SetMatchPrivateServerResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetMatchPrivateServerResponse_privateServerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PrivateServerId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetMatchPrivateServerResponse_privateServerId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetMatchPrivateServerResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetMatchPrivateServerResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.SetMatchPrivateServerResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetMatchPrivateServerResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.SetMatchPrivateServerResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.SetMatchPrivateServerError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.SetMatchPrivateServerError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.SetMatchPrivateServerError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.SetMatchPrivateServerError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.SetMatchPrivateServerError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.SetMatchPrivateServerError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SetMatchPrivateServerError)
	fc.Result = res
	return ec.marshalNSetMatchPrivateServerError2githubcomMorhafAlshiblycoandainternalbffmodelSetMatchPrivateServerError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetMatchPrivateServerResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetMatchPrivateServerResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SetMatchPrivateServerError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StartMatchResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.StartMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StartMatchResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StartMatchResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StartMatchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StartMatchResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.StartMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StartMatchResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.StartMatchResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.StartMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.StartMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.StartMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.StartMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.StartMatchError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.StartMatchError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.StartMatchError)
	fc.Result = res
	return ec.marshalNStartMatchError2githubcomMorhafAlshiblycoandainternalbffmodelStartMatchError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StartMatchResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StartMatchResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StartMatchError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_id(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_type(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Type, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_data(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_expiresAt(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ExpiresAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_expiresAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_completedAt(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_completedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CompletedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_completedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.TaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.TaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.TaskResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal model.TaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.TaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal model.TaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.TaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.TaskError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.TaskError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TaskError)
	fc.Result = res
	return ec.marshalNTaskError2githubcomMorhafAlshiblycoandainternalbffmodelTaskError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TaskError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_id(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_name(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_score(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_score(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Score, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_score(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_ranking(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_ranking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Ranking, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_ranking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_members(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_members(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Members, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal []*api.TeamMember
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.TeamMember
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal []*api.TeamMember
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.TeamMember
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.TeamMember); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.TeamMember`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.TeamMember)
	fc.Result = res
	return ec.marshalNTeamMember2githubcomMorhafAlshiblycoandaapiTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_members(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamMember_id(ctx, field)
			case "userId":
				return ec.fieldContext_TeamMember_userId(ctx, field)
			case "teamId":
				return ec.fieldContext_TeamMember_teamId(ctx, field)
			case "data":
				return ec.fieldContext_TeamMember_data(ctx, field)
			case "joinedAt":
				return ec.fieldContext_TeamMember_joinedAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TeamMember_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_data(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_id(ctx context.Context, field graphql.CollectedField, obj *api.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_userId(ctx context.Context, field graphql.CollectedField, obj *api.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_teamId(ctx context.Context, field graphql.CollectedField, obj *api.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_teamId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TeamId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_teamId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_data(ctx context.Context, field graphql.CollectedField, obj *api.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_joinedAt(ctx context.Context, field graphql.CollectedField, obj *api.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_joinedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.JoinedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_joinedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.TeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.TeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.TeamResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.TeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.TeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.TeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.TeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.TeamError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.TeamError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TeamError)
	fc.Result = res
	return ec.marshalNTeamError2githubcomMorhafAlshiblycoandainternalbffmodelTeamError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TeamError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_id(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_tournament(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_tournament(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tournament, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_tournament(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_userId(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_interval(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_interval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.TournamentUser().Interval(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal graphqlEnums.TournamentInterval
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal graphqlEnums.TournamentInterval
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal graphqlEnums.TournamentInterval
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal graphqlEnums.TournamentInterval
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(graphqlEnums.TournamentInterval); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/pkg/graphqlEnums.TournamentInterval`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(graphqlEnums.TournamentInterval)
	fc.Result = res
	return ec.marshalNTournamentInterval2githubcomMorhafAlshiblycoandapkggraphqlEnumsTournamentInterval(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_interval(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TournamentInterval does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_score(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_score(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Score, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_score(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_ranking(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_ranking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Ranking, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_ranking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_data(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_tournamentStartedAt(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_tournamentStartedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TournamentStartedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_tournamentStartedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.TournamentUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal model.TournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.TournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal model.TournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.TournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.TournamentUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.TournamentUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TournamentUserError)
	fc.Result = res
	return ec.marshalNTournamentUserError2githubcomMorhafAlshiblycoandainternalbffmodelTournamentUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TournamentUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateArenaResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateArenaResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateArenaResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateArenaResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateArenaResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateArenaResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateArenaResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateArenaError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateArenaError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateArenaError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateArenaError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateArenaError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateArenaError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateArenaError)
	fc.Result = res
	return ec.marshalNUpdateArenaError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateArenaError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateArenaResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateArenaResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateArenaError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEventResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEventResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEventResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEventResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEventResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateEventResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.UpdateEventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateEventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.UpdateEventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateEventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateEventError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateEventError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateEventError)
	fc.Result = res
	return ec.marshalNUpdateEventError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateEventError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEventResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEventResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateEventError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEventRoundResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEventRoundResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEventRoundResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEventRoundResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEventRoundResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEventRoundResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateEventRoundResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.UpdateEventRoundError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateEventRoundError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.UpdateEventRoundError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateEventRoundError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateEventRoundError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateEventRoundError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateEventRoundError)
	fc.Result = res
	return ec.marshalNUpdateEventRoundError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateEventRoundError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEventRoundResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEventRoundResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateEventRoundError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEventUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateEventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEventUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEventUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEventUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEventUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateEventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEventUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateEventUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.UpdateEventUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateEventUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Event")
			if err != nil {
				var zeroVal model.UpdateEventUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateEventUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateEventUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateEventUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateEventUserError)
	fc.Result = res
	return ec.marshalNUpdateEventUserError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateEventUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEventUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEventUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateEventUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateItemResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateItemResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateItemResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateItemResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateItemResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateItemResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateItemResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal model.UpdateItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Item")
			if err != nil {
				var zeroVal model.UpdateItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateItemError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateItemError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateItemError)
	fc.Result = res
	return ec.marshalNUpdateItemError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateItemError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateItemResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateItemResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateItemError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateMatchResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateMatchResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateMatchResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateMatchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateMatchResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateMatchResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateMatchResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateMatchError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateMatchError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateMatchError)
	fc.Result = res
	return ec.marshalNUpdateMatchError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateMatchError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateMatchResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateMatchResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateMatchError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateMatchmakingTicketResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateMatchmakingTicketResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateMatchmakingTicketResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateMatchmakingTicketResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateMatchmakingTicketResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateMatchmakingTicketResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateMatchmakingTicketError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateMatchmakingTicketError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateMatchmakingTicketError)
	fc.Result = res
	return ec.marshalNUpdateMatchmakingTicketError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateMatchmakingTicketError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateMatchmakingTicketResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateMatchmakingTicketError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateMatchmakingUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateMatchmakingUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateMatchmakingUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateMatchmakingUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateMatchmakingUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateMatchmakingUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateMatchmakingUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateMatchmakingUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateMatchmakingUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateMatchmakingUserError)
	fc.Result = res
	return ec.marshalNUpdateMatchmakingUserError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateMatchmakingUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateMatchmakingUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateMatchmakingUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateMatchmakingUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateRecordResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateRecordResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateRecordResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateRecordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateRecordResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateRecordResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateRecordResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal model.UpdateRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Record")
			if err != nil {
				var zeroVal model.UpdateRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateRecordError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateRecordError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateRecordError)
	fc.Result = res
	return ec.marshalNUpdateRecordError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateRecordError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateRecordResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateRecordResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateRecordError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTaskResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTaskResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTaskResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTaskResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTaskResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTaskResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateTaskResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal model.UpdateTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Task")
			if err != nil {
				var zeroVal model.UpdateTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateTaskError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateTaskError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateTaskError)
	fc.Result = res
	return ec.marshalNUpdateTaskError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateTaskError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTaskResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTaskResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateTaskError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamMemberResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTeamMemberResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamMemberResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamMemberResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamMemberResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamMemberResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTeamMemberResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamMemberResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateTeamMemberResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.UpdateTeamMemberError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTeamMemberError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.UpdateTeamMemberError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTeamMemberError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateTeamMemberError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateTeamMemberError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateTeamMemberError)
	fc.Result = res
	return ec.marshalNUpdateTeamMemberError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateTeamMemberError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamMemberResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamMemberResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateTeamMemberError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateTeamResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.UpdateTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Team")
			if err != nil {
				var zeroVal model.UpdateTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateTeamError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateTeamError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateTeamError)
	fc.Result = res
	return ec.marshalNUpdateTeamError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateTeamError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateTeamError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTournamentUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTournamentUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTournamentUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTournamentUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTournamentUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTournamentUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateTournamentUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal model.UpdateTournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Tournament")
			if err != nil {
				var zeroVal model.UpdateTournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateTournamentUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateTournamentUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateTournamentUserError)
	fc.Result = res
	return ec.marshalNUpdateTournamentUserError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateTournamentUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTournamentUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTournamentUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateTournamentUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookResponse_status(ctx context.Context, field graphql.CollectedField, obj *api.WebhookResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Status, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Webhook")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint32); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookResponse_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookResponse_headers(ctx context.Context, field graphql.CollectedField, obj *api.WebhookResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookResponse_headers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Headers, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Webhook")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookResponse_headers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookResponse_body(ctx context.Context, field graphql.CollectedField, obj *api.WebhookResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookResponse_body(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Body, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2string(ctx, "Webhook")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookResponse_body(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddEventResultRequest(ctx context.Context, obj any) (api.AddEventResultRequest, error) {
	var it api.AddEventResultRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"event", "clientUserId", "result", "userData", "roundUserData"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventRequest2githubcomMorhafAlshiblycoandaapiEventRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRequest); ok {
				it.Event = data
			} else if tmp == nil {
				it.Event = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUserId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.ClientUserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "result":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("result"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.Result = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userData":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userData"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.UserData = data
			} else if tmp == nil {
				it.UserData = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "roundUserData":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roundUserData"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.RoundUserData = data
			} else if tmp == nil {
				it.RoundUserData = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArenaRequest(ctx context.Context, obj any) (api.ArenaRequest, error) {
	var it api.ArenaRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateArenaRequest(ctx context.Context, obj any) (api.CreateArenaRequest, error) {
	var it api.CreateArenaRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "minPlayers", "maxPlayersPerTicket", "maxPlayers", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "minPlayers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minPlayers"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint322uint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint32); ok {
				it.MinPlayers = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "maxPlayersPerTicket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPlayersPerTicket"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint322uint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint32); ok {
				it.MaxPlayersPerTicket = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "maxPlayers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPlayers"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint322uint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint32); ok {
				it.MaxPlayers = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEventRequest(ctx context.Context, obj any) (api.CreateEventRequest, error) {
	var it api.CreateEventRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "data", "startedAt", "rounds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "startedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startedAt"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Example == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive example is not implemented")
				}
				return ec.directives.Example(ctx, obj, directive1, value)
			}
			directive3 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive2, category)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*timestamppb.Timestamp); ok {
				it.StartedAt = data
			} else if tmp == nil {
				it.StartedAt = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "rounds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rounds"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNCreateEventRound2githubcomMorhafAlshiblycoandaapiCreateEventRound(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal []*api.CreateEventRound
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*api.CreateEventRound
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal []*api.CreateEventRound
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*api.CreateEventRound
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*api.CreateEventRound); ok {
				it.Rounds = data
			} else if tmp == nil {
				it.Rounds = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.CreateEventRound`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEventRound(ctx context.Context, obj any) (api.CreateEventRound, error) {
	var it api.CreateEventRound
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "data", "endedAt", "scoring"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "endedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endedAt"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Example == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive example is not implemented")
				}
				return ec.directives.Example(ctx, obj, directive1, value)
			}
			directive3 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive2, category)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*timestamppb.Timestamp); ok {
				it.EndedAt = data
			} else if tmp == nil {
				it.EndedAt = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "scoring":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoring"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal []uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal []uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]uint64); ok {
				it.Scoring = data
			} else if tmp == nil {
				it.Scoring = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEventRoundRequest(ctx context.Context, obj any) (api.CreateEventRoundRequest, error) {
	var it api.CreateEventRoundRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"event", "round"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventRequest2githubcomMorhafAlshiblycoandaapiEventRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRequest); ok {
				it.Event = data
			} else if tmp == nil {
				it.Event = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "round":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("round"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNCreateEventRound2githubcomMorhafAlshiblycoandaapiCreateEventRound(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.CreateEventRound
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.CreateEventRound
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.CreateEventRound
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.CreateEventRound
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.CreateEventRound); ok {
				it.Round = data
			} else if tmp == nil {
				it.Round = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateEventRound`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateItemRequest(ctx context.Context, obj any) (api.CreateItemRequest, error) {
	var it api.CreateItemRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "type", "data", "expiresAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNID2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Item")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Id = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Item")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Type = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Item")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Example == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive example is not implemented")
				}
				return ec.directives.Example(ctx, obj, directive1, value)
			}
			directive3 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Item")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive2, category)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*timestamppb.Timestamp); ok {
				it.ExpiresAt = data
			} else if tmp == nil {
				it.ExpiresAt = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMatchmakingTicketRequest(ctx context.Context, obj any) (api.CreateMatchmakingTicketRequest, error) {
	var it api.CreateMatchmakingTicketRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchmakingUsers", "arenas", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchmakingUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingUsers"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiMatchmakingUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*api.MatchmakingUserRequest); ok {
				it.MatchmakingUsers = data
			} else if tmp == nil {
				it.MatchmakingUsers = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.MatchmakingUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "arenas":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arenas"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNArenaRequest2githubcomMorhafAlshiblycoandaapiArenaRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*api.ArenaRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*api.ArenaRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*api.ArenaRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*api.ArenaRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*api.ArenaRequest); ok {
				it.Arenas = data
			} else if tmp == nil {
				it.Arenas = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.ArenaRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMatchmakingUserRequest(ctx context.Context, obj any) (api.CreateMatchmakingUserRequest, error) {
	var it api.CreateMatchmakingUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientUserId", "elo", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUserId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.ClientUserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "elo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("elo"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNInt642int64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int64); ok {
				it.Elo = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRecordRequest(ctx context.Context, obj any) (api.CreateRecordRequest, error) {
	var it api.CreateRecordRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "userId", "record", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.UserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "record":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("record"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.Record = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTaskRequest(ctx context.Context, obj any) (api.CreateTaskRequest, error) {
	var it api.CreateTaskRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "type", "data", "expiresAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNID2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Task")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Id = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Task")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Type = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Task")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Example == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive example is not implemented")
				}
				return ec.directives.Example(ctx, obj, directive1, value)
			}
			directive3 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Task")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive2, category)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*timestamppb.Timestamp); ok {
				it.ExpiresAt = data
			} else if tmp == nil {
				it.ExpiresAt = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTeamRequest(ctx context.Context, obj any) (api.CreateTeamRequest, error) {
	var it api.CreateTeamRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "score", "firstMemberUserId", "data", "firstMemberData"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "score":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOInt642int64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int64); ok {
				it.Score = data
			} else if tmp == nil {
				it.Score = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "firstMemberUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstMemberUserId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.FirstMemberUserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "firstMemberData":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstMemberData"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.FirstMemberData = data
			} else if tmp == nil {
				it.FirstMemberData = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTournamentUserRequest(ctx context.Context, obj any) (api.CreateTournamentUserRequest, error) {
	var it api.CreateTournamentUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tournament", "interval", "userId", "score", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tournament":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tournament"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Tournament = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "interval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interval"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTournamentInterval2githubcomMorhafAlshiblycoandapkggraphqlEnumsTournamentInterval(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(graphqlEnums.TournamentInterval); ok {
				if err = ec.resolvers.CreateTournamentUserRequest().Interval(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/pkg/graphqlEnums.TournamentInterval`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.UserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "score":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOInt642int64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int64); ok {
				it.Score = data
			} else if tmp == nil {
				it.Score = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEndMatchRequest(ctx context.Context, obj any) (api.EndMatchRequest, error) {
	var it api.EndMatchRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"match", "endTime"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "match":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("match"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchRequest2githubcomMorhafAlshiblycoandaapiMatchRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchRequest); ok {
				it.Match = data
			} else if tmp == nil {
				it.Match = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "endTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endTime"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Example == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive example is not implemented")
				}
				return ec.directives.Example(ctx, obj, directive1, value)
			}
			directive3 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive2, category)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*timestamppb.Timestamp); ok {
				it.EndTime = data
			} else if tmp == nil {
				it.EndTime = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventRequest(ctx context.Context, obj any) (api.EventRequest, error) {
	var it api.EventRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventRoundRequest(ctx context.Context, obj any) (api.EventRoundRequest, error) {
	var it api.EventRoundRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "event", "roundName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOEventRequest2githubcomMorhafAlshiblycoandaapiEventRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRequest); ok {
				it.Event = data
			} else if tmp == nil {
				it.Event = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "roundName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roundName"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.RoundName = data
			} else if tmp == nil {
				it.RoundName = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventRoundUserRequest(ctx context.Context, obj any) (api.EventRoundUserRequest, error) {
	var it api.EventRoundUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.Id = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventUserRequest(ctx context.Context, obj any) (api.EventUserRequest, error) {
	var it api.EventUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "event", "clientUserId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOEventRequest2githubcomMorhafAlshiblycoandaapiEventRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRequest); ok {
				it.Event = data
			} else if tmp == nil {
				it.Event = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUserId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.ClientUserId = data
			} else if tmp == nil {
				it.ClientUserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetEventRequest(ctx context.Context, obj any) (api.GetEventRequest, error) {
	var it api.GetEventRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"event", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventRequest2githubcomMorhafAlshiblycoandaapiEventRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRequest); ok {
				it.Event = data
			} else if tmp == nil {
				it.Event = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetEventRoundRequest(ctx context.Context, obj any) (api.GetEventRoundRequest, error) {
	var it api.GetEventRoundRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"round", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "round":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("round"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventRoundRequest2githubcomMorhafAlshiblycoandaapiEventRoundRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRoundRequest); ok {
				it.Round = data
			} else if tmp == nil {
				it.Round = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRoundRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetEventUserRequest(ctx context.Context, obj any) (api.GetEventUserRequest, error) {
	var it api.GetEventUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"user", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "user":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventUserRequest2githubcomMorhafAlshiblycoandaapiEventUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventUserRequest); ok {
				it.User = data
			} else if tmp == nil {
				it.User = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetItemsRequest(ctx context.Context, obj any) (api.GetItemsRequest, error) {
	var it api.GetItemsRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Item")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Type = data
			} else if tmp == nil {
				it.Type = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Item")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetMatchRequest(ctx context.Context, obj any) (api.GetMatchRequest, error) {
	var it api.GetMatchRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"match", "ticketPagination", "userPagination", "arenaPagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "match":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("match"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchRequest2githubcomMorhafAlshiblycoandaapiMatchRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchRequest); ok {
				it.Match = data
			} else if tmp == nil {
				it.Match = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "ticketPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.TicketPagination = data
			} else if tmp == nil {
				it.TicketPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.UserPagination = data
			} else if tmp == nil {
				it.UserPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "arenaPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arenaPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.ArenaPagination = data
			} else if tmp == nil {
				it.ArenaPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetMatchesRequest(ctx context.Context, obj any) (api.GetMatchesRequest, error) {
	var it api.GetMatchesRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"arena", "matchmakingUser", "statuses", "pagination", "ticketPagination", "userPagination", "arenaPagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "arena":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arena"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOArenaRequest2githubcomMorhafAlshiblycoandaapiArenaRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.ArenaRequest); ok {
				it.Arena = data
			} else if tmp == nil {
				it.Arena = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.ArenaRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "matchmakingUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingUser"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiMatchmakingUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingUserRequest); ok {
				it.MatchmakingUser = data
			} else if tmp == nil {
				it.MatchmakingUser = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMatchStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchStatus(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*model.MatchStatus
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*model.MatchStatus
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*model.MatchStatus
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*model.MatchStatus
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.MatchStatus); ok {
				if err = ec.resolvers.GetMatchesRequest().Statuses(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/internal/bff/model.MatchStatus`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "ticketPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.TicketPagination = data
			} else if tmp == nil {
				it.TicketPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.UserPagination = data
			} else if tmp == nil {
				it.UserPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "arenaPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arenaPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.ArenaPagination = data
			} else if tmp == nil {
				it.ArenaPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetMatchmakingTicketRequest(ctx context.Context, obj any) (api.GetMatchmakingTicketRequest, error) {
	var it api.GetMatchmakingTicketRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchmakingTicket", "userPagination", "arenaPagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchmakingTicket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingTicket"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchmakingTicketRequest2githubcomMorhafAlshiblycoandaapiMatchmakingTicketRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingTicketRequest); ok {
				it.MatchmakingTicket = data
			} else if tmp == nil {
				it.MatchmakingTicket = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingTicketRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.UserPagination = data
			} else if tmp == nil {
				it.UserPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "arenaPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arenaPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.ArenaPagination = data
			} else if tmp == nil {
				it.ArenaPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetMatchmakingTicketsRequest(ctx context.Context, obj any) (api.GetMatchmakingTicketsRequest, error) {
	var it api.GetMatchmakingTicketsRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchId", "matchmakingUser", "statuses", "pagination", "userPagination", "arenaPagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.MatchId = data
			} else if tmp == nil {
				it.MatchId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "matchmakingUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingUser"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiMatchmakingUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingUserRequest); ok {
				it.MatchmakingUser = data
			} else if tmp == nil {
				it.MatchmakingUser = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMatchmakingTicketStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchmakingTicketStatus(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*model.MatchmakingTicketStatus
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*model.MatchmakingTicketStatus
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*model.MatchmakingTicketStatus
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*model.MatchmakingTicketStatus
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.MatchmakingTicketStatus); ok {
				if err = ec.resolvers.GetMatchmakingTicketsRequest().Statuses(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/internal/bff/model.MatchmakingTicketStatus`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.UserPagination = data
			} else if tmp == nil {
				it.UserPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "arenaPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arenaPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.ArenaPagination = data
			} else if tmp == nil {
				it.ArenaPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetRecordsRequest(ctx context.Context, obj any) (api.GetRecordsRequest, error) {
	var it api.GetRecordsRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "userId", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.UserId = data
			} else if tmp == nil {
				it.UserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetTasksRequest(ctx context.Context, obj any) (api.GetTasksRequest, error) {
	var it api.GetTasksRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "completed", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Task")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Type = data
			} else if tmp == nil {
				it.Type = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "completed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("completed"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOBoolean2bool(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Task")
				if err != nil {
					var zeroVal *bool
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *bool
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*bool); ok {
				it.Completed = data
			} else if tmp == nil {
				it.Completed = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Task")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetTeamRequest(ctx context.Context, obj any) (api.GetTeamRequest, error) {
	var it api.GetTeamRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"team", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTeamRequest2githubcomMorhafAlshiblycoandaapiTeamRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TeamRequest); ok {
				it.Team = data
			} else if tmp == nil {
				it.Team = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetTeamsRequest(ctx context.Context, obj any) (api.GetTeamsRequest, error) {
	var it api.GetTeamsRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"pagination", "memberPagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "memberPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memberPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.MemberPagination = data
			} else if tmp == nil {
				it.MemberPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetTournamentUsersRequest(ctx context.Context, obj any) (api.GetTournamentUsersRequest, error) {
	var it api.GetTournamentUsersRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tournament", "interval", "userId", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tournament":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tournament"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Tournament = data
			} else if tmp == nil {
				it.Tournament = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "interval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interval"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTournamentInterval2githubcomMorhafAlshiblycoandapkggraphqlEnumsTournamentInterval(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(graphqlEnums.TournamentInterval); ok {
				if err = ec.resolvers.GetTournamentUsersRequest().Interval(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/pkg/graphqlEnums.TournamentInterval`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.UserId = data
			} else if tmp == nil {
				it.UserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputItemRequest(ctx context.Context, obj any) (api.ItemRequest, error) {
	var it api.ItemRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNID2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Item")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Id = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Item")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Type = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJoinTeamRequest(ctx context.Context, obj any) (api.JoinTeamRequest, error) {
	var it api.JoinTeamRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"team", "userId", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTeamRequest2githubcomMorhafAlshiblycoandaapiTeamRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TeamRequest); ok {
				it.Team = data
			} else if tmp == nil {
				it.Team = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.UserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchRequest(ctx context.Context, obj any) (api.MatchRequest, error) {
	var it api.MatchRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "matchmakingTicket"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "matchmakingTicket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingTicket"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMatchmakingTicketRequest2githubcomMorhafAlshiblycoandaapiMatchmakingTicketRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingTicketRequest); ok {
				it.MatchmakingTicket = data
			} else if tmp == nil {
				it.MatchmakingTicket = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingTicketRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchmakingTicketRequest(ctx context.Context, obj any) (api.MatchmakingTicketRequest, error) {
	var it api.MatchmakingTicketRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "matchmakingUser"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "matchmakingUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingUser"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiMatchmakingUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingUserRequest); ok {
				it.MatchmakingUser = data
			} else if tmp == nil {
				it.MatchmakingUser = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchmakingUserRequest(ctx context.Context, obj any) (api.MatchmakingUserRequest, error) {
	var it api.MatchmakingUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "clientUserId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUserId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.ClientUserId = data
			} else if tmp == nil {
				it.ClientUserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNameUserId(ctx context.Context, obj any) (api.NameUserId, error) {
	var it api.NameUserId
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.UserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPagination(ctx context.Context, obj any) (api.Pagination, error) {
	var it api.Pagination
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"max", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "max":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint322uint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint32); ok {
				it.Max = data
			} else if tmp == nil {
				it.Max = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Page = data
			} else if tmp == nil {
				it.Page = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRecordRequest(ctx context.Context, obj any) (api.RecordRequest, error) {
	var it api.RecordRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "nameUserId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "nameUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameUserId"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalONameUserId2githubcomMorhafAlshiblycoandaapiNameUserId(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal *api.NameUserId
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.NameUserId
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal *api.NameUserId
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.NameUserId
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.NameUserId); ok {
				it.NameUserId = data
			} else if tmp == nil {
				it.NameUserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.NameUserId`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchTeamsRequest(ctx context.Context, obj any) (api.SearchTeamsRequest, error) {
	var it api.SearchTeamsRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"query", "pagination", "memberPagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "query":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Query = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "memberPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memberPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.MemberPagination = data
			} else if tmp == nil {
				it.MemberPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSetMatchPrivateServerRequest(ctx context.Context, obj any) (api.SetMatchPrivateServerRequest, error) {
	var it api.SetMatchPrivateServerRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"match", "privateServerId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "match":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("match"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchRequest2githubcomMorhafAlshiblycoandaapiMatchRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchRequest); ok {
				it.Match = data
			} else if tmp == nil {
				it.Match = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "privateServerId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("privateServerId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.PrivateServerId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStartMatchRequest(ctx context.Context, obj any) (api.StartMatchRequest, error) {
	var it api.StartMatchRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"match", "startTime"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "match":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("match"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchRequest2githubcomMorhafAlshiblycoandaapiMatchRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchRequest); ok {
				it.Match = data
			} else if tmp == nil {
				it.Match = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "startTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startTime"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				value, err := ec.unmarshalOString2string(ctx, "2023-10-01T12:00:00Z")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Example == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive example is not implemented")
				}
				return ec.directives.Example(ctx, obj, directive1, value)
			}
			directive3 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive2, category)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*timestamppb.Timestamp); ok {
				it.StartTime = data
			} else if tmp == nil {
				it.StartTime = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskRequest(ctx context.Context, obj any) (api.TaskRequest, error) {
	var it api.TaskRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNID2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Task")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Id = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Task")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Type = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamMemberRequest(ctx context.Context, obj any) (api.TeamMemberRequest, error) {
	var it api.TeamMemberRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.UserId = data
			} else if tmp == nil {
				it.UserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamRequest(ctx context.Context, obj any) (api.TeamRequest, error) {
	var it api.TeamRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "member"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "member":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("member"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOTeamMemberRequest2githubcomMorhafAlshiblycoandaapiTeamMemberRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TeamMemberRequest); ok {
				it.Member = data
			} else if tmp == nil {
				it.Member = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamMemberRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTournamentIntervalUserId(ctx context.Context, obj any) (api.TournamentIntervalUserId, error) {
	var it api.TournamentIntervalUserId
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tournament", "interval", "userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tournament":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tournament"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Tournament = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "interval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interval"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTournamentInterval2githubcomMorhafAlshiblycoandapkggraphqlEnumsTournamentInterval(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(graphqlEnums.TournamentInterval); ok {
				if err = ec.resolvers.TournamentIntervalUserId().Interval(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/pkg/graphqlEnums.TournamentInterval`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.UserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTournamentUserRequest(ctx context.Context, obj any) (api.TournamentUserRequest, error) {
	var it api.TournamentUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "tournamentIntervalUserId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "tournamentIntervalUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tournamentIntervalUserId"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOTournamentIntervalUserId2githubcomMorhafAlshiblycoandaapiTournamentIntervalUserId(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *api.TournamentIntervalUserId
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TournamentIntervalUserId
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *api.TournamentIntervalUserId
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TournamentIntervalUserId
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TournamentIntervalUserId); ok {
				it.TournamentIntervalUserId = data
			} else if tmp == nil {
				it.TournamentIntervalUserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TournamentIntervalUserId`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateArenaRequest(ctx context.Context, obj any) (api.UpdateArenaRequest, error) {
	var it api.UpdateArenaRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"arena", "minPlayers", "maxPlayersPerTicket", "maxPlayers", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "arena":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arena"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNArenaRequest2githubcomMorhafAlshiblycoandaapiArenaRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.ArenaRequest); ok {
				it.Arena = data
			} else if tmp == nil {
				it.Arena = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.ArenaRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "minPlayers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minPlayers"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint322uint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint32); ok {
				it.MinPlayers = data
			} else if tmp == nil {
				it.MinPlayers = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "maxPlayersPerTicket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPlayersPerTicket"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint322uint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint32); ok {
				it.MaxPlayersPerTicket = data
			} else if tmp == nil {
				it.MaxPlayersPerTicket = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "maxPlayers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPlayers"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint322uint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint32); ok {
				it.MaxPlayers = data
			} else if tmp == nil {
				it.MaxPlayers = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventRequest(ctx context.Context, obj any) (api.UpdateEventRequest, error) {
	var it api.UpdateEventRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"event", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventRequest2githubcomMorhafAlshiblycoandaapiEventRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRequest); ok {
				it.Event = data
			} else if tmp == nil {
				it.Event = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventRoundRequest(ctx context.Context, obj any) (api.UpdateEventRoundRequest, error) {
	var it api.UpdateEventRoundRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"round", "data", "scoring"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "round":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("round"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventRoundRequest2githubcomMorhafAlshiblycoandaapiEventRoundRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRoundRequest); ok {
				it.Round = data
			} else if tmp == nil {
				it.Round = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRoundRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "scoring":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoring"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal []uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal []uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]uint64); ok {
				it.Scoring = data
			} else if tmp == nil {
				it.Scoring = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventUserRequest(ctx context.Context, obj any) (api.UpdateEventUserRequest, error) {
	var it api.UpdateEventUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"user", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "user":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventUserRequest2githubcomMorhafAlshiblycoandaapiEventUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventUserRequest); ok {
				it.User = data
			} else if tmp == nil {
				it.User = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateItemRequest(ctx context.Context, obj any) (api.UpdateItemRequest, error) {
	var it api.UpdateItemRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"item", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "item":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("item"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNItemRequest2githubcomMorhafAlshiblycoandaapiItemRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Item")
				if err != nil {
					var zeroVal *api.ItemRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.ItemRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Item")
				if err != nil {
					var zeroVal *api.ItemRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.ItemRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.ItemRequest); ok {
				it.Item = data
			} else if tmp == nil {
				it.Item = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.ItemRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Item")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchRequest(ctx context.Context, obj any) (api.UpdateMatchRequest, error) {
	var it api.UpdateMatchRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"match", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "match":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("match"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchRequest2githubcomMorhafAlshiblycoandaapiMatchRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchRequest); ok {
				it.Match = data
			} else if tmp == nil {
				it.Match = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchmakingTicketRequest(ctx context.Context, obj any) (api.UpdateMatchmakingTicketRequest, error) {
	var it api.UpdateMatchmakingTicketRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchmakingTicket", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchmakingTicket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingTicket"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchmakingTicketRequest2githubcomMorhafAlshiblycoandaapiMatchmakingTicketRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingTicketRequest); ok {
				it.MatchmakingTicket = data
			} else if tmp == nil {
				it.MatchmakingTicket = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingTicketRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchmakingUserRequest(ctx context.Context, obj any) (api.UpdateMatchmakingUserRequest, error) {
	var it api.UpdateMatchmakingUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchmakingUser", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchmakingUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingUser"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiMatchmakingUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingUserRequest); ok {
				it.MatchmakingUser = data
			} else if tmp == nil {
				it.MatchmakingUser = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateRecordRequest(ctx context.Context, obj any) (api.UpdateRecordRequest, error) {
	var it api.UpdateRecordRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"request", "record", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "request":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("request"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNRecordRequest2githubcomMorhafAlshiblycoandaapiRecordRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal *api.RecordRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.RecordRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal *api.RecordRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.RecordRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.RecordRequest); ok {
				it.Request = data
			} else if tmp == nil {
				it.Request = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.RecordRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "record":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("record"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Record = data
			} else if tmp == nil {
				it.Record = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Record")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTaskRequest(ctx context.Context, obj any) (api.UpdateTaskRequest, error) {
	var it api.UpdateTaskRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"task", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "task":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("task"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTaskRequest2githubcomMorhafAlshiblycoandaapiTaskRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Task")
				if err != nil {
					var zeroVal *api.TaskRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TaskRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Task")
				if err != nil {
					var zeroVal *api.TaskRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TaskRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TaskRequest); ok {
				it.Task = data
			} else if tmp == nil {
				it.Task = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TaskRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Task")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTeamMemberRequest(ctx context.Context, obj any) (api.UpdateTeamMemberRequest, error) {
	var it api.UpdateTeamMemberRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"member", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "member":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("member"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTeamMemberRequest2githubcomMorhafAlshiblycoandaapiTeamMemberRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TeamMemberRequest); ok {
				it.Member = data
			} else if tmp == nil {
				it.Member = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamMemberRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTeamRequest(ctx context.Context, obj any) (api.UpdateTeamRequest, error) {
	var it api.UpdateTeamRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"team", "data", "score", "incrementScore"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTeamRequest2githubcomMorhafAlshiblycoandaapiTeamRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TeamRequest); ok {
				it.Team = data
			} else if tmp == nil {
				it.Team = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "score":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOInt642int64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int64); ok {
				it.Score = data
			} else if tmp == nil {
				it.Score = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "incrementScore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("incrementScore"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOBoolean2bool(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Team")
				if err != nil {
					var zeroVal *bool
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *bool
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*bool); ok {
				it.IncrementScore = data
			} else if tmp == nil {
				it.IncrementScore = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTournamentUserRequest(ctx context.Context, obj any) (api.UpdateTournamentUserRequest, error) {
	var it api.UpdateTournamentUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tournament", "data", "score", "incrementScore"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tournament":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tournament"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTournamentUserRequest2githubcomMorhafAlshiblycoandaapiTournamentUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *api.TournamentUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TournamentUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *api.TournamentUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TournamentUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TournamentUserRequest); ok {
				it.Tournament = data
			} else if tmp == nil {
				it.Tournament = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TournamentUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "score":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOInt642int64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int64); ok {
				it.Score = data
			} else if tmp == nil {
				it.Score = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "incrementScore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("incrementScore"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOBoolean2bool(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Tournament")
				if err != nil {
					var zeroVal *bool
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *bool
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*bool); ok {
				it.IncrementScore = data
			} else if tmp == nil {
				it.IncrementScore = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookRequest(ctx context.Context, obj any) (api.WebhookRequest, error) {
	var it api.WebhookRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"uri", "method", "headers", "body"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "uri":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uri"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Webhook")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Uri = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "method":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("method"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Webhook")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Method = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "headers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("headers"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Webhook")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Headers = data
			} else if tmp == nil {
				it.Headers = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "body":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("body"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2string(ctx, "Webhook")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Body = data
			} else if tmp == nil {
				it.Body = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var addEventResultResponseImplementors = []string{"AddEventResultResponse"}

func (ec *executionContext) _AddEventResultResponse(ctx context.Context, sel ast.SelectionSet, obj *api.AddEventResultResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addEventResultResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddEventResultResponse")
		case "success":
			out.Values[i] = ec._AddEventResultResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AddEventResultResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var arenaImplementors = []string{"Arena"}

func (ec *executionContext) _Arena(ctx context.Context, sel ast.SelectionSet, obj *api.Arena) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, arenaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Arena")
		case "id":
			out.Values[i] = ec._Arena_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Arena_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minPlayers":
			out.Values[i] = ec._Arena_minPlayers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxPlayersPerTicket":
			out.Values[i] = ec._Arena_maxPlayersPerTicket(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxPlayers":
			out.Values[i] = ec._Arena_maxPlayers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._Arena_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Arena_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Arena_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var completeTaskResponseImplementors = []string{"CompleteTaskResponse"}

func (ec *executionContext) _CompleteTaskResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CompleteTaskResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, completeTaskResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompleteTaskResponse")
		case "success":
			out.Values[i] = ec._CompleteTaskResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompleteTaskResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createArenaResponseImplementors = []string{"CreateArenaResponse"}

func (ec *executionContext) _CreateArenaResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateArenaResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createArenaResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateArenaResponse")
		case "success":
			out.Values[i] = ec._CreateArenaResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateArenaResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateArenaResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createEventResponseImplementors = []string{"CreateEventResponse"}

func (ec *executionContext) _CreateEventResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateEventResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createEventResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateEventResponse")
		case "success":
			out.Values[i] = ec._CreateEventResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateEventResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateEventResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createEventRoundResponseImplementors = []string{"CreateEventRoundResponse"}

func (ec *executionContext) _CreateEventRoundResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateEventRoundResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createEventRoundResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateEventRoundResponse")
		case "success":
			out.Values[i] = ec._CreateEventRoundResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateEventRoundResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateEventRoundResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createItemResponseImplementors = []string{"CreateItemResponse"}

func (ec *executionContext) _CreateItemResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateItemResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createItemResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateItemResponse")
		case "success":
			out.Values[i] = ec._CreateItemResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateItemResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createMatchmakingTicketResponseImplementors = []string{"CreateMatchmakingTicketResponse"}

func (ec *executionContext) _CreateMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateMatchmakingTicketResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createMatchmakingTicketResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateMatchmakingTicketResponse")
		case "success":
			out.Values[i] = ec._CreateMatchmakingTicketResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateMatchmakingTicketResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateMatchmakingTicketResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createMatchmakingUserResponseImplementors = []string{"CreateMatchmakingUserResponse"}

func (ec *executionContext) _CreateMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateMatchmakingUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createMatchmakingUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateMatchmakingUserResponse")
		case "success":
			out.Values[i] = ec._CreateMatchmakingUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateMatchmakingUserResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateMatchmakingUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createRecordResponseImplementors = []string{"CreateRecordResponse"}

func (ec *executionContext) _CreateRecordResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateRecordResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createRecordResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateRecordResponse")
		case "success":
			out.Values[i] = ec._CreateRecordResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateRecordResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateRecordResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createTaskResponseImplementors = []string{"CreateTaskResponse"}

func (ec *executionContext) _CreateTaskResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateTaskResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createTaskResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateTaskResponse")
		case "success":
			out.Values[i] = ec._CreateTaskResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateTaskResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createTeamResponseImplementors = []string{"CreateTeamResponse"}

func (ec *executionContext) _CreateTeamResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateTeamResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createTeamResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateTeamResponse")
		case "success":
			out.Values[i] = ec._CreateTeamResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateTeamResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateTeamResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createTournamentUserResponseImplementors = []string{"CreateTournamentUserResponse"}

func (ec *executionContext) _CreateTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateTournamentUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createTournamentUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateTournamentUserResponse")
		case "success":
			out.Values[i] = ec._CreateTournamentUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateTournamentUserResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateTournamentUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteMatchResponseImplementors = []string{"DeleteMatchResponse"}

func (ec *executionContext) _DeleteMatchResponse(ctx context.Context, sel ast.SelectionSet, obj *api.DeleteMatchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteMatchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteMatchResponse")
		case "success":
			out.Values[i] = ec._DeleteMatchResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteMatchResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteMatchmakingTicketResponseImplementors = []string{"DeleteMatchmakingTicketResponse"}

func (ec *executionContext) _DeleteMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, obj *api.DeleteMatchmakingTicketResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteMatchmakingTicketResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteMatchmakingTicketResponse")
		case "success":
			out.Values[i] = ec._DeleteMatchmakingTicketResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteMatchmakingTicketResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteMatchmakingUserResponseImplementors = []string{"DeleteMatchmakingUserResponse"}

func (ec *executionContext) _DeleteMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.DeleteMatchmakingUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteMatchmakingUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteMatchmakingUserResponse")
		case "success":
			out.Values[i] = ec._DeleteMatchmakingUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteMatchmakingUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteRecordResponseImplementors = []string{"DeleteRecordResponse"}

func (ec *executionContext) _DeleteRecordResponse(ctx context.Context, sel ast.SelectionSet, obj *api.DeleteRecordResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteRecordResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteRecordResponse")
		case "success":
			out.Values[i] = ec._DeleteRecordResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteRecordResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var endMatchResponseImplementors = []string{"EndMatchResponse"}

func (ec *executionContext) _EndMatchResponse(ctx context.Context, sel ast.SelectionSet, obj *api.EndMatchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, endMatchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EndMatchResponse")
		case "success":
			out.Values[i] = ec._EndMatchResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EndMatchResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventImplementors = []string{"Event"}

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj *api.Event) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Event")
		case "id":
			out.Values[i] = ec._Event_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Event_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentRoundId":
			out.Values[i] = ec._Event_currentRoundId(ctx, field, obj)
		case "currentRoundName":
			out.Values[i] = ec._Event_currentRoundName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._Event_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rounds":
			out.Values[i] = ec._Event_rounds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startedAt":
			out.Values[i] = ec._Event_startedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Event_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Event_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventResponseImplementors = []string{"EventResponse"}

func (ec *executionContext) _EventResponse(ctx context.Context, sel ast.SelectionSet, obj *api.EventResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventResponse")
		case "success":
			out.Values[i] = ec._EventResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EventResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventRoundImplementors = []string{"EventRound"}

func (ec *executionContext) _EventRound(ctx context.Context, sel ast.SelectionSet, obj *api.EventRound) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventRoundImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventRound")
		case "id":
			out.Values[i] = ec._EventRound_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventId":
			out.Values[i] = ec._EventRound_eventId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._EventRound_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scoring":
			out.Values[i] = ec._EventRound_scoring(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._EventRound_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endedAt":
			out.Values[i] = ec._EventRound_endedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._EventRound_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._EventRound_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventRoundUserImplementors = []string{"EventRoundUser"}

func (ec *executionContext) _EventRoundUser(ctx context.Context, sel ast.SelectionSet, obj *api.EventRoundUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventRoundUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventRoundUser")
		case "id":
			out.Values[i] = ec._EventRoundUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventUserId":
			out.Values[i] = ec._EventRoundUser_eventUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clientUserId":
			out.Values[i] = ec._EventRoundUser_clientUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventRoundId":
			out.Values[i] = ec._EventRoundUser_eventRoundId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "result":
			out.Values[i] = ec._EventRoundUser_result(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ranking":
			out.Values[i] = ec._EventRoundUser_ranking(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._EventRoundUser_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._EventRoundUser_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._EventRoundUser_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventUserImplementors = []string{"EventUser"}

func (ec *executionContext) _EventUser(ctx context.Context, sel ast.SelectionSet, obj *api.EventUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventUser")
		case "id":
			out.Values[i] = ec._EventUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventId":
			out.Values[i] = ec._EventUser_eventId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clientUserId":
			out.Values[i] = ec._EventUser_clientUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "score":
			out.Values[i] = ec._EventUser_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ranking":
			out.Values[i] = ec._EventUser_ranking(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._EventUser_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._EventUser_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._EventUser_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventUserResponseImplementors = []string{"EventUserResponse"}

func (ec *executionContext) _EventUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.EventUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventUserResponse")
		case "success":
			out.Values[i] = ec._EventUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EventUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getArenaResponseImplementors = []string{"GetArenaResponse"}

func (ec *executionContext) _GetArenaResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetArenaResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getArenaResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetArenaResponse")
		case "success":
			out.Values[i] = ec._GetArenaResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "arena":
			out.Values[i] = ec._GetArenaResponse_arena(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetArenaResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getArenasResponseImplementors = []string{"GetArenasResponse"}

func (ec *executionContext) _GetArenasResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetArenasResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getArenasResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetArenasResponse")
		case "success":
			out.Values[i] = ec._GetArenasResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "arenas":
			out.Values[i] = ec._GetArenasResponse_arenas(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getEventResponseImplementors = []string{"GetEventResponse"}

func (ec *executionContext) _GetEventResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetEventResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getEventResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetEventResponse")
		case "success":
			out.Values[i] = ec._GetEventResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "event":
			out.Values[i] = ec._GetEventResponse_event(ctx, field, obj)
		case "leaderboard":
			out.Values[i] = ec._GetEventResponse_leaderboard(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetEventResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getEventRoundResponseImplementors = []string{"GetEventRoundResponse"}

func (ec *executionContext) _GetEventRoundResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetEventRoundResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getEventRoundResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetEventRoundResponse")
		case "success":
			out.Values[i] = ec._GetEventRoundResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "round":
			out.Values[i] = ec._GetEventRoundResponse_round(ctx, field, obj)
		case "results":
			out.Values[i] = ec._GetEventRoundResponse_results(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetEventRoundResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getEventUserResponseImplementors = []string{"GetEventUserResponse"}

func (ec *executionContext) _GetEventUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetEventUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getEventUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetEventUserResponse")
		case "success":
			out.Values[i] = ec._GetEventUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			out.Values[i] = ec._GetEventUserResponse_user(ctx, field, obj)
		case "results":
			out.Values[i] = ec._GetEventUserResponse_results(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetEventUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getItemResponseImplementors = []string{"GetItemResponse"}

func (ec *executionContext) _GetItemResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetItemResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getItemResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetItemResponse")
		case "success":
			out.Values[i] = ec._GetItemResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "item":
			out.Values[i] = ec._GetItemResponse_item(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetItemResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getItemsResponseImplementors = []string{"GetItemsResponse"}

func (ec *executionContext) _GetItemsResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetItemsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getItemsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetItemsResponse")
		case "success":
			out.Values[i] = ec._GetItemsResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._GetItemsResponse_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMatchResponseImplementors = []string{"GetMatchResponse"}

func (ec *executionContext) _GetMatchResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetMatchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMatchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMatchResponse")
		case "success":
			out.Values[i] = ec._GetMatchResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "match":
			out.Values[i] = ec._GetMatchResponse_match(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMatchResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMatchesResponseImplementors = []string{"GetMatchesResponse"}

func (ec *executionContext) _GetMatchesResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetMatchesResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMatchesResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMatchesResponse")
		case "success":
			out.Values[i] = ec._GetMatchesResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matches":
			out.Values[i] = ec._GetMatchesResponse_matches(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMatchmakingTicketResponseImplementors = []string{"GetMatchmakingTicketResponse"}

func (ec *executionContext) _GetMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetMatchmakingTicketResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMatchmakingTicketResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMatchmakingTicketResponse")
		case "success":
			out.Values[i] = ec._GetMatchmakingTicketResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchmakingTicket":
			out.Values[i] = ec._GetMatchmakingTicketResponse_matchmakingTicket(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMatchmakingTicketResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMatchmakingTicketsResponseImplementors = []string{"GetMatchmakingTicketsResponse"}

func (ec *executionContext) _GetMatchmakingTicketsResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetMatchmakingTicketsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMatchmakingTicketsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMatchmakingTicketsResponse")
		case "success":
			out.Values[i] = ec._GetMatchmakingTicketsResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchmakingTickets":
			out.Values[i] = ec._GetMatchmakingTicketsResponse_matchmakingTickets(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMatchmakingTicketsResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMatchmakingUserResponseImplementors = []string{"GetMatchmakingUserResponse"}

func (ec *executionContext) _GetMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetMatchmakingUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMatchmakingUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMatchmakingUserResponse")
		case "success":
			out.Values[i] = ec._GetMatchmakingUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchmakingUser":
			out.Values[i] = ec._GetMatchmakingUserResponse_matchmakingUser(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMatchmakingUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMatchmakingUsersResponseImplementors = []string{"GetMatchmakingUsersResponse"}

func (ec *executionContext) _GetMatchmakingUsersResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetMatchmakingUsersResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMatchmakingUsersResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMatchmakingUsersResponse")
		case "success":
			out.Values[i] = ec._GetMatchmakingUsersResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchmakingUsers":
			out.Values[i] = ec._GetMatchmakingUsersResponse_matchmakingUsers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getRecordResponseImplementors = []string{"GetRecordResponse"}

func (ec *executionContext) _GetRecordResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetRecordResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getRecordResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetRecordResponse")
		case "success":
			out.Values[i] = ec._GetRecordResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "record":
			out.Values[i] = ec._GetRecordResponse_record(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetRecordResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getRecordsResponseImplementors = []string{"GetRecordsResponse"}

func (ec *executionContext) _GetRecordsResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetRecordsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getRecordsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetRecordsResponse")
		case "success":
			out.Values[i] = ec._GetRecordsResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "records":
			out.Values[i] = ec._GetRecordsResponse_records(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetRecordsResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTaskResponseImplementors = []string{"GetTaskResponse"}

func (ec *executionContext) _GetTaskResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTaskResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTaskResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTaskResponse")
		case "success":
			out.Values[i] = ec._GetTaskResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "task":
			out.Values[i] = ec._GetTaskResponse_task(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetTaskResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTasksResponseImplementors = []string{"GetTasksResponse"}

func (ec *executionContext) _GetTasksResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTasksResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTasksResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTasksResponse")
		case "success":
			out.Values[i] = ec._GetTasksResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._GetTasksResponse_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTeamMemberResponseImplementors = []string{"GetTeamMemberResponse"}

func (ec *executionContext) _GetTeamMemberResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTeamMemberResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTeamMemberResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTeamMemberResponse")
		case "success":
			out.Values[i] = ec._GetTeamMemberResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "member":
			out.Values[i] = ec._GetTeamMemberResponse_member(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetTeamMemberResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTeamResponseImplementors = []string{"GetTeamResponse"}

func (ec *executionContext) _GetTeamResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTeamResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTeamResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTeamResponse")
		case "success":
			out.Values[i] = ec._GetTeamResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			out.Values[i] = ec._GetTeamResponse_team(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetTeamResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTeamsResponseImplementors = []string{"GetTeamsResponse"}

func (ec *executionContext) _GetTeamsResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTeamsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTeamsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTeamsResponse")
		case "success":
			out.Values[i] = ec._GetTeamsResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teams":
			out.Values[i] = ec._GetTeamsResponse_teams(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTournamentUserResponseImplementors = []string{"GetTournamentUserResponse"}

func (ec *executionContext) _GetTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTournamentUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTournamentUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTournamentUserResponse")
		case "success":
			out.Values[i] = ec._GetTournamentUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tournamentUser":
			out.Values[i] = ec._GetTournamentUserResponse_tournamentUser(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetTournamentUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTournamentUsersResponseImplementors = []string{"GetTournamentUsersResponse"}

func (ec *executionContext) _GetTournamentUsersResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTournamentUsersResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTournamentUsersResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTournamentUsersResponse")
		case "success":
			out.Values[i] = ec._GetTournamentUsersResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tournamentUsers":
			out.Values[i] = ec._GetTournamentUsersResponse_tournamentUsers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetTournamentUsersResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemImplementors = []string{"Item"}

func (ec *executionContext) _Item(ctx context.Context, sel ast.SelectionSet, obj *api.Item) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Item")
		case "id":
			out.Values[i] = ec._Item_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Item_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._Item_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expiresAt":
			out.Values[i] = ec._Item_expiresAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Item_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Item_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemResponseImplementors = []string{"ItemResponse"}

func (ec *executionContext) _ItemResponse(ctx context.Context, sel ast.SelectionSet, obj *api.ItemResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ItemResponse")
		case "success":
			out.Values[i] = ec._ItemResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ItemResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var joinTeamResponseImplementors = []string{"JoinTeamResponse"}

func (ec *executionContext) _JoinTeamResponse(ctx context.Context, sel ast.SelectionSet, obj *api.JoinTeamResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, joinTeamResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JoinTeamResponse")
		case "success":
			out.Values[i] = ec._JoinTeamResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JoinTeamResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var leaveTeamResponseImplementors = []string{"LeaveTeamResponse"}

func (ec *executionContext) _LeaveTeamResponse(ctx context.Context, sel ast.SelectionSet, obj *api.LeaveTeamResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, leaveTeamResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LeaveTeamResponse")
		case "success":
			out.Values[i] = ec._LeaveTeamResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LeaveTeamResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchImplementors = []string{"Match"}

func (ec *executionContext) _Match(ctx context.Context, sel ast.SelectionSet, obj *api.Match) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Match")
		case "id":
			out.Values[i] = ec._Match_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "arena":
			out.Values[i] = ec._Match_arena(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tickets":
			out.Values[i] = ec._Match_tickets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "privateServerId":
			out.Values[i] = ec._Match_privateServerId(ctx, field, obj)
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "data":
			out.Values[i] = ec._Match_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lockedAt":
			out.Values[i] = ec._Match_lockedAt(ctx, field, obj)
		case "startedAt":
			out.Values[i] = ec._Match_startedAt(ctx, field, obj)
		case "endedAt":
			out.Values[i] = ec._Match_endedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Match_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Match_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchmakingTicketImplementors = []string{"MatchmakingTicket"}

func (ec *executionContext) _MatchmakingTicket(ctx context.Context, sel ast.SelectionSet, obj *api.MatchmakingTicket) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchmakingTicketImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchmakingTicket")
		case "id":
			out.Values[i] = ec._MatchmakingTicket_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchmakingUsers":
			out.Values[i] = ec._MatchmakingTicket_matchmakingUsers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "arenas":
			out.Values[i] = ec._MatchmakingTicket_arenas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchId":
			out.Values[i] = ec._MatchmakingTicket_matchId(ctx, field, obj)
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchmakingTicket_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "data":
			out.Values[i] = ec._MatchmakingTicket_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._MatchmakingTicket_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._MatchmakingTicket_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchmakingUserImplementors = []string{"MatchmakingUser"}

func (ec *executionContext) _MatchmakingUser(ctx context.Context, sel ast.SelectionSet, obj *api.MatchmakingUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchmakingUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchmakingUser")
		case "id":
			out.Values[i] = ec._MatchmakingUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clientUserId":
			out.Values[i] = ec._MatchmakingUser_clientUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._MatchmakingUser_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "elo":
			out.Values[i] = ec._MatchmakingUser_elo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._MatchmakingUser_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._MatchmakingUser_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "CreateEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateEventRound":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateEventRound(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateEventRound":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateEventRound(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateEventUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateEventUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteEventUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteEventUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "AddEventResult":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_AddEventResult(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "RemoveEventResult":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_RemoveEventResult(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateArena":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateArena(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateArena":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateArena(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateMatchmakingUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateMatchmakingUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateMatchmakingUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateMatchmakingUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteMatchmakingUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteMatchmakingUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateMatchmakingTicket":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateMatchmakingTicket(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateMatchmakingTicket":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateMatchmakingTicket(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteMatchmakingTicket":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteMatchmakingTicket(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "StartMatch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_StartMatch(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "EndMatch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_EndMatch(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateMatch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateMatch(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "SetMatchPrivateServer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_SetMatchPrivateServer(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteMatch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteMatch(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateRecord":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateRecord(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateRecord":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateRecord(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteRecord":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteRecord(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CompleteTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CompleteTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "JoinTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_JoinTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "LeaveTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_LeaveTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateTeamMember":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateTeamMember(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateTournamentUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateTournamentUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateTournamentUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateTournamentUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteTournamentUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteTournamentUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Webhook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Webhook(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "GetEvent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetEvent(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetEventRound":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetEventRound(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetEventUser":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetEventUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetItem":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetItem(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetItems":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetItems(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetArena":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetArena(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetArenas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetArenas(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetMatchmakingUser":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetMatchmakingUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetMatchmakingUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetMatchmakingUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetMatchmakingTicket":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetMatchmakingTicket(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetMatchmakingTickets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetMatchmakingTickets(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetMatch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetMatch(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetMatches":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetMatches(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetRecord":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetRecord(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetRecords":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetRecords(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTask":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTask(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTasks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTasks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTeam":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTeam(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTeams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTeams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTeamMember":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTeamMember(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "SearchTeams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_SearchTeams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTournamentUser":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTournamentUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTournamentUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTournamentUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var recordImplementors = []string{"Record"}

func (ec *executionContext) _Record(ctx context.Context, sel ast.SelectionSet, obj *api.Record) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, recordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Record")
		case "id":
			out.Values[i] = ec._Record_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Record_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._Record_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "record":
			out.Values[i] = ec._Record_record(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ranking":
			out.Values[i] = ec._Record_ranking(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._Record_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Record_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Record_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var removeEventResultResponseImplementors = []string{"RemoveEventResultResponse"}

func (ec *executionContext) _RemoveEventResultResponse(ctx context.Context, sel ast.SelectionSet, obj *api.RemoveEventResultResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, removeEventResultResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RemoveEventResultResponse")
		case "success":
			out.Values[i] = ec._RemoveEventResultResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RemoveEventResultResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchTeamsResponseImplementors = []string{"SearchTeamsResponse"}

func (ec *executionContext) _SearchTeamsResponse(ctx context.Context, sel ast.SelectionSet, obj *api.SearchTeamsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchTeamsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchTeamsResponse")
		case "success":
			out.Values[i] = ec._SearchTeamsResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teams":
			out.Values[i] = ec._SearchTeamsResponse_teams(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SearchTeamsResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var setMatchPrivateServerResponseImplementors = []string{"SetMatchPrivateServerResponse"}

func (ec *executionContext) _SetMatchPrivateServerResponse(ctx context.Context, sel ast.SelectionSet, obj *api.SetMatchPrivateServerResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setMatchPrivateServerResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetMatchPrivateServerResponse")
		case "success":
			out.Values[i] = ec._SetMatchPrivateServerResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "privateServerId":
			out.Values[i] = ec._SetMatchPrivateServerResponse_privateServerId(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SetMatchPrivateServerResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var startMatchResponseImplementors = []string{"StartMatchResponse"}

func (ec *executionContext) _StartMatchResponse(ctx context.Context, sel ast.SelectionSet, obj *api.StartMatchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, startMatchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StartMatchResponse")
		case "success":
			out.Values[i] = ec._StartMatchResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StartMatchResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskImplementors = []string{"Task"}

func (ec *executionContext) _Task(ctx context.Context, sel ast.SelectionSet, obj *api.Task) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Task")
		case "id":
			out.Values[i] = ec._Task_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Task_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._Task_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expiresAt":
			out.Values[i] = ec._Task_expiresAt(ctx, field, obj)
		case "completedAt":
			out.Values[i] = ec._Task_completedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Task_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Task_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskResponseImplementors = []string{"TaskResponse"}

func (ec *executionContext) _TaskResponse(ctx context.Context, sel ast.SelectionSet, obj *api.TaskResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskResponse")
		case "success":
			out.Values[i] = ec._TaskResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamImplementors = []string{"Team"}

func (ec *executionContext) _Team(ctx context.Context, sel ast.SelectionSet, obj *api.Team) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Team")
		case "id":
			out.Values[i] = ec._Team_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Team_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "score":
			out.Values[i] = ec._Team_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ranking":
			out.Values[i] = ec._Team_ranking(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "members":
			out.Values[i] = ec._Team_members(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._Team_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Team_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Team_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberImplementors = []string{"TeamMember"}

func (ec *executionContext) _TeamMember(ctx context.Context, sel ast.SelectionSet, obj *api.TeamMember) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMember")
		case "id":
			out.Values[i] = ec._TeamMember_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._TeamMember_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamId":
			out.Values[i] = ec._TeamMember_teamId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._TeamMember_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "joinedAt":
			out.Values[i] = ec._TeamMember_joinedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._TeamMember_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamResponseImplementors = []string{"TeamResponse"}

func (ec *executionContext) _TeamResponse(ctx context.Context, sel ast.SelectionSet, obj *api.TeamResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamResponse")
		case "success":
			out.Values[i] = ec._TeamResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tournamentUserImplementors = []string{"TournamentUser"}

func (ec *executionContext) _TournamentUser(ctx context.Context, sel ast.SelectionSet, obj *api.TournamentUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tournamentUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TournamentUser")
		case "id":
			out.Values[i] = ec._TournamentUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tournament":
			out.Values[i] = ec._TournamentUser_tournament(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._TournamentUser_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "interval":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TournamentUser_interval(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "score":
			out.Values[i] = ec._TournamentUser_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ranking":
			out.Values[i] = ec._TournamentUser_ranking(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "data":
			out.Values[i] = ec._TournamentUser_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tournamentStartedAt":
			out.Values[i] = ec._TournamentUser_tournamentStartedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._TournamentUser_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._TournamentUser_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tournamentUserResponseImplementors = []string{"TournamentUserResponse"}

func (ec *executionContext) _TournamentUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.TournamentUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tournamentUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TournamentUserResponse")
		case "success":
			out.Values[i] = ec._TournamentUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TournamentUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateArenaResponseImplementors = []string{"UpdateArenaResponse"}

func (ec *executionContext) _UpdateArenaResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateArenaResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateArenaResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateArenaResponse")
		case "success":
			out.Values[i] = ec._UpdateArenaResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateArenaResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateEventResponseImplementors = []string{"UpdateEventResponse"}

func (ec *executionContext) _UpdateEventResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateEventResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateEventResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateEventResponse")
		case "success":
			out.Values[i] = ec._UpdateEventResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateEventResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateEventRoundResponseImplementors = []string{"UpdateEventRoundResponse"}

func (ec *executionContext) _UpdateEventRoundResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateEventRoundResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateEventRoundResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateEventRoundResponse")
		case "success":
			out.Values[i] = ec._UpdateEventRoundResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateEventRoundResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateEventUserResponseImplementors = []string{"UpdateEventUserResponse"}

func (ec *executionContext) _UpdateEventUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateEventUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateEventUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateEventUserResponse")
		case "success":
			out.Values[i] = ec._UpdateEventUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateEventUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateItemResponseImplementors = []string{"UpdateItemResponse"}

func (ec *executionContext) _UpdateItemResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateItemResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateItemResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateItemResponse")
		case "success":
			out.Values[i] = ec._UpdateItemResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateItemResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateMatchResponseImplementors = []string{"UpdateMatchResponse"}

func (ec *executionContext) _UpdateMatchResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateMatchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateMatchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateMatchResponse")
		case "success":
			out.Values[i] = ec._UpdateMatchResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateMatchResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateMatchmakingTicketResponseImplementors = []string{"UpdateMatchmakingTicketResponse"}

func (ec *executionContext) _UpdateMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateMatchmakingTicketResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateMatchmakingTicketResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateMatchmakingTicketResponse")
		case "success":
			out.Values[i] = ec._UpdateMatchmakingTicketResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateMatchmakingTicketResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateMatchmakingUserResponseImplementors = []string{"UpdateMatchmakingUserResponse"}

func (ec *executionContext) _UpdateMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateMatchmakingUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateMatchmakingUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateMatchmakingUserResponse")
		case "success":
			out.Values[i] = ec._UpdateMatchmakingUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateMatchmakingUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateRecordResponseImplementors = []string{"UpdateRecordResponse"}

func (ec *executionContext) _UpdateRecordResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateRecordResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateRecordResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateRecordResponse")
		case "success":
			out.Values[i] = ec._UpdateRecordResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateRecordResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTaskResponseImplementors = []string{"UpdateTaskResponse"}

func (ec *executionContext) _UpdateTaskResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateTaskResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTaskResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTaskResponse")
		case "success":
			out.Values[i] = ec._UpdateTaskResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateTaskResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTeamMemberResponseImplementors = []string{"UpdateTeamMemberResponse"}

func (ec *executionContext) _UpdateTeamMemberResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateTeamMemberResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTeamMemberResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTeamMemberResponse")
		case "success":
			out.Values[i] = ec._UpdateTeamMemberResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateTeamMemberResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTeamResponseImplementors = []string{"UpdateTeamResponse"}

func (ec *executionContext) _UpdateTeamResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateTeamResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTeamResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTeamResponse")
		case "success":
			out.Values[i] = ec._UpdateTeamResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateTeamResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTournamentUserResponseImplementors = []string{"UpdateTournamentUserResponse"}

func (ec *executionContext) _UpdateTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateTournamentUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTournamentUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTournamentUserResponse")
		case "success":
			out.Values[i] = ec._UpdateTournamentUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateTournamentUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookResponseImplementors = []string{"WebhookResponse"}

func (ec *executionContext) _WebhookResponse(ctx context.Context, sel ast.SelectionSet, obj *api.WebhookResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WebhookResponse")
		case "status":
			out.Values[i] = ec._WebhookResponse_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "headers":
			out.Values[i] = ec._WebhookResponse_headers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "body":
			out.Values[i] = ec._WebhookResponse_body(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddEventResultError2githubcomMorhafAlshiblycoandainternalbffmodelAddEventResultError(ctx context.Context, v any) (model.AddEventResultError, error) {
	var res model.AddEventResultError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddEventResultError2githubcomMorhafAlshiblycoandainternalbffmodelAddEventResultError(ctx context.Context, sel ast.SelectionSet, v model.AddEventResultError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAddEventResultResponse2githubcomMorhafAlshiblycoandaapiAddEventResultResponse(ctx context.Context, sel ast.SelectionSet, v api.AddEventResultResponse) graphql.Marshaler {
	return ec._AddEventResultResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNAddEventResultResponse2githubcomMorhafAlshiblycoandaapiAddEventResultResponse(ctx context.Context, sel ast.SelectionSet, v *api.AddEventResultResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AddEventResultResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNArena2githubcomMorhafAlshiblycoandaapiArena(ctx context.Context, sel ast.SelectionSet, v []*api.Arena) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOArena2githubcomMorhafAlshiblycoandaapiArena(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNArena2githubcomMorhafAlshiblycoandaapiArena(ctx context.Context, sel ast.SelectionSet, v *api.Arena) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Arena(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArenaRequest2githubcomMorhafAlshiblycoandaapiArenaRequest(ctx context.Context, v any) ([]*api.ArenaRequest, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*api.ArenaRequest, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOArenaRequest2githubcomMorhafAlshiblycoandaapiArenaRequest(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNArenaRequest2githubcomMorhafAlshiblycoandaapiArenaRequest(ctx context.Context, v any) (*api.ArenaRequest, error) {
	res, err := ec.unmarshalInputArenaRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCompleteTaskError2githubcomMorhafAlshiblycoandainternalbffmodelCompleteTaskError(ctx context.Context, v any) (model.CompleteTaskError, error) {
	var res model.CompleteTaskError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCompleteTaskError2githubcomMorhafAlshiblycoandainternalbffmodelCompleteTaskError(ctx context.Context, sel ast.SelectionSet, v model.CompleteTaskError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCompleteTaskResponse2githubcomMorhafAlshiblycoandaapiCompleteTaskResponse(ctx context.Context, sel ast.SelectionSet, v api.CompleteTaskResponse) graphql.Marshaler {
	return ec._CompleteTaskResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompleteTaskResponse2githubcomMorhafAlshiblycoandaapiCompleteTaskResponse(ctx context.Context, sel ast.SelectionSet, v *api.CompleteTaskResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CompleteTaskResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateArenaError2githubcomMorhafAlshiblycoandainternalbffmodelCreateArenaError(ctx context.Context, v any) (model.CreateArenaError, error) {
	var res model.CreateArenaError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateArenaError2githubcomMorhafAlshiblycoandainternalbffmodelCreateArenaError(ctx context.Context, sel ast.SelectionSet, v model.CreateArenaError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateArenaResponse2githubcomMorhafAlshiblycoandaapiCreateArenaResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateArenaResponse) graphql.Marshaler {
	return ec._CreateArenaResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateArenaResponse2githubcomMorhafAlshiblycoandaapiCreateArenaResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateArenaResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateArenaResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateEventError2githubcomMorhafAlshiblycoandainternalbffmodelCreateEventError(ctx context.Context, v any) (model.CreateEventError, error) {
	var res model.CreateEventError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateEventError2githubcomMorhafAlshiblycoandainternalbffmodelCreateEventError(ctx context.Context, sel ast.SelectionSet, v model.CreateEventError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateEventResponse2githubcomMorhafAlshiblycoandaapiCreateEventResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateEventResponse) graphql.Marshaler {
	return ec._CreateEventResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateEventResponse2githubcomMorhafAlshiblycoandaapiCreateEventResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateEventResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateEventResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateEventRound2githubcomMorhafAlshiblycoandaapiCreateEventRound(ctx context.Context, v any) ([]*api.CreateEventRound, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*api.CreateEventRound, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOCreateEventRound2githubcomMorhafAlshiblycoandaapiCreateEventRound(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateEventRound2githubcomMorhafAlshiblycoandaapiCreateEventRound(ctx context.Context, v any) (*api.CreateEventRound, error) {
	res, err := ec.unmarshalInputCreateEventRound(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateEventRoundError2githubcomMorhafAlshiblycoandainternalbffmodelCreateEventRoundError(ctx context.Context, v any) (model.CreateEventRoundError, error) {
	var res model.CreateEventRoundError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateEventRoundError2githubcomMorhafAlshiblycoandainternalbffmodelCreateEventRoundError(ctx context.Context, sel ast.SelectionSet, v model.CreateEventRoundError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateEventRoundResponse2githubcomMorhafAlshiblycoandaapiCreateEventRoundResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateEventRoundResponse) graphql.Marshaler {
	return ec._CreateEventRoundResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateEventRoundResponse2githubcomMorhafAlshiblycoandaapiCreateEventRoundResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateEventRoundResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateEventRoundResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateItemError2githubcomMorhafAlshiblycoandainternalbffmodelCreateItemError(ctx context.Context, v any) (model.CreateItemError, error) {
	var res model.CreateItemError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateItemError2githubcomMorhafAlshiblycoandainternalbffmodelCreateItemError(ctx context.Context, sel ast.SelectionSet, v model.CreateItemError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateItemResponse2githubcomMorhafAlshiblycoandaapiCreateItemResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateItemResponse) graphql.Marshaler {
	return ec._CreateItemResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateItemResponse2githubcomMorhafAlshiblycoandaapiCreateItemResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateItemResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateItemResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateMatchmakingTicketError2githubcomMorhafAlshiblycoandainternalbffmodelCreateMatchmakingTicketError(ctx context.Context, v any) (model.CreateMatchmakingTicketError, error) {
	var res model.CreateMatchmakingTicketError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateMatchmakingTicketError2githubcomMorhafAlshiblycoandainternalbffmodelCreateMatchmakingTicketError(ctx context.Context, sel ast.SelectionSet, v model.CreateMatchmakingTicketError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateMatchmakingTicketResponse2githubcomMorhafAlshiblycoandaapiCreateMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateMatchmakingTicketResponse) graphql.Marshaler {
	return ec._CreateMatchmakingTicketResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateMatchmakingTicketResponse2githubcomMorhafAlshiblycoandaapiCreateMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateMatchmakingTicketResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateMatchmakingTicketResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateMatchmakingUserError2githubcomMorhafAlshiblycoandainternalbffmodelCreateMatchmakingUserError(ctx context.Context, v any) (model.CreateMatchmakingUserError, error) {
	var res model.CreateMatchmakingUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateMatchmakingUserError2githubcomMorhafAlshiblycoandainternalbffmodelCreateMatchmakingUserError(ctx context.Context, sel ast.SelectionSet, v model.CreateMatchmakingUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateMatchmakingUserResponse2githubcomMorhafAlshiblycoandaapiCreateMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateMatchmakingUserResponse) graphql.Marshaler {
	return ec._CreateMatchmakingUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateMatchmakingUserResponse2githubcomMorhafAlshiblycoandaapiCreateMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateMatchmakingUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateMatchmakingUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateRecordError2githubcomMorhafAlshiblycoandainternalbffmodelCreateRecordError(ctx context.Context, v any) (model.CreateRecordError, error) {
	var res model.CreateRecordError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateRecordError2githubcomMorhafAlshiblycoandainternalbffmodelCreateRecordError(ctx context.Context, sel ast.SelectionSet, v model.CreateRecordError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateRecordResponse2githubcomMorhafAlshiblycoandaapiCreateRecordResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateRecordResponse) graphql.Marshaler {
	return ec._CreateRecordResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateRecordResponse2githubcomMorhafAlshiblycoandaapiCreateRecordResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateRecordResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateRecordResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateTaskError2githubcomMorhafAlshiblycoandainternalbffmodelCreateTaskError(ctx context.Context, v any) (model.CreateTaskError, error) {
	var res model.CreateTaskError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateTaskError2githubcomMorhafAlshiblycoandainternalbffmodelCreateTaskError(ctx context.Context, sel ast.SelectionSet, v model.CreateTaskError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateTaskResponse2githubcomMorhafAlshiblycoandaapiCreateTaskResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateTaskResponse) graphql.Marshaler {
	return ec._CreateTaskResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateTaskResponse2githubcomMorhafAlshiblycoandaapiCreateTaskResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateTaskResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateTaskResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateTeamError2githubcomMorhafAlshiblycoandainternalbffmodelCreateTeamError(ctx context.Context, v any) (model.CreateTeamError, error) {
	var res model.CreateTeamError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateTeamError2githubcomMorhafAlshiblycoandainternalbffmodelCreateTeamError(ctx context.Context, sel ast.SelectionSet, v model.CreateTeamError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateTeamResponse2githubcomMorhafAlshiblycoandaapiCreateTeamResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateTeamResponse) graphql.Marshaler {
	return ec._CreateTeamResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateTeamResponse2githubcomMorhafAlshiblycoandaapiCreateTeamResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateTeamResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateTeamResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateTournamentUserError2githubcomMorhafAlshiblycoandainternalbffmodelCreateTournamentUserError(ctx context.Context, v any) (model.CreateTournamentUserError, error) {
	var res model.CreateTournamentUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateTournamentUserError2githubcomMorhafAlshiblycoandainternalbffmodelCreateTournamentUserError(ctx context.Context, sel ast.SelectionSet, v model.CreateTournamentUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateTournamentUserResponse2githubcomMorhafAlshiblycoandaapiCreateTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateTournamentUserResponse) graphql.Marshaler {
	return ec._CreateTournamentUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateTournamentUserResponse2githubcomMorhafAlshiblycoandaapiCreateTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateTournamentUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateTournamentUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteMatchError2githubcomMorhafAlshiblycoandainternalbffmodelDeleteMatchError(ctx context.Context, v any) (model.DeleteMatchError, error) {
	var res model.DeleteMatchError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteMatchError2githubcomMorhafAlshiblycoandainternalbffmodelDeleteMatchError(ctx context.Context, sel ast.SelectionSet, v model.DeleteMatchError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDeleteMatchResponse2githubcomMorhafAlshiblycoandaapiDeleteMatchResponse(ctx context.Context, sel ast.SelectionSet, v api.DeleteMatchResponse) graphql.Marshaler {
	return ec._DeleteMatchResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteMatchResponse2githubcomMorhafAlshiblycoandaapiDeleteMatchResponse(ctx context.Context, sel ast.SelectionSet, v *api.DeleteMatchResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteMatchResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteMatchmakingTicketError2githubcomMorhafAlshiblycoandainternalbffmodelDeleteMatchmakingTicketError(ctx context.Context, v any) (model.DeleteMatchmakingTicketError, error) {
	var res model.DeleteMatchmakingTicketError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteMatchmakingTicketError2githubcomMorhafAlshiblycoandainternalbffmodelDeleteMatchmakingTicketError(ctx context.Context, sel ast.SelectionSet, v model.DeleteMatchmakingTicketError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDeleteMatchmakingTicketResponse2githubcomMorhafAlshiblycoandaapiDeleteMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v api.DeleteMatchmakingTicketResponse) graphql.Marshaler {
	return ec._DeleteMatchmakingTicketResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteMatchmakingTicketResponse2githubcomMorhafAlshiblycoandaapiDeleteMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v *api.DeleteMatchmakingTicketResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteMatchmakingTicketResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteMatchmakingUserError2githubcomMorhafAlshiblycoandainternalbffmodelDeleteMatchmakingUserError(ctx context.Context, v any) (model.DeleteMatchmakingUserError, error) {
	var res model.DeleteMatchmakingUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteMatchmakingUserError2githubcomMorhafAlshiblycoandainternalbffmodelDeleteMatchmakingUserError(ctx context.Context, sel ast.SelectionSet, v model.DeleteMatchmakingUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDeleteMatchmakingUserResponse2githubcomMorhafAlshiblycoandaapiDeleteMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v api.DeleteMatchmakingUserResponse) graphql.Marshaler {
	return ec._DeleteMatchmakingUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteMatchmakingUserResponse2githubcomMorhafAlshiblycoandaapiDeleteMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.DeleteMatchmakingUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteMatchmakingUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteRecordError2githubcomMorhafAlshiblycoandainternalbffmodelDeleteRecordError(ctx context.Context, v any) (model.DeleteRecordError, error) {
	var res model.DeleteRecordError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteRecordError2githubcomMorhafAlshiblycoandainternalbffmodelDeleteRecordError(ctx context.Context, sel ast.SelectionSet, v model.DeleteRecordError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDeleteRecordResponse2githubcomMorhafAlshiblycoandaapiDeleteRecordResponse(ctx context.Context, sel ast.SelectionSet, v api.DeleteRecordResponse) graphql.Marshaler {
	return ec._DeleteRecordResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteRecordResponse2githubcomMorhafAlshiblycoandaapiDeleteRecordResponse(ctx context.Context, sel ast.SelectionSet, v *api.DeleteRecordResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteRecordResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEndMatchError2githubcomMorhafAlshiblycoandainternalbffmodelEndMatchError(ctx context.Context, v any) (model.EndMatchError, error) {
	var res model.EndMatchError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEndMatchError2githubcomMorhafAlshiblycoandainternalbffmodelEndMatchError(ctx context.Context, sel ast.SelectionSet, v model.EndMatchError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEndMatchResponse2githubcomMorhafAlshiblycoandaapiEndMatchResponse(ctx context.Context, sel ast.SelectionSet, v api.EndMatchResponse) graphql.Marshaler {
	return ec._EndMatchResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNEndMatchResponse2githubcomMorhafAlshiblycoandaapiEndMatchResponse(ctx context.Context, sel ast.SelectionSet, v *api.EndMatchResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EndMatchResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventError2githubcomMorhafAlshiblycoandainternalbffmodelEventError(ctx context.Context, v any) (model.EventError, error) {
	var res model.EventError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventError2githubcomMorhafAlshiblycoandainternalbffmodelEventError(ctx context.Context, sel ast.SelectionSet, v model.EventError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventRequest2githubcomMorhafAlshiblycoandaapiEventRequest(ctx context.Context, v any) (*api.EventRequest, error) {
	res, err := ec.unmarshalInputEventRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventResponse2githubcomMorhafAlshiblycoandaapiEventResponse(ctx context.Context, sel ast.SelectionSet, v api.EventResponse) graphql.Marshaler {
	return ec._EventResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventResponse2githubcomMorhafAlshiblycoandaapiEventResponse(ctx context.Context, sel ast.SelectionSet, v *api.EventResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNEventRound2githubcomMorhafAlshiblycoandaapiEventRound(ctx context.Context, sel ast.SelectionSet, v []*api.EventRound) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEventRound2githubcomMorhafAlshiblycoandaapiEventRound(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNEventRoundRequest2githubcomMorhafAlshiblycoandaapiEventRoundRequest(ctx context.Context, v any) (*api.EventRoundRequest, error) {
	res, err := ec.unmarshalInputEventRoundRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventRoundUser2githubcomMorhafAlshiblycoandaapiEventRoundUser(ctx context.Context, sel ast.SelectionSet, v []*api.EventRoundUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEventRoundUser2githubcomMorhafAlshiblycoandaapiEventRoundUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNEventUser2githubcomMorhafAlshiblycoandaapiEventUser(ctx context.Context, sel ast.SelectionSet, v []*api.EventUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEventUser2githubcomMorhafAlshiblycoandaapiEventUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNEventUserError2githubcomMorhafAlshiblycoandainternalbffmodelEventUserError(ctx context.Context, v any) (model.EventUserError, error) {
	var res model.EventUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventUserError2githubcomMorhafAlshiblycoandainternalbffmodelEventUserError(ctx context.Context, sel ast.SelectionSet, v model.EventUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventUserRequest2githubcomMorhafAlshiblycoandaapiEventUserRequest(ctx context.Context, v any) (*api.EventUserRequest, error) {
	res, err := ec.unmarshalInputEventUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventUserResponse2githubcomMorhafAlshiblycoandaapiEventUserResponse(ctx context.Context, sel ast.SelectionSet, v api.EventUserResponse) graphql.Marshaler {
	return ec._EventUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventUserResponse2githubcomMorhafAlshiblycoandaapiEventUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.EventUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetArenaError2githubcomMorhafAlshiblycoandainternalbffmodelGetArenaError(ctx context.Context, v any) (model.GetArenaError, error) {
	var res model.GetArenaError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetArenaError2githubcomMorhafAlshiblycoandainternalbffmodelGetArenaError(ctx context.Context, sel ast.SelectionSet, v model.GetArenaError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetArenaResponse2githubcomMorhafAlshiblycoandaapiGetArenaResponse(ctx context.Context, sel ast.SelectionSet, v api.GetArenaResponse) graphql.Marshaler {
	return ec._GetArenaResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetArenaResponse2githubcomMorhafAlshiblycoandaapiGetArenaResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetArenaResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetArenaResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetArenasResponse2githubcomMorhafAlshiblycoandaapiGetArenasResponse(ctx context.Context, sel ast.SelectionSet, v api.GetArenasResponse) graphql.Marshaler {
	return ec._GetArenasResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetArenasResponse2githubcomMorhafAlshiblycoandaapiGetArenasResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetArenasResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetArenasResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetEventError2githubcomMorhafAlshiblycoandainternalbffmodelGetEventError(ctx context.Context, v any) (model.GetEventError, error) {
	var res model.GetEventError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetEventError2githubcomMorhafAlshiblycoandainternalbffmodelGetEventError(ctx context.Context, sel ast.SelectionSet, v model.GetEventError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetEventResponse2githubcomMorhafAlshiblycoandaapiGetEventResponse(ctx context.Context, sel ast.SelectionSet, v api.GetEventResponse) graphql.Marshaler {
	return ec._GetEventResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetEventResponse2githubcomMorhafAlshiblycoandaapiGetEventResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetEventResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetEventResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetEventRoundError2githubcomMorhafAlshiblycoandainternalbffmodelGetEventRoundError(ctx context.Context, v any) (model.GetEventRoundError, error) {
	var res model.GetEventRoundError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetEventRoundError2githubcomMorhafAlshiblycoandainternalbffmodelGetEventRoundError(ctx context.Context, sel ast.SelectionSet, v model.GetEventRoundError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetEventRoundResponse2githubcomMorhafAlshiblycoandaapiGetEventRoundResponse(ctx context.Context, sel ast.SelectionSet, v api.GetEventRoundResponse) graphql.Marshaler {
	return ec._GetEventRoundResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetEventRoundResponse2githubcomMorhafAlshiblycoandaapiGetEventRoundResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetEventRoundResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetEventRoundResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetEventUserError2githubcomMorhafAlshiblycoandainternalbffmodelGetEventUserError(ctx context.Context, v any) (model.GetEventUserError, error) {
	var res model.GetEventUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetEventUserError2githubcomMorhafAlshiblycoandainternalbffmodelGetEventUserError(ctx context.Context, sel ast.SelectionSet, v model.GetEventUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetEventUserResponse2githubcomMorhafAlshiblycoandaapiGetEventUserResponse(ctx context.Context, sel ast.SelectionSet, v api.GetEventUserResponse) graphql.Marshaler {
	return ec._GetEventUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetEventUserResponse2githubcomMorhafAlshiblycoandaapiGetEventUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetEventUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetEventUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetItemError2githubcomMorhafAlshiblycoandainternalbffmodelGetItemError(ctx context.Context, v any) (model.GetItemError, error) {
	var res model.GetItemError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetItemError2githubcomMorhafAlshiblycoandainternalbffmodelGetItemError(ctx context.Context, sel ast.SelectionSet, v model.GetItemError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetItemResponse2githubcomMorhafAlshiblycoandaapiGetItemResponse(ctx context.Context, sel ast.SelectionSet, v api.GetItemResponse) graphql.Marshaler {
	return ec._GetItemResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetItemResponse2githubcomMorhafAlshiblycoandaapiGetItemResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetItemResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetItemResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetItemsResponse2githubcomMorhafAlshiblycoandaapiGetItemsResponse(ctx context.Context, sel ast.SelectionSet, v api.GetItemsResponse) graphql.Marshaler {
	return ec._GetItemsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetItemsResponse2githubcomMorhafAlshiblycoandaapiGetItemsResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetItemsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetItemsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetMatchError2githubcomMorhafAlshiblycoandainternalbffmodelGetMatchError(ctx context.Context, v any) (model.GetMatchError, error) {
	var res model.GetMatchError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetMatchError2githubcomMorhafAlshiblycoandainternalbffmodelGetMatchError(ctx context.Context, sel ast.SelectionSet, v model.GetMatchError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetMatchResponse2githubcomMorhafAlshiblycoandaapiGetMatchResponse(ctx context.Context, sel ast.SelectionSet, v api.GetMatchResponse) graphql.Marshaler {
	return ec._GetMatchResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMatchResponse2githubcomMorhafAlshiblycoandaapiGetMatchResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetMatchResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMatchResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetMatchesResponse2githubcomMorhafAlshiblycoandaapiGetMatchesResponse(ctx context.Context, sel ast.SelectionSet, v api.GetMatchesResponse) graphql.Marshaler {
	return ec._GetMatchesResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMatchesResponse2githubcomMorhafAlshiblycoandaapiGetMatchesResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetMatchesResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMatchesResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetMatchmakingTicketError2githubcomMorhafAlshiblycoandainternalbffmodelGetMatchmakingTicketError(ctx context.Context, v any) (model.GetMatchmakingTicketError, error) {
	var res model.GetMatchmakingTicketError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetMatchmakingTicketError2githubcomMorhafAlshiblycoandainternalbffmodelGetMatchmakingTicketError(ctx context.Context, sel ast.SelectionSet, v model.GetMatchmakingTicketError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetMatchmakingTicketResponse2githubcomMorhafAlshiblycoandaapiGetMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v api.GetMatchmakingTicketResponse) graphql.Marshaler {
	return ec._GetMatchmakingTicketResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMatchmakingTicketResponse2githubcomMorhafAlshiblycoandaapiGetMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetMatchmakingTicketResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMatchmakingTicketResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetMatchmakingTicketsError2githubcomMorhafAlshiblycoandainternalbffmodelGetMatchmakingTicketsError(ctx context.Context, v any) (model.GetMatchmakingTicketsError, error) {
	var res model.GetMatchmakingTicketsError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetMatchmakingTicketsError2githubcomMorhafAlshiblycoandainternalbffmodelGetMatchmakingTicketsError(ctx context.Context, sel ast.SelectionSet, v model.GetMatchmakingTicketsError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetMatchmakingTicketsResponse2githubcomMorhafAlshiblycoandaapiGetMatchmakingTicketsResponse(ctx context.Context, sel ast.SelectionSet, v api.GetMatchmakingTicketsResponse) graphql.Marshaler {
	return ec._GetMatchmakingTicketsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMatchmakingTicketsResponse2githubcomMorhafAlshiblycoandaapiGetMatchmakingTicketsResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetMatchmakingTicketsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMatchmakingTicketsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetMatchmakingUserError2githubcomMorhafAlshiblycoandainternalbffmodelGetMatchmakingUserError(ctx context.Context, v any) (model.GetMatchmakingUserError, error) {
	var res model.GetMatchmakingUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetMatchmakingUserError2githubcomMorhafAlshiblycoandainternalbffmodelGetMatchmakingUserError(ctx context.Context, sel ast.SelectionSet, v model.GetMatchmakingUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetMatchmakingUserResponse2githubcomMorhafAlshiblycoandaapiGetMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v api.GetMatchmakingUserResponse) graphql.Marshaler {
	return ec._GetMatchmakingUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMatchmakingUserResponse2githubcomMorhafAlshiblycoandaapiGetMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetMatchmakingUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMatchmakingUserResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetMatchmakingUsersResponse2githubcomMorhafAlshiblycoandaapiGetMatchmakingUsersResponse(ctx context.Context, sel ast.SelectionSet, v api.GetMatchmakingUsersResponse) graphql.Marshaler {
	return ec._GetMatchmakingUsersResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMatchmakingUsersResponse2githubcomMorhafAlshiblycoandaapiGetMatchmakingUsersResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetMatchmakingUsersResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMatchmakingUsersResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetRecordError2githubcomMorhafAlshiblycoandainternalbffmodelGetRecordError(ctx context.Context, v any) (model.GetRecordError, error) {
	var res model.GetRecordError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetRecordError2githubcomMorhafAlshiblycoandainternalbffmodelGetRecordError(ctx context.Context, sel ast.SelectionSet, v model.GetRecordError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetRecordResponse2githubcomMorhafAlshiblycoandaapiGetRecordResponse(ctx context.Context, sel ast.SelectionSet, v api.GetRecordResponse) graphql.Marshaler {
	return ec._GetRecordResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetRecordResponse2githubcomMorhafAlshiblycoandaapiGetRecordResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetRecordResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetRecordResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetRecordsError2githubcomMorhafAlshiblycoandainternalbffmodelGetRecordsError(ctx context.Context, v any) (model.GetRecordsError, error) {
	var res model.GetRecordsError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetRecordsError2githubcomMorhafAlshiblycoandainternalbffmodelGetRecordsError(ctx context.Context, sel ast.SelectionSet, v model.GetRecordsError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetRecordsResponse2githubcomMorhafAlshiblycoandaapiGetRecordsResponse(ctx context.Context, sel ast.SelectionSet, v api.GetRecordsResponse) graphql.Marshaler {
	return ec._GetRecordsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetRecordsResponse2githubcomMorhafAlshiblycoandaapiGetRecordsResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetRecordsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetRecordsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetTaskError2githubcomMorhafAlshiblycoandainternalbffmodelGetTaskError(ctx context.Context, v any) (model.GetTaskError, error) {
	var res model.GetTaskError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetTaskError2githubcomMorhafAlshiblycoandainternalbffmodelGetTaskError(ctx context.Context, sel ast.SelectionSet, v model.GetTaskError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetTaskResponse2githubcomMorhafAlshiblycoandaapiGetTaskResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTaskResponse) graphql.Marshaler {
	return ec._GetTaskResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTaskResponse2githubcomMorhafAlshiblycoandaapiGetTaskResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTaskResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTaskResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetTasksResponse2githubcomMorhafAlshiblycoandaapiGetTasksResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTasksResponse) graphql.Marshaler {
	return ec._GetTasksResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTasksResponse2githubcomMorhafAlshiblycoandaapiGetTasksResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTasksResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTasksResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetTeamError2githubcomMorhafAlshiblycoandainternalbffmodelGetTeamError(ctx context.Context, v any) (model.GetTeamError, error) {
	var res model.GetTeamError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetTeamError2githubcomMorhafAlshiblycoandainternalbffmodelGetTeamError(ctx context.Context, sel ast.SelectionSet, v model.GetTeamError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGetTeamMemberError2githubcomMorhafAlshiblycoandainternalbffmodelGetTeamMemberError(ctx context.Context, v any) (model.GetTeamMemberError, error) {
	var res model.GetTeamMemberError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetTeamMemberError2githubcomMorhafAlshiblycoandainternalbffmodelGetTeamMemberError(ctx context.Context, sel ast.SelectionSet, v model.GetTeamMemberError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetTeamMemberResponse2githubcomMorhafAlshiblycoandaapiGetTeamMemberResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTeamMemberResponse) graphql.Marshaler {
	return ec._GetTeamMemberResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTeamMemberResponse2githubcomMorhafAlshiblycoandaapiGetTeamMemberResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTeamMemberResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTeamMemberResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetTeamResponse2githubcomMorhafAlshiblycoandaapiGetTeamResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTeamResponse) graphql.Marshaler {
	return ec._GetTeamResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTeamResponse2githubcomMorhafAlshiblycoandaapiGetTeamResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTeamResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTeamResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetTeamsResponse2githubcomMorhafAlshiblycoandaapiGetTeamsResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTeamsResponse) graphql.Marshaler {
	return ec._GetTeamsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTeamsResponse2githubcomMorhafAlshiblycoandaapiGetTeamsResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTeamsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTeamsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetTournamentUserError2githubcomMorhafAlshiblycoandainternalbffmodelGetTournamentUserError(ctx context.Context, v any) (model.GetTournamentUserError, error) {
	var res model.GetTournamentUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetTournamentUserError2githubcomMorhafAlshiblycoandainternalbffmodelGetTournamentUserError(ctx context.Context, sel ast.SelectionSet, v model.GetTournamentUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetTournamentUserResponse2githubcomMorhafAlshiblycoandaapiGetTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTournamentUserResponse) graphql.Marshaler {
	return ec._GetTournamentUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTournamentUserResponse2githubcomMorhafAlshiblycoandaapiGetTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTournamentUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTournamentUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetTournamentUsersError2githubcomMorhafAlshiblycoandainternalbffmodelGetTournamentUsersError(ctx context.Context, v any) (model.GetTournamentUsersError, error) {
	var res model.GetTournamentUsersError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetTournamentUsersError2githubcomMorhafAlshiblycoandainternalbffmodelGetTournamentUsersError(ctx context.Context, sel ast.SelectionSet, v model.GetTournamentUsersError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetTournamentUsersResponse2githubcomMorhafAlshiblycoandaapiGetTournamentUsersResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTournamentUsersResponse) graphql.Marshaler {
	return ec._GetTournamentUsersResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTournamentUsersResponse2githubcomMorhafAlshiblycoandaapiGetTournamentUsersResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTournamentUsersResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTournamentUsersResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt642int64(ctx context.Context, v any) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt642int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNItem2githubcomMorhafAlshiblycoandaapiItem(ctx context.Context, sel ast.SelectionSet, v []*api.Item) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOItem2githubcomMorhafAlshiblycoandaapiItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNItemError2githubcomMorhafAlshiblycoandainternalbffmodelItemError(ctx context.Context, v any) (model.ItemError, error) {
	var res model.ItemError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemError2githubcomMorhafAlshiblycoandainternalbffmodelItemError(ctx context.Context, sel ast.SelectionSet, v model.ItemError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNItemRequest2githubcomMorhafAlshiblycoandaapiItemRequest(ctx context.Context, v any) (*api.ItemRequest, error) {
	res, err := ec.unmarshalInputItemRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemResponse2githubcomMorhafAlshiblycoandaapiItemResponse(ctx context.Context, sel ast.SelectionSet, v api.ItemResponse) graphql.Marshaler {
	return ec._ItemResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNItemResponse2githubcomMorhafAlshiblycoandaapiItemResponse(ctx context.Context, sel ast.SelectionSet, v *api.ItemResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ItemResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNJoinTeamError2githubcomMorhafAlshiblycoandainternalbffmodelJoinTeamError(ctx context.Context, v any) (model.JoinTeamError, error) {
	var res model.JoinTeamError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJoinTeamError2githubcomMorhafAlshiblycoandainternalbffmodelJoinTeamError(ctx context.Context, sel ast.SelectionSet, v model.JoinTeamError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNJoinTeamResponse2githubcomMorhafAlshiblycoandaapiJoinTeamResponse(ctx context.Context, sel ast.SelectionSet, v api.JoinTeamResponse) graphql.Marshaler {
	return ec._JoinTeamResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNJoinTeamResponse2githubcomMorhafAlshiblycoandaapiJoinTeamResponse(ctx context.Context, sel ast.SelectionSet, v *api.JoinTeamResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JoinTeamResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLeaveTeamError2githubcomMorhafAlshiblycoandainternalbffmodelLeaveTeamError(ctx context.Context, v any) (model.LeaveTeamError, error) {
	var res model.LeaveTeamError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLeaveTeamError2githubcomMorhafAlshiblycoandainternalbffmodelLeaveTeamError(ctx context.Context, sel ast.SelectionSet, v model.LeaveTeamError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLeaveTeamResponse2githubcomMorhafAlshiblycoandaapiLeaveTeamResponse(ctx context.Context, sel ast.SelectionSet, v api.LeaveTeamResponse) graphql.Marshaler {
	return ec._LeaveTeamResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNLeaveTeamResponse2githubcomMorhafAlshiblycoandaapiLeaveTeamResponse(ctx context.Context, sel ast.SelectionSet, v *api.LeaveTeamResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LeaveTeamResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMatchRequest2githubcomMorhafAlshiblycoandaapiMatchRequest(ctx context.Context, v any) (*api.MatchRequest, error) {
	res, err := ec.unmarshalInputMatchRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMatchStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchStatus(ctx context.Context, v any) (model.MatchStatus, error) {
	var res model.MatchStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMatchStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchStatus(ctx context.Context, sel ast.SelectionSet, v model.MatchStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMatchmakingTicket2githubcomMorhafAlshiblycoandaapiMatchmakingTicket(ctx context.Context, sel ast.SelectionSet, v []*api.MatchmakingTicket) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatchmakingTicket2githubcomMorhafAlshiblycoandaapiMatchmakingTicket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNMatchmakingTicketRequest2githubcomMorhafAlshiblycoandaapiMatchmakingTicketRequest(ctx context.Context, v any) (*api.MatchmakingTicketRequest, error) {
	res, err := ec.unmarshalInputMatchmakingTicketRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMatchmakingTicketStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchmakingTicketStatus(ctx context.Context, v any) (model.MatchmakingTicketStatus, error) {
	var res model.MatchmakingTicketStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMatchmakingTicketStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchmakingTicketStatus(ctx context.Context, sel ast.SelectionSet, v model.MatchmakingTicketStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMatchmakingUser2githubcomMorhafAlshiblycoandaapiMatchmakingUser(ctx context.Context, sel ast.SelectionSet, v []*api.MatchmakingUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatchmakingUser2githubcomMorhafAlshiblycoandaapiMatchmakingUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiMatchmakingUserRequest(ctx context.Context, v any) ([]*api.MatchmakingUserRequest, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*api.MatchmakingUserRequest, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiMatchmakingUserRequest(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiMatchmakingUserRequest(ctx context.Context, v any) (*api.MatchmakingUserRequest, error) {
	res, err := ec.unmarshalInputMatchmakingUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRecord2githubcomMorhafAlshiblycoandaapiRecord(ctx context.Context, sel ast.SelectionSet, v []*api.Record) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORecord2githubcomMorhafAlshiblycoandaapiRecord(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNRecordRequest2githubcomMorhafAlshiblycoandaapiRecordRequest(ctx context.Context, v any) (*api.RecordRequest, error) {
	res, err := ec.unmarshalInputRecordRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRemoveEventResultError2githubcomMorhafAlshiblycoandainternalbffmodelRemoveEventResultError(ctx context.Context, v any) (model.RemoveEventResultError, error) {
	var res model.RemoveEventResultError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRemoveEventResultError2githubcomMorhafAlshiblycoandainternalbffmodelRemoveEventResultError(ctx context.Context, sel ast.SelectionSet, v model.RemoveEventResultError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRemoveEventResultResponse2githubcomMorhafAlshiblycoandaapiRemoveEventResultResponse(ctx context.Context, sel ast.SelectionSet, v api.RemoveEventResultResponse) graphql.Marshaler {
	return ec._RemoveEventResultResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRemoveEventResultResponse2githubcomMorhafAlshiblycoandaapiRemoveEventResultResponse(ctx context.Context, sel ast.SelectionSet, v *api.RemoveEventResultResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RemoveEventResultResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSearchTeamsError2githubcomMorhafAlshiblycoandainternalbffmodelSearchTeamsError(ctx context.Context, v any) (model.SearchTeamsError, error) {
	var res model.SearchTeamsError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSearchTeamsError2githubcomMorhafAlshiblycoandainternalbffmodelSearchTeamsError(ctx context.Context, sel ast.SelectionSet, v model.SearchTeamsError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSearchTeamsResponse2githubcomMorhafAlshiblycoandaapiSearchTeamsResponse(ctx context.Context, sel ast.SelectionSet, v api.SearchTeamsResponse) graphql.Marshaler {
	return ec._SearchTeamsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchTeamsResponse2githubcomMorhafAlshiblycoandaapiSearchTeamsResponse(ctx context.Context, sel ast.SelectionSet, v *api.SearchTeamsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SearchTeamsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSetMatchPrivateServerError2githubcomMorhafAlshiblycoandainternalbffmodelSetMatchPrivateServerError(ctx context.Context, v any) (model.SetMatchPrivateServerError, error) {
	var res model.SetMatchPrivateServerError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSetMatchPrivateServerError2githubcomMorhafAlshiblycoandainternalbffmodelSetMatchPrivateServerError(ctx context.Context, sel ast.SelectionSet, v model.SetMatchPrivateServerError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSetMatchPrivateServerResponse2githubcomMorhafAlshiblycoandaapiSetMatchPrivateServerResponse(ctx context.Context, sel ast.SelectionSet, v api.SetMatchPrivateServerResponse) graphql.Marshaler {
	return ec._SetMatchPrivateServerResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNSetMatchPrivateServerResponse2githubcomMorhafAlshiblycoandaapiSetMatchPrivateServerResponse(ctx context.Context, sel ast.SelectionSet, v *api.SetMatchPrivateServerResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SetMatchPrivateServerResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStartMatchError2githubcomMorhafAlshiblycoandainternalbffmodelStartMatchError(ctx context.Context, v any) (model.StartMatchError, error) {
	var res model.StartMatchError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStartMatchError2githubcomMorhafAlshiblycoandainternalbffmodelStartMatchError(ctx context.Context, sel ast.SelectionSet, v model.StartMatchError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNStartMatchResponse2githubcomMorhafAlshiblycoandaapiStartMatchResponse(ctx context.Context, sel ast.SelectionSet, v api.StartMatchResponse) graphql.Marshaler {
	return ec._StartMatchResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNStartMatchResponse2githubcomMorhafAlshiblycoandaapiStartMatchResponse(ctx context.Context, sel ast.SelectionSet, v *api.StartMatchResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StartMatchResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx context.Context, v any) (*structpb.Struct, error) {
	res, err := scalar.UnmarshalProtobufStruct(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx context.Context, sel ast.SelectionSet, v *structpb.Struct) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := scalar.MarshalProtobufStruct(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTask2githubcomMorhafAlshiblycoandaapiTask(ctx context.Context, sel ast.SelectionSet, v []*api.Task) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTask2githubcomMorhafAlshiblycoandaapiTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNTaskError2githubcomMorhafAlshiblycoandainternalbffmodelTaskError(ctx context.Context, v any) (model.TaskError, error) {
	var res model.TaskError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskError2githubcomMorhafAlshiblycoandainternalbffmodelTaskError(ctx context.Context, sel ast.SelectionSet, v model.TaskError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTaskRequest2githubcomMorhafAlshiblycoandaapiTaskRequest(ctx context.Context, v any) (*api.TaskRequest, error) {
	res, err := ec.unmarshalInputTaskRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskResponse2githubcomMorhafAlshiblycoandaapiTaskResponse(ctx context.Context, sel ast.SelectionSet, v api.TaskResponse) graphql.Marshaler {
	return ec._TaskResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskResponse2githubcomMorhafAlshiblycoandaapiTaskResponse(ctx context.Context, sel ast.SelectionSet, v *api.TaskResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNTeam2githubcomMorhafAlshiblycoandaapiTeam(ctx context.Context, sel ast.SelectionSet, v []*api.Team) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTeam2githubcomMorhafAlshiblycoandaapiTeam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNTeamError2githubcomMorhafAlshiblycoandainternalbffmodelTeamError(ctx context.Context, v any) (model.TeamError, error) {
	var res model.TeamError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamError2githubcomMorhafAlshiblycoandainternalbffmodelTeamError(ctx context.Context, sel ast.SelectionSet, v model.TeamError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTeamMember2githubcomMorhafAlshiblycoandaapiTeamMember(ctx context.Context, sel ast.SelectionSet, v []*api.TeamMember) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTeamMember2githubcomMorhafAlshiblycoandaapiTeamMember(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNTeamMemberRequest2githubcomMorhafAlshiblycoandaapiTeamMemberRequest(ctx context.Context, v any) (*api.TeamMemberRequest, error) {
	res, err := ec.unmarshalInputTeamMemberRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTeamRequest2githubcomMorhafAlshiblycoandaapiTeamRequest(ctx context.Context, v any) (*api.TeamRequest, error) {
	res, err := ec.unmarshalInputTeamRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamResponse2githubcomMorhafAlshiblycoandaapiTeamResponse(ctx context.Context, sel ast.SelectionSet, v api.TeamResponse) graphql.Marshaler {
	return ec._TeamResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamResponse2githubcomMorhafAlshiblycoandaapiTeamResponse(ctx context.Context, sel ast.SelectionSet, v *api.TeamResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx context.Context, v any) (*timestamppb.Timestamp, error) {
	res, err := scalar.UnmarshalProtobufTimestamp(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx context.Context, sel ast.SelectionSet, v *timestamppb.Timestamp) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := scalar.MarshalProtobufTimestamp(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTournamentInterval2githubcomMorhafAlshiblycoandapkggraphqlEnumsTournamentInterval(ctx context.Context, v any) (graphqlEnums.TournamentInterval, error) {
	var res graphqlEnums.TournamentInterval
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTournamentInterval2githubcomMorhafAlshiblycoandapkggraphqlEnumsTournamentInterval(ctx context.Context, sel ast.SelectionSet, v graphqlEnums.TournamentInterval) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTournamentUser2githubcomMorhafAlshiblycoandaapiTournamentUser(ctx context.Context, sel ast.SelectionSet, v []*api.TournamentUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTournamentUser2githubcomMorhafAlshiblycoandaapiTournamentUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNTournamentUserError2githubcomMorhafAlshiblycoandainternalbffmodelTournamentUserError(ctx context.Context, v any) (model.TournamentUserError, error) {
	var res model.TournamentUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTournamentUserError2githubcomMorhafAlshiblycoandainternalbffmodelTournamentUserError(ctx context.Context, sel ast.SelectionSet, v model.TournamentUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTournamentUserRequest2githubcomMorhafAlshiblycoandaapiTournamentUserRequest(ctx context.Context, v any) (*api.TournamentUserRequest, error) {
	res, err := ec.unmarshalInputTournamentUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTournamentUserResponse2githubcomMorhafAlshiblycoandaapiTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v api.TournamentUserResponse) graphql.Marshaler {
	return ec._TournamentUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNTournamentUserResponse2githubcomMorhafAlshiblycoandaapiTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.TournamentUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TournamentUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUint322uint32(ctx context.Context, v any) (uint32, error) {
	res, err := graphql.UnmarshalUint32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint322uint32(ctx context.Context, sel ast.SelectionSet, v uint32) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalUint32(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUint642uint64(ctx context.Context, v any) (uint64, error) {
	res, err := graphql.UnmarshalUint64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint642uint64(ctx context.Context, sel ast.SelectionSet, v uint64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalUint64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUint642uint64(ctx context.Context, v any) ([]uint64, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]uint64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUint642uint64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNUint642uint64(ctx context.Context, sel ast.SelectionSet, v []uint64) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNUint642uint64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNUpdateArenaError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateArenaError(ctx context.Context, v any) (model.UpdateArenaError, error) {
	var res model.UpdateArenaError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateArenaError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateArenaError(ctx context.Context, sel ast.SelectionSet, v model.UpdateArenaError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateArenaResponse2githubcomMorhafAlshiblycoandaapiUpdateArenaResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateArenaResponse) graphql.Marshaler {
	return ec._UpdateArenaResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateArenaResponse2githubcomMorhafAlshiblycoandaapiUpdateArenaResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateArenaResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateArenaResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateEventError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateEventError(ctx context.Context, v any) (model.UpdateEventError, error) {
	var res model.UpdateEventError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateEventError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateEventError(ctx context.Context, sel ast.SelectionSet, v model.UpdateEventError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateEventResponse2githubcomMorhafAlshiblycoandaapiUpdateEventResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateEventResponse) graphql.Marshaler {
	return ec._UpdateEventResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateEventResponse2githubcomMorhafAlshiblycoandaapiUpdateEventResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateEventResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateEventResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateEventRoundError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateEventRoundError(ctx context.Context, v any) (model.UpdateEventRoundError, error) {
	var res model.UpdateEventRoundError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateEventRoundError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateEventRoundError(ctx context.Context, sel ast.SelectionSet, v model.UpdateEventRoundError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateEventRoundResponse2githubcomMorhafAlshiblycoandaapiUpdateEventRoundResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateEventRoundResponse) graphql.Marshaler {
	return ec._UpdateEventRoundResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateEventRoundResponse2githubcomMorhafAlshiblycoandaapiUpdateEventRoundResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateEventRoundResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateEventRoundResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateEventUserError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateEventUserError(ctx context.Context, v any) (model.UpdateEventUserError, error) {
	var res model.UpdateEventUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateEventUserError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateEventUserError(ctx context.Context, sel ast.SelectionSet, v model.UpdateEventUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateEventUserResponse2githubcomMorhafAlshiblycoandaapiUpdateEventUserResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateEventUserResponse) graphql.Marshaler {
	return ec._UpdateEventUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateEventUserResponse2githubcomMorhafAlshiblycoandaapiUpdateEventUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateEventUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateEventUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateItemError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateItemError(ctx context.Context, v any) (model.UpdateItemError, error) {
	var res model.UpdateItemError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateItemError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateItemError(ctx context.Context, sel ast.SelectionSet, v model.UpdateItemError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateItemResponse2githubcomMorhafAlshiblycoandaapiUpdateItemResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateItemResponse) graphql.Marshaler {
	return ec._UpdateItemResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateItemResponse2githubcomMorhafAlshiblycoandaapiUpdateItemResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateItemResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateItemResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateMatchError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateMatchError(ctx context.Context, v any) (model.UpdateMatchError, error) {
	var res model.UpdateMatchError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateMatchError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateMatchError(ctx context.Context, sel ast.SelectionSet, v model.UpdateMatchError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateMatchResponse2githubcomMorhafAlshiblycoandaapiUpdateMatchResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateMatchResponse) graphql.Marshaler {
	return ec._UpdateMatchResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateMatchResponse2githubcomMorhafAlshiblycoandaapiUpdateMatchResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateMatchResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateMatchResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateMatchmakingTicketError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateMatchmakingTicketError(ctx context.Context, v any) (model.UpdateMatchmakingTicketError, error) {
	var res model.UpdateMatchmakingTicketError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateMatchmakingTicketError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateMatchmakingTicketError(ctx context.Context, sel ast.SelectionSet, v model.UpdateMatchmakingTicketError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateMatchmakingTicketResponse2githubcomMorhafAlshiblycoandaapiUpdateMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateMatchmakingTicketResponse) graphql.Marshaler {
	return ec._UpdateMatchmakingTicketResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateMatchmakingTicketResponse2githubcomMorhafAlshiblycoandaapiUpdateMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateMatchmakingTicketResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateMatchmakingTicketResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateMatchmakingUserError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateMatchmakingUserError(ctx context.Context, v any) (model.UpdateMatchmakingUserError, error) {
	var res model.UpdateMatchmakingUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateMatchmakingUserError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateMatchmakingUserError(ctx context.Context, sel ast.SelectionSet, v model.UpdateMatchmakingUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateMatchmakingUserResponse2githubcomMorhafAlshiblycoandaapiUpdateMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateMatchmakingUserResponse) graphql.Marshaler {
	return ec._UpdateMatchmakingUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateMatchmakingUserResponse2githubcomMorhafAlshiblycoandaapiUpdateMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateMatchmakingUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateMatchmakingUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateRecordError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateRecordError(ctx context.Context, v any) (model.UpdateRecordError, error) {
	var res model.UpdateRecordError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateRecordError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateRecordError(ctx context.Context, sel ast.SelectionSet, v model.UpdateRecordError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateRecordResponse2githubcomMorhafAlshiblycoandaapiUpdateRecordResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateRecordResponse) graphql.Marshaler {
	return ec._UpdateRecordResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateRecordResponse2githubcomMorhafAlshiblycoandaapiUpdateRecordResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateRecordResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateRecordResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateTaskError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateTaskError(ctx context.Context, v any) (model.UpdateTaskError, error) {
	var res model.UpdateTaskError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTaskError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateTaskError(ctx context.Context, sel ast.SelectionSet, v model.UpdateTaskError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateTaskResponse2githubcomMorhafAlshiblycoandaapiUpdateTaskResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateTaskResponse) graphql.Marshaler {
	return ec._UpdateTaskResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTaskResponse2githubcomMorhafAlshiblycoandaapiUpdateTaskResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateTaskResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTaskResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateTeamError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateTeamError(ctx context.Context, v any) (model.UpdateTeamError, error) {
	var res model.UpdateTeamError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTeamError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateTeamError(ctx context.Context, sel ast.SelectionSet, v model.UpdateTeamError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUpdateTeamMemberError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateTeamMemberError(ctx context.Context, v any) (model.UpdateTeamMemberError, error) {
	var res model.UpdateTeamMemberError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTeamMemberError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateTeamMemberError(ctx context.Context, sel ast.SelectionSet, v model.UpdateTeamMemberError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateTeamMemberResponse2githubcomMorhafAlshiblycoandaapiUpdateTeamMemberResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateTeamMemberResponse) graphql.Marshaler {
	return ec._UpdateTeamMemberResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTeamMemberResponse2githubcomMorhafAlshiblycoandaapiUpdateTeamMemberResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateTeamMemberResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTeamMemberResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNUpdateTeamResponse2githubcomMorhafAlshiblycoandaapiUpdateTeamResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateTeamResponse) graphql.Marshaler {
	return ec._UpdateTeamResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTeamResponse2githubcomMorhafAlshiblycoandaapiUpdateTeamResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateTeamResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTeamResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateTournamentUserError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateTournamentUserError(ctx context.Context, v any) (model.UpdateTournamentUserError, error) {
	var res model.UpdateTournamentUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTournamentUserError2githubcomMorhafAlshiblycoandainternalbffmodelUpdateTournamentUserError(ctx context.Context, sel ast.SelectionSet, v model.UpdateTournamentUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateTournamentUserResponse2githubcomMorhafAlshiblycoandaapiUpdateTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateTournamentUserResponse) graphql.Marshaler {
	return ec._UpdateTournamentUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTournamentUserResponse2githubcomMorhafAlshiblycoandaapiUpdateTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateTournamentUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTournamentUserResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNWebhookResponse2githubcomMorhafAlshiblycoandaapiWebhookResponse(ctx context.Context, sel ast.SelectionSet, v api.WebhookResponse) graphql.Marshaler {
	return ec._WebhookResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNWebhookResponse2githubcomMorhafAlshiblycoandaapiWebhookResponse(ctx context.Context, sel ast.SelectionSet, v *api.WebhookResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WebhookResponse(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAddEventResultRequest2githubcomMorhafAlshiblycoandaapiAddEventResultRequest(ctx context.Context, v any) (*api.AddEventResultRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAddEventResultRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOArena2githubcomMorhafAlshiblycoandaapiArena(ctx context.Context, sel ast.SelectionSet, v []*api.Arena) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOArena2githubcomMorhafAlshiblycoandaapiArena(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOArena2githubcomMorhafAlshiblycoandaapiArena(ctx context.Context, sel ast.SelectionSet, v *api.Arena) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Arena(ctx, sel, v)
}

func (ec *executionContext) unmarshalOArenaRequest2githubcomMorhafAlshiblycoandaapiArenaRequest(ctx context.Context, v any) (*api.ArenaRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputArenaRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCreateArenaRequest2githubcomMorhafAlshiblycoandaapiCreateArenaRequest(ctx context.Context, v any) (*api.CreateArenaRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateArenaRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateEventRequest2githubcomMorhafAlshiblycoandaapiCreateEventRequest(ctx context.Context, v any) (*api.CreateEventRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateEventRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateEventRound2githubcomMorhafAlshiblycoandaapiCreateEventRound(ctx context.Context, v any) (*api.CreateEventRound, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateEventRound(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateEventRoundRequest2githubcomMorhafAlshiblycoandaapiCreateEventRoundRequest(ctx context.Context, v any) (*api.CreateEventRoundRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateEventRoundRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateItemRequest2githubcomMorhafAlshiblycoandaapiCreateItemRequest(ctx context.Context, v any) (*api.CreateItemRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateItemRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateMatchmakingTicketRequest2githubcomMorhafAlshiblycoandaapiCreateMatchmakingTicketRequest(ctx context.Context, v any) (*api.CreateMatchmakingTicketRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateMatchmakingTicketRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiCreateMatchmakingUserRequest(ctx context.Context, v any) (*api.CreateMatchmakingUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateMatchmakingUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateRecordRequest2githubcomMorhafAlshiblycoandaapiCreateRecordRequest(ctx context.Context, v any) (*api.CreateRecordRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateRecordRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateTaskRequest2githubcomMorhafAlshiblycoandaapiCreateTaskRequest(ctx context.Context, v any) (*api.CreateTaskRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateTaskRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateTeamRequest2githubcomMorhafAlshiblycoandaapiCreateTeamRequest(ctx context.Context, v any) (*api.CreateTeamRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateTeamRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateTournamentUserRequest2githubcomMorhafAlshiblycoandaapiCreateTournamentUserRequest(ctx context.Context, v any) (*api.CreateTournamentUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateTournamentUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEndMatchRequest2githubcomMorhafAlshiblycoandaapiEndMatchRequest(ctx context.Context, v any) (*api.EndMatchRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEndMatchRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEvent2githubcomMorhafAlshiblycoandaapiEvent(ctx context.Context, sel ast.SelectionSet, v *api.Event) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventRequest2githubcomMorhafAlshiblycoandaapiEventRequest(ctx context.Context, v any) (*api.EventRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventRound2githubcomMorhafAlshiblycoandaapiEventRound(ctx context.Context, sel ast.SelectionSet, v *api.EventRound) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventRound(ctx, sel, v)
}

func (ec *executionContext) marshalOEventRoundUser2githubcomMorhafAlshiblycoandaapiEventRoundUser(ctx context.Context, sel ast.SelectionSet, v *api.EventRoundUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventRoundUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventRoundUserRequest2githubcomMorhafAlshiblycoandaapiEventRoundUserRequest(ctx context.Context, v any) (*api.EventRoundUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventRoundUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventUser2githubcomMorhafAlshiblycoandaapiEventUser(ctx context.Context, sel ast.SelectionSet, v *api.EventUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventUserRequest2githubcomMorhafAlshiblycoandaapiEventUserRequest(ctx context.Context, v any) (*api.EventUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetEventRequest2githubcomMorhafAlshiblycoandaapiGetEventRequest(ctx context.Context, v any) (*api.GetEventRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetEventRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetEventRoundRequest2githubcomMorhafAlshiblycoandaapiGetEventRoundRequest(ctx context.Context, v any) (*api.GetEventRoundRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetEventRoundRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetEventUserRequest2githubcomMorhafAlshiblycoandaapiGetEventUserRequest(ctx context.Context, v any) (*api.GetEventUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetEventUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetItemsRequest2githubcomMorhafAlshiblycoandaapiGetItemsRequest(ctx context.Context, v any) (*api.GetItemsRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetItemsRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetMatchRequest2githubcomMorhafAlshiblycoandaapiGetMatchRequest(ctx context.Context, v any) (*api.GetMatchRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetMatchRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetMatchesRequest2githubcomMorhafAlshiblycoandaapiGetMatchesRequest(ctx context.Context, v any) (*api.GetMatchesRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetMatchesRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetMatchmakingTicketRequest2githubcomMorhafAlshiblycoandaapiGetMatchmakingTicketRequest(ctx context.Context, v any) (*api.GetMatchmakingTicketRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetMatchmakingTicketRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetMatchmakingTicketsRequest2githubcomMorhafAlshiblycoandaapiGetMatchmakingTicketsRequest(ctx context.Context, v any) (*api.GetMatchmakingTicketsRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetMatchmakingTicketsRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetRecordsRequest2githubcomMorhafAlshiblycoandaapiGetRecordsRequest(ctx context.Context, v any) (*api.GetRecordsRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetRecordsRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetTasksRequest2githubcomMorhafAlshiblycoandaapiGetTasksRequest(ctx context.Context, v any) (*api.GetTasksRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetTasksRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetTeamRequest2githubcomMorhafAlshiblycoandaapiGetTeamRequest(ctx context.Context, v any) (*api.GetTeamRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetTeamRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetTeamsRequest2githubcomMorhafAlshiblycoandaapiGetTeamsRequest(ctx context.Context, v any) (*api.GetTeamsRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetTeamsRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetTournamentUsersRequest2githubcomMorhafAlshiblycoandaapiGetTournamentUsersRequest(ctx context.Context, v any) (*api.GetTournamentUsersRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetTournamentUsersRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInt642int64(ctx context.Context, v any) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt642int64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) marshalOItem2githubcomMorhafAlshiblycoandaapiItem(ctx context.Context, sel ast.SelectionSet, v *api.Item) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Item(ctx, sel, v)
}

func (ec *executionContext) unmarshalOItemRequest2githubcomMorhafAlshiblycoandaapiItemRequest(ctx context.Context, v any) (*api.ItemRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputItemRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOJoinTeamRequest2githubcomMorhafAlshiblycoandaapiJoinTeamRequest(ctx context.Context, v any) (*api.JoinTeamRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJoinTeamRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatch2githubcomMorhafAlshiblycoandaapiMatch(ctx context.Context, sel ast.SelectionSet, v []*api.Match) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatch2githubcomMorhafAlshiblycoandaapiMatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMatch2githubcomMorhafAlshiblycoandaapiMatch(ctx context.Context, sel ast.SelectionSet, v *api.Match) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Match(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMatchRequest2githubcomMorhafAlshiblycoandaapiMatchRequest(ctx context.Context, v any) (*api.MatchRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMatchStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchStatus(ctx context.Context, v any) ([]*model.MatchStatus, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.MatchStatus, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOMatchStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMatchStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchStatus(ctx context.Context, sel ast.SelectionSet, v []*model.MatchStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatchStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalOMatchStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchStatus(ctx context.Context, v any) (*model.MatchStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.MatchStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatchStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchStatus(ctx context.Context, sel ast.SelectionSet, v *model.MatchStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOMatchmakingTicket2githubcomMorhafAlshiblycoandaapiMatchmakingTicket(ctx context.Context, sel ast.SelectionSet, v []*api.MatchmakingTicket) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatchmakingTicket2githubcomMorhafAlshiblycoandaapiMatchmakingTicket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMatchmakingTicket2githubcomMorhafAlshiblycoandaapiMatchmakingTicket(ctx context.Context, sel ast.SelectionSet, v *api.MatchmakingTicket) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MatchmakingTicket(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMatchmakingTicketRequest2githubcomMorhafAlshiblycoandaapiMatchmakingTicketRequest(ctx context.Context, v any) (*api.MatchmakingTicketRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchmakingTicketRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMatchmakingTicketStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchmakingTicketStatus(ctx context.Context, v any) ([]*model.MatchmakingTicketStatus, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.MatchmakingTicketStatus, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOMatchmakingTicketStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchmakingTicketStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMatchmakingTicketStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchmakingTicketStatus(ctx context.Context, sel ast.SelectionSet, v []*model.MatchmakingTicketStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatchmakingTicketStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchmakingTicketStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalOMatchmakingTicketStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchmakingTicketStatus(ctx context.Context, v any) (*model.MatchmakingTicketStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.MatchmakingTicketStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatchmakingTicketStatus2githubcomMorhafAlshiblycoandainternalbffmodelMatchmakingTicketStatus(ctx context.Context, sel ast.SelectionSet, v *model.MatchmakingTicketStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOMatchmakingUser2githubcomMorhafAlshiblycoandaapiMatchmakingUser(ctx context.Context, sel ast.SelectionSet, v []*api.MatchmakingUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatchmakingUser2githubcomMorhafAlshiblycoandaapiMatchmakingUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMatchmakingUser2githubcomMorhafAlshiblycoandaapiMatchmakingUser(ctx context.Context, sel ast.SelectionSet, v *api.MatchmakingUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MatchmakingUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiMatchmakingUserRequest(ctx context.Context, v any) (*api.MatchmakingUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchmakingUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONameUserId2githubcomMorhafAlshiblycoandaapiNameUserId(ctx context.Context, v any) (*api.NameUserId, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNameUserId(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPagination2githubcomMorhafAlshiblycoandaapiPagination(ctx context.Context, v any) (*api.Pagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPagination(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORecord2githubcomMorhafAlshiblycoandaapiRecord(ctx context.Context, sel ast.SelectionSet, v *api.Record) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Record(ctx, sel, v)
}

func (ec *executionContext) unmarshalORecordRequest2githubcomMorhafAlshiblycoandaapiRecordRequest(ctx context.Context, v any) (*api.RecordRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRecordRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchTeamsRequest2githubcomMorhafAlshiblycoandaapiSearchTeamsRequest(ctx context.Context, v any) (*api.SearchTeamsRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchTeamsRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSetMatchPrivateServerRequest2githubcomMorhafAlshiblycoandaapiSetMatchPrivateServerRequest(ctx context.Context, v any) (*api.SetMatchPrivateServerRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSetMatchPrivateServerRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOStartMatchRequest2githubcomMorhafAlshiblycoandaapiStartMatchRequest(ctx context.Context, v any) (*api.StartMatchRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStartMatchRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx context.Context, v any) (*structpb.Struct, error) {
	if v == nil {
		return nil, nil
	}
	res, err := scalar.UnmarshalProtobufStruct(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStruct2googlegolangorgprotobuftypesknownstructpbStruct(ctx context.Context, sel ast.SelectionSet, v *structpb.Struct) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := scalar.MarshalProtobufStruct(v)
	return res
}

func (ec *executionContext) marshalOTask2githubcomMorhafAlshiblycoandaapiTask(ctx context.Context, sel ast.SelectionSet, v *api.Task) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTaskRequest2githubcomMorhafAlshiblycoandaapiTaskRequest(ctx context.Context, v any) (*api.TaskRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTaskRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTeam2githubcomMorhafAlshiblycoandaapiTeam(ctx context.Context, sel ast.SelectionSet, v *api.Team) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Team(ctx, sel, v)
}

func (ec *executionContext) marshalOTeamMember2githubcomMorhafAlshiblycoandaapiTeamMember(ctx context.Context, sel ast.SelectionSet, v *api.TeamMember) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamMember(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTeamMemberRequest2githubcomMorhafAlshiblycoandaapiTeamMemberRequest(ctx context.Context, v any) (*api.TeamMemberRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamMemberRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTeamRequest2githubcomMorhafAlshiblycoandaapiTeamRequest(ctx context.Context, v any) (*api.TeamRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx context.Context, v any) (*timestamppb.Timestamp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := scalar.UnmarshalProtobufTimestamp(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTimestamp2googlegolangorgprotobuftypesknowntimestamppbTimestamp(ctx context.Context, sel ast.SelectionSet, v *timestamppb.Timestamp) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := scalar.MarshalProtobufTimestamp(v)
	return res
}

func (ec *executionContext) unmarshalOTournamentIntervalUserId2githubcomMorhafAlshiblycoandaapiTournamentIntervalUserId(ctx context.Context, v any) (*api.TournamentIntervalUserId, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTournamentIntervalUserId(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTournamentUser2githubcomMorhafAlshiblycoandaapiTournamentUser(ctx context.Context, sel ast.SelectionSet, v *api.TournamentUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TournamentUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTournamentUserRequest2githubcomMorhafAlshiblycoandaapiTournamentUserRequest(ctx context.Context, v any) (*api.TournamentUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTournamentUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUint322uint32(ctx context.Context, v any) (*uint32, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUint32(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint322uint32(ctx context.Context, sel ast.SelectionSet, v *uint32) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalUint32(*v)
	return res
}

func (ec *executionContext) unmarshalOUint642uint64(ctx context.Context, v any) ([]uint64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]uint64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUint642uint64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUint642uint64(ctx context.Context, sel ast.SelectionSet, v []uint64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNUint642uint64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUint642uint64(ctx context.Context, v any) (*uint64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUint64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint642uint64(ctx context.Context, sel ast.SelectionSet, v *uint64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalUint64(*v)
	return res
}

func (ec *executionContext) unmarshalOUpdateArenaRequest2githubcomMorhafAlshiblycoandaapiUpdateArenaRequest(ctx context.Context, v any) (*api.UpdateArenaRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateArenaRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateEventRequest2githubcomMorhafAlshiblycoandaapiUpdateEventRequest(ctx context.Context, v any) (*api.UpdateEventRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateEventRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateEventRoundRequest2githubcomMorhafAlshiblycoandaapiUpdateEventRoundRequest(ctx context.Context, v any) (*api.UpdateEventRoundRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateEventRoundRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateEventUserRequest2githubcomMorhafAlshiblycoandaapiUpdateEventUserRequest(ctx context.Context, v any) (*api.UpdateEventUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateEventUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateItemRequest2githubcomMorhafAlshiblycoandaapiUpdateItemRequest(ctx context.Context, v any) (*api.UpdateItemRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateItemRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateMatchRequest2githubcomMorhafAlshiblycoandaapiUpdateMatchRequest(ctx context.Context, v any) (*api.UpdateMatchRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateMatchRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateMatchmakingTicketRequest2githubcomMorhafAlshiblycoandaapiUpdateMatchmakingTicketRequest(ctx context.Context, v any) (*api.UpdateMatchmakingTicketRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateMatchmakingTicketRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateMatchmakingUserRequest2githubcomMorhafAlshiblycoandaapiUpdateMatchmakingUserRequest(ctx context.Context, v any) (*api.UpdateMatchmakingUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateMatchmakingUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateRecordRequest2githubcomMorhafAlshiblycoandaapiUpdateRecordRequest(ctx context.Context, v any) (*api.UpdateRecordRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateRecordRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateTaskRequest2githubcomMorhafAlshiblycoandaapiUpdateTaskRequest(ctx context.Context, v any) (*api.UpdateTaskRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateTaskRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateTeamMemberRequest2githubcomMorhafAlshiblycoandaapiUpdateTeamMemberRequest(ctx context.Context, v any) (*api.UpdateTeamMemberRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateTeamMemberRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateTeamRequest2githubcomMorhafAlshiblycoandaapiUpdateTeamRequest(ctx context.Context, v any) (*api.UpdateTeamRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateTeamRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateTournamentUserRequest2githubcomMorhafAlshiblycoandaapiUpdateTournamentUserRequest(ctx context.Context, v any) (*api.UpdateTournamentUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateTournamentUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWebhookRequest2githubcomMorhafAlshiblycoandaapiWebhookRequest(ctx context.Context, v any) (*api.WebhookRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWebhookRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
