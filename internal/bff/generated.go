// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package bff

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/MorhafAlshibly/coanda/api"
	"github.com/MorhafAlshibly/coanda/internal/bff/model"
	"github.com/MorhafAlshibly/coanda/pkg/graphqlEnums"
	"github.com/MorhafAlshibly/coanda/pkg/scalar"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AddEventResultResponse() AddEventResultResponseResolver
	CompleteTaskResponse() CompleteTaskResponseResolver
	CreateArenaResponse() CreateArenaResponseResolver
	CreateEventResponse() CreateEventResponseResolver
	CreateEventRoundResponse() CreateEventRoundResponseResolver
	CreateItemResponse() CreateItemResponseResolver
	CreateMatchmakingTicketResponse() CreateMatchmakingTicketResponseResolver
	CreateMatchmakingUserResponse() CreateMatchmakingUserResponseResolver
	CreateRecordResponse() CreateRecordResponseResolver
	CreateTaskResponse() CreateTaskResponseResolver
	CreateTeamResponse() CreateTeamResponseResolver
	CreateTournamentUserResponse() CreateTournamentUserResponseResolver
	DeleteMatchResponse() DeleteMatchResponseResolver
	DeleteMatchmakingTicketResponse() DeleteMatchmakingTicketResponseResolver
	DeleteMatchmakingUserResponse() DeleteMatchmakingUserResponseResolver
	DeleteRecordResponse() DeleteRecordResponseResolver
	EndMatchResponse() EndMatchResponseResolver
	EventResponse() EventResponseResolver
	EventUserResponse() EventUserResponseResolver
	GetArenaResponse() GetArenaResponseResolver
	GetEventResponse() GetEventResponseResolver
	GetEventRoundResponse() GetEventRoundResponseResolver
	GetEventUserResponse() GetEventUserResponseResolver
	GetItemResponse() GetItemResponseResolver
	GetMatchResponse() GetMatchResponseResolver
	GetMatchmakingTicketResponse() GetMatchmakingTicketResponseResolver
	GetMatchmakingTicketsResponse() GetMatchmakingTicketsResponseResolver
	GetMatchmakingUserResponse() GetMatchmakingUserResponseResolver
	GetRecordResponse() GetRecordResponseResolver
	GetRecordsResponse() GetRecordsResponseResolver
	GetTaskResponse() GetTaskResponseResolver
	GetTeamMemberResponse() GetTeamMemberResponseResolver
	GetTeamResponse() GetTeamResponseResolver
	GetTournamentUserResponse() GetTournamentUserResponseResolver
	GetTournamentUsersResponse() GetTournamentUsersResponseResolver
	ItemResponse() ItemResponseResolver
	JoinTeamResponse() JoinTeamResponseResolver
	LeaveTeamResponse() LeaveTeamResponseResolver
	Match() MatchResolver
	MatchmakingTicket() MatchmakingTicketResolver
	Mutation() MutationResolver
	Query() QueryResolver
	RemoveEventResultResponse() RemoveEventResultResponseResolver
	SearchTeamsResponse() SearchTeamsResponseResolver
	SetMatchPrivateServerResponse() SetMatchPrivateServerResponseResolver
	StartMatchResponse() StartMatchResponseResolver
	TaskResponse() TaskResponseResolver
	TeamResponse() TeamResponseResolver
	TournamentUser() TournamentUserResolver
	TournamentUserResponse() TournamentUserResponseResolver
	UpdateArenaResponse() UpdateArenaResponseResolver
	UpdateEventResponse() UpdateEventResponseResolver
	UpdateEventRoundResponse() UpdateEventRoundResponseResolver
	UpdateEventUserResponse() UpdateEventUserResponseResolver
	UpdateItemResponse() UpdateItemResponseResolver
	UpdateMatchResponse() UpdateMatchResponseResolver
	UpdateMatchmakingTicketResponse() UpdateMatchmakingTicketResponseResolver
	UpdateMatchmakingUserResponse() UpdateMatchmakingUserResponseResolver
	UpdateRecordResponse() UpdateRecordResponseResolver
	UpdateTaskResponse() UpdateTaskResponseResolver
	UpdateTeamMemberResponse() UpdateTeamMemberResponseResolver
	UpdateTeamResponse() UpdateTeamResponseResolver
	UpdateTournamentUserResponse() UpdateTournamentUserResponseResolver
	CreateTournamentUserRequest() CreateTournamentUserRequestResolver
	GetMatchesRequest() GetMatchesRequestResolver
	GetMatchmakingTicketsRequest() GetMatchmakingTicketsRequestResolver
	GetTournamentUsersRequest() GetTournamentUsersRequestResolver
	TournamentIntervalUserId() TournamentIntervalUserIdResolver
}

type DirectiveRoot struct {
	Doc     func(ctx context.Context, obj any, next graphql.Resolver, category *string) (res any, err error)
	Example func(ctx context.Context, obj any, next graphql.Resolver, value *string) (res any, err error)
}

type ComplexityRoot struct {
	AddEventResultResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	Arena struct {
		CreatedAt           func(childComplexity int) int
		Data                func(childComplexity int) int
		Id                  func(childComplexity int) int
		MaxPlayers          func(childComplexity int) int
		MaxPlayersPerTicket func(childComplexity int) int
		MinPlayers          func(childComplexity int) int
		Name                func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
	}

	CompleteTaskResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateArenaResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateEventResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateEventRoundResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateItemResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateMatchmakingTicketResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateMatchmakingUserResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateRecordResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateTaskResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateTeamResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	CreateTournamentUserResponse struct {
		Error   func(childComplexity int) int
		Id      func(childComplexity int) int
		Success func(childComplexity int) int
	}

	DeleteMatchResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	DeleteMatchmakingTicketResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	DeleteMatchmakingUserResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	DeleteRecordResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	EndMatchResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	Event struct {
		CreatedAt        func(childComplexity int) int
		CurrentRoundId   func(childComplexity int) int
		CurrentRoundName func(childComplexity int) int
		Data             func(childComplexity int) int
		Id               func(childComplexity int) int
		Name             func(childComplexity int) int
		Rounds           func(childComplexity int) int
		StartedAt        func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	EventResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	EventRound struct {
		CreatedAt func(childComplexity int) int
		Data      func(childComplexity int) int
		EndedAt   func(childComplexity int) int
		EventId   func(childComplexity int) int
		Id        func(childComplexity int) int
		Name      func(childComplexity int) int
		Scoring   func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	EventRoundUser struct {
		ClientUserId func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Data         func(childComplexity int) int
		EventRoundId func(childComplexity int) int
		EventUserId  func(childComplexity int) int
		Id           func(childComplexity int) int
		Ranking      func(childComplexity int) int
		Result       func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	EventUser struct {
		ClientUserId func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Data         func(childComplexity int) int
		EventId      func(childComplexity int) int
		Id           func(childComplexity int) int
		Ranking      func(childComplexity int) int
		Score        func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	EventUserResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetArenaResponse struct {
		Arena   func(childComplexity int) int
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetArenasResponse struct {
		Arenas  func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetEventResponse struct {
		Error       func(childComplexity int) int
		Event       func(childComplexity int) int
		Leaderboard func(childComplexity int) int
		Success     func(childComplexity int) int
	}

	GetEventRoundResponse struct {
		Error   func(childComplexity int) int
		Results func(childComplexity int) int
		Round   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetEventUserResponse struct {
		Error   func(childComplexity int) int
		Results func(childComplexity int) int
		Success func(childComplexity int) int
		User    func(childComplexity int) int
	}

	GetItemResponse struct {
		Error   func(childComplexity int) int
		Item    func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetItemsResponse struct {
		Items   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetMatchResponse struct {
		Error   func(childComplexity int) int
		Match   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetMatchesResponse struct {
		Matches func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetMatchmakingTicketResponse struct {
		Error             func(childComplexity int) int
		MatchmakingTicket func(childComplexity int) int
		Success           func(childComplexity int) int
	}

	GetMatchmakingTicketsResponse struct {
		Error              func(childComplexity int) int
		MatchmakingTickets func(childComplexity int) int
		Success            func(childComplexity int) int
	}

	GetMatchmakingUserResponse struct {
		Error           func(childComplexity int) int
		MatchmakingUser func(childComplexity int) int
		Success         func(childComplexity int) int
	}

	GetMatchmakingUsersResponse struct {
		MatchmakingUsers func(childComplexity int) int
		Success          func(childComplexity int) int
	}

	GetRecordResponse struct {
		Error   func(childComplexity int) int
		Record  func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetRecordsResponse struct {
		Error   func(childComplexity int) int
		Records func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetTaskResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
		Task    func(childComplexity int) int
	}

	GetTasksResponse struct {
		Success func(childComplexity int) int
		Tasks   func(childComplexity int) int
	}

	GetTeamMemberResponse struct {
		Error   func(childComplexity int) int
		Member  func(childComplexity int) int
		Success func(childComplexity int) int
	}

	GetTeamResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
		Team    func(childComplexity int) int
	}

	GetTeamsResponse struct {
		Success func(childComplexity int) int
		Teams   func(childComplexity int) int
	}

	GetTournamentUserResponse struct {
		Error          func(childComplexity int) int
		Success        func(childComplexity int) int
		TournamentUser func(childComplexity int) int
	}

	GetTournamentUsersResponse struct {
		Error           func(childComplexity int) int
		Success         func(childComplexity int) int
		TournamentUsers func(childComplexity int) int
	}

	Item struct {
		CreatedAt func(childComplexity int) int
		Data      func(childComplexity int) int
		ExpiresAt func(childComplexity int) int
		Id        func(childComplexity int) int
		Type      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	ItemResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	JoinTeamResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	LeaveTeamResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	Match struct {
		Arena           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Data            func(childComplexity int) int
		EndedAt         func(childComplexity int) int
		Id              func(childComplexity int) int
		LockedAt        func(childComplexity int) int
		PrivateServerId func(childComplexity int) int
		StartedAt       func(childComplexity int) int
		Status          func(childComplexity int) int
		Tickets         func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
	}

	MatchmakingTicket struct {
		Arenas           func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		Data             func(childComplexity int) int
		Id               func(childComplexity int) int
		MatchId          func(childComplexity int) int
		MatchmakingUsers func(childComplexity int) int
		Status           func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	MatchmakingUser struct {
		ClientUserId func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Data         func(childComplexity int) int
		Elo          func(childComplexity int) int
		Id           func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	Mutation struct {
		AddEventResult          func(childComplexity int, input *api.AddEventResultRequest) int
		CompleteTask            func(childComplexity int, input *api.TaskRequest) int
		CreateArena             func(childComplexity int, input *api.CreateArenaRequest) int
		CreateEvent             func(childComplexity int, input *api.CreateEventRequest) int
		CreateEventRound        func(childComplexity int, input *api.CreateEventRoundRequest) int
		CreateItem              func(childComplexity int, input *api.CreateItemRequest) int
		CreateMatchmakingTicket func(childComplexity int, input *api.CreateMatchmakingTicketRequest) int
		CreateMatchmakingUser   func(childComplexity int, input *api.CreateMatchmakingUserRequest) int
		CreateRecord            func(childComplexity int, input *api.CreateRecordRequest) int
		CreateTask              func(childComplexity int, input *api.CreateTaskRequest) int
		CreateTeam              func(childComplexity int, input *api.CreateTeamRequest) int
		CreateTournamentUser    func(childComplexity int, input *api.CreateTournamentUserRequest) int
		DeleteEvent             func(childComplexity int, input *api.EventRequest) int
		DeleteEventUser         func(childComplexity int, input *api.EventUserRequest) int
		DeleteItem              func(childComplexity int, input *api.ItemRequest) int
		DeleteMatch             func(childComplexity int, input *api.MatchRequest) int
		DeleteMatchmakingTicket func(childComplexity int, input *api.MatchmakingTicketRequest) int
		DeleteMatchmakingUser   func(childComplexity int, input *api.MatchmakingUserRequest) int
		DeleteRecord            func(childComplexity int, input *api.RecordRequest) int
		DeleteTask              func(childComplexity int, input *api.TaskRequest) int
		DeleteTeam              func(childComplexity int, input *api.TeamRequest) int
		DeleteTournamentUser    func(childComplexity int, input *api.TournamentUserRequest) int
		EndMatch                func(childComplexity int, input *api.EndMatchRequest) int
		JoinTeam                func(childComplexity int, input *api.JoinTeamRequest) int
		LeaveTeam               func(childComplexity int, input *api.TeamMemberRequest) int
		RemoveEventResult       func(childComplexity int, input *api.EventRoundUserRequest) int
		SetMatchPrivateServer   func(childComplexity int, input *api.SetMatchPrivateServerRequest) int
		StartMatch              func(childComplexity int, input *api.StartMatchRequest) int
		UpdateArena             func(childComplexity int, input *api.UpdateArenaRequest) int
		UpdateEvent             func(childComplexity int, input *api.UpdateEventRequest) int
		UpdateEventRound        func(childComplexity int, input *api.UpdateEventRoundRequest) int
		UpdateEventUser         func(childComplexity int, input *api.UpdateEventUserRequest) int
		UpdateItem              func(childComplexity int, input *api.UpdateItemRequest) int
		UpdateMatch             func(childComplexity int, input *api.UpdateMatchRequest) int
		UpdateMatchmakingTicket func(childComplexity int, input *api.UpdateMatchmakingTicketRequest) int
		UpdateMatchmakingUser   func(childComplexity int, input *api.UpdateMatchmakingUserRequest) int
		UpdateRecord            func(childComplexity int, input *api.UpdateRecordRequest) int
		UpdateTask              func(childComplexity int, input *api.UpdateTaskRequest) int
		UpdateTeam              func(childComplexity int, input *api.UpdateTeamRequest) int
		UpdateTeamMember        func(childComplexity int, input *api.UpdateTeamMemberRequest) int
		UpdateTournamentUser    func(childComplexity int, input *api.UpdateTournamentUserRequest) int
		Webhook                 func(childComplexity int, input *api.WebhookRequest) int
	}

	Query struct {
		GetArena              func(childComplexity int, input *api.ArenaRequest) int
		GetArenas             func(childComplexity int, input *api.Pagination) int
		GetEvent              func(childComplexity int, input *api.GetEventRequest) int
		GetEventRound         func(childComplexity int, input *api.GetEventRoundRequest) int
		GetEventUser          func(childComplexity int, input *api.GetEventUserRequest) int
		GetItem               func(childComplexity int, input *api.ItemRequest) int
		GetItems              func(childComplexity int, input *api.GetItemsRequest) int
		GetMatch              func(childComplexity int, input *api.GetMatchRequest) int
		GetMatches            func(childComplexity int, input *api.GetMatchesRequest) int
		GetMatchmakingTicket  func(childComplexity int, input *api.GetMatchmakingTicketRequest) int
		GetMatchmakingTickets func(childComplexity int, input *api.GetMatchmakingTicketsRequest) int
		GetMatchmakingUser    func(childComplexity int, input *api.MatchmakingUserRequest) int
		GetMatchmakingUsers   func(childComplexity int, input *api.Pagination) int
		GetRecord             func(childComplexity int, input *api.RecordRequest) int
		GetRecords            func(childComplexity int, input *api.GetRecordsRequest) int
		GetTask               func(childComplexity int, input *api.TaskRequest) int
		GetTasks              func(childComplexity int, input *api.GetTasksRequest) int
		GetTeam               func(childComplexity int, input *api.GetTeamRequest) int
		GetTeamMember         func(childComplexity int, input *api.TeamMemberRequest) int
		GetTeams              func(childComplexity int, input *api.GetTeamsRequest) int
		GetTournamentUser     func(childComplexity int, input *api.TournamentUserRequest) int
		GetTournamentUsers    func(childComplexity int, input *api.GetTournamentUsersRequest) int
		SearchTeams           func(childComplexity int, input *api.SearchTeamsRequest) int
	}

	Record struct {
		CreatedAt func(childComplexity int) int
		Data      func(childComplexity int) int
		Id        func(childComplexity int) int
		Name      func(childComplexity int) int
		Ranking   func(childComplexity int) int
		Record    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		UserId    func(childComplexity int) int
	}

	RemoveEventResultResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	SearchTeamsResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
		Teams   func(childComplexity int) int
	}

	SetMatchPrivateServerResponse struct {
		Error           func(childComplexity int) int
		PrivateServerId func(childComplexity int) int
		Success         func(childComplexity int) int
	}

	StartMatchResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	Task struct {
		CompletedAt func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Data        func(childComplexity int) int
		ExpiresAt   func(childComplexity int) int
		Id          func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	TaskResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	Team struct {
		CreatedAt func(childComplexity int) int
		Data      func(childComplexity int) int
		Id        func(childComplexity int) int
		Members   func(childComplexity int) int
		Name      func(childComplexity int) int
		Ranking   func(childComplexity int) int
		Score     func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	TeamMember struct {
		Data      func(childComplexity int) int
		Id        func(childComplexity int) int
		JoinedAt  func(childComplexity int) int
		TeamId    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		UserId    func(childComplexity int) int
	}

	TeamResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	TournamentUser struct {
		CreatedAt           func(childComplexity int) int
		Data                func(childComplexity int) int
		Id                  func(childComplexity int) int
		Interval            func(childComplexity int) int
		Ranking             func(childComplexity int) int
		Score               func(childComplexity int) int
		Tournament          func(childComplexity int) int
		TournamentStartedAt func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
		UserId              func(childComplexity int) int
	}

	TournamentUserResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateArenaResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateEventResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateEventRoundResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateEventUserResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateItemResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateMatchResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateMatchmakingTicketResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateMatchmakingUserResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateRecordResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateTaskResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateTeamMemberResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateTeamResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UpdateTournamentUserResponse struct {
		Error   func(childComplexity int) int
		Success func(childComplexity int) int
	}

	WebhookResponse struct {
		Body    func(childComplexity int) int
		Headers func(childComplexity int) int
		Status  func(childComplexity int) int
	}
}

type AddEventResultResponseResolver interface {
	Error(ctx context.Context, obj *api.AddEventResultResponse) (model.AddEventResultError, error)
}
type CompleteTaskResponseResolver interface {
	Error(ctx context.Context, obj *api.CompleteTaskResponse) (model.CompleteTaskError, error)
}
type CreateArenaResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateArenaResponse) (model.CreateArenaError, error)
}
type CreateEventResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateEventResponse) (model.CreateEventError, error)
}
type CreateEventRoundResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateEventRoundResponse) (model.CreateEventRoundError, error)
}
type CreateItemResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateItemResponse) (model.CreateItemError, error)
}
type CreateMatchmakingTicketResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateMatchmakingTicketResponse) (model.CreateMatchmakingTicketError, error)
}
type CreateMatchmakingUserResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateMatchmakingUserResponse) (model.CreateMatchmakingUserError, error)
}
type CreateRecordResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateRecordResponse) (model.CreateRecordError, error)
}
type CreateTaskResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateTaskResponse) (model.CreateTaskError, error)
}
type CreateTeamResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateTeamResponse) (model.CreateTeamError, error)
}
type CreateTournamentUserResponseResolver interface {
	Error(ctx context.Context, obj *api.CreateTournamentUserResponse) (model.CreateTournamentUserError, error)
}
type DeleteMatchResponseResolver interface {
	Error(ctx context.Context, obj *api.DeleteMatchResponse) (model.DeleteMatchError, error)
}
type DeleteMatchmakingTicketResponseResolver interface {
	Error(ctx context.Context, obj *api.DeleteMatchmakingTicketResponse) (model.DeleteMatchmakingTicketError, error)
}
type DeleteMatchmakingUserResponseResolver interface {
	Error(ctx context.Context, obj *api.DeleteMatchmakingUserResponse) (model.DeleteMatchmakingUserError, error)
}
type DeleteRecordResponseResolver interface {
	Error(ctx context.Context, obj *api.DeleteRecordResponse) (model.DeleteRecordError, error)
}
type EndMatchResponseResolver interface {
	Error(ctx context.Context, obj *api.EndMatchResponse) (model.EndMatchError, error)
}
type EventResponseResolver interface {
	Error(ctx context.Context, obj *api.EventResponse) (model.EventError, error)
}
type EventUserResponseResolver interface {
	Error(ctx context.Context, obj *api.EventUserResponse) (model.EventUserError, error)
}
type GetArenaResponseResolver interface {
	Error(ctx context.Context, obj *api.GetArenaResponse) (model.GetArenaError, error)
}
type GetEventResponseResolver interface {
	Error(ctx context.Context, obj *api.GetEventResponse) (model.GetEventError, error)
}
type GetEventRoundResponseResolver interface {
	Error(ctx context.Context, obj *api.GetEventRoundResponse) (model.GetEventRoundError, error)
}
type GetEventUserResponseResolver interface {
	Error(ctx context.Context, obj *api.GetEventUserResponse) (model.GetEventUserError, error)
}
type GetItemResponseResolver interface {
	Error(ctx context.Context, obj *api.GetItemResponse) (model.GetItemError, error)
}
type GetMatchResponseResolver interface {
	Error(ctx context.Context, obj *api.GetMatchResponse) (model.GetMatchError, error)
}
type GetMatchmakingTicketResponseResolver interface {
	Error(ctx context.Context, obj *api.GetMatchmakingTicketResponse) (model.GetMatchmakingTicketError, error)
}
type GetMatchmakingTicketsResponseResolver interface {
	Error(ctx context.Context, obj *api.GetMatchmakingTicketsResponse) (model.GetMatchmakingTicketsError, error)
}
type GetMatchmakingUserResponseResolver interface {
	Error(ctx context.Context, obj *api.GetMatchmakingUserResponse) (model.GetMatchmakingUserError, error)
}
type GetRecordResponseResolver interface {
	Error(ctx context.Context, obj *api.GetRecordResponse) (model.GetRecordError, error)
}
type GetRecordsResponseResolver interface {
	Error(ctx context.Context, obj *api.GetRecordsResponse) (model.GetRecordsError, error)
}
type GetTaskResponseResolver interface {
	Error(ctx context.Context, obj *api.GetTaskResponse) (model.GetTaskError, error)
}
type GetTeamMemberResponseResolver interface {
	Error(ctx context.Context, obj *api.GetTeamMemberResponse) (model.GetTeamMemberError, error)
}
type GetTeamResponseResolver interface {
	Error(ctx context.Context, obj *api.GetTeamResponse) (model.GetTeamError, error)
}
type GetTournamentUserResponseResolver interface {
	Error(ctx context.Context, obj *api.GetTournamentUserResponse) (model.GetTournamentUserError, error)
}
type GetTournamentUsersResponseResolver interface {
	Error(ctx context.Context, obj *api.GetTournamentUsersResponse) (model.GetTournamentUsersError, error)
}
type ItemResponseResolver interface {
	Error(ctx context.Context, obj *api.ItemResponse) (model.ItemError, error)
}
type JoinTeamResponseResolver interface {
	Error(ctx context.Context, obj *api.JoinTeamResponse) (model.JoinTeamError, error)
}
type LeaveTeamResponseResolver interface {
	Error(ctx context.Context, obj *api.LeaveTeamResponse) (model.LeaveTeamError, error)
}
type MatchResolver interface {
	Status(ctx context.Context, obj *api.Match) (model.MatchStatus, error)
}
type MatchmakingTicketResolver interface {
	Status(ctx context.Context, obj *api.MatchmakingTicket) (model.MatchmakingTicketStatus, error)
}
type MutationResolver interface {
	CreateEvent(ctx context.Context, input *api.CreateEventRequest) (*api.CreateEventResponse, error)
	UpdateEvent(ctx context.Context, input *api.UpdateEventRequest) (*api.UpdateEventResponse, error)
	DeleteEvent(ctx context.Context, input *api.EventRequest) (*api.EventResponse, error)
	CreateEventRound(ctx context.Context, input *api.CreateEventRoundRequest) (*api.CreateEventRoundResponse, error)
	UpdateEventRound(ctx context.Context, input *api.UpdateEventRoundRequest) (*api.UpdateEventRoundResponse, error)
	UpdateEventUser(ctx context.Context, input *api.UpdateEventUserRequest) (*api.UpdateEventUserResponse, error)
	DeleteEventUser(ctx context.Context, input *api.EventUserRequest) (*api.EventUserResponse, error)
	AddEventResult(ctx context.Context, input *api.AddEventResultRequest) (*api.AddEventResultResponse, error)
	RemoveEventResult(ctx context.Context, input *api.EventRoundUserRequest) (*api.RemoveEventResultResponse, error)
	CreateItem(ctx context.Context, input *api.CreateItemRequest) (*api.CreateItemResponse, error)
	UpdateItem(ctx context.Context, input *api.UpdateItemRequest) (*api.UpdateItemResponse, error)
	DeleteItem(ctx context.Context, input *api.ItemRequest) (*api.ItemResponse, error)
	CreateArena(ctx context.Context, input *api.CreateArenaRequest) (*api.CreateArenaResponse, error)
	UpdateArena(ctx context.Context, input *api.UpdateArenaRequest) (*api.UpdateArenaResponse, error)
	CreateMatchmakingUser(ctx context.Context, input *api.CreateMatchmakingUserRequest) (*api.CreateMatchmakingUserResponse, error)
	UpdateMatchmakingUser(ctx context.Context, input *api.UpdateMatchmakingUserRequest) (*api.UpdateMatchmakingUserResponse, error)
	DeleteMatchmakingUser(ctx context.Context, input *api.MatchmakingUserRequest) (*api.DeleteMatchmakingUserResponse, error)
	CreateMatchmakingTicket(ctx context.Context, input *api.CreateMatchmakingTicketRequest) (*api.CreateMatchmakingTicketResponse, error)
	UpdateMatchmakingTicket(ctx context.Context, input *api.UpdateMatchmakingTicketRequest) (*api.UpdateMatchmakingTicketResponse, error)
	DeleteMatchmakingTicket(ctx context.Context, input *api.MatchmakingTicketRequest) (*api.DeleteMatchmakingTicketResponse, error)
	StartMatch(ctx context.Context, input *api.StartMatchRequest) (*api.StartMatchResponse, error)
	EndMatch(ctx context.Context, input *api.EndMatchRequest) (*api.EndMatchResponse, error)
	UpdateMatch(ctx context.Context, input *api.UpdateMatchRequest) (*api.UpdateMatchResponse, error)
	SetMatchPrivateServer(ctx context.Context, input *api.SetMatchPrivateServerRequest) (*api.SetMatchPrivateServerResponse, error)
	DeleteMatch(ctx context.Context, input *api.MatchRequest) (*api.DeleteMatchResponse, error)
	CreateRecord(ctx context.Context, input *api.CreateRecordRequest) (*api.CreateRecordResponse, error)
	UpdateRecord(ctx context.Context, input *api.UpdateRecordRequest) (*api.UpdateRecordResponse, error)
	DeleteRecord(ctx context.Context, input *api.RecordRequest) (*api.DeleteRecordResponse, error)
	CreateTask(ctx context.Context, input *api.CreateTaskRequest) (*api.CreateTaskResponse, error)
	UpdateTask(ctx context.Context, input *api.UpdateTaskRequest) (*api.UpdateTaskResponse, error)
	CompleteTask(ctx context.Context, input *api.TaskRequest) (*api.CompleteTaskResponse, error)
	DeleteTask(ctx context.Context, input *api.TaskRequest) (*api.TaskResponse, error)
	CreateTeam(ctx context.Context, input *api.CreateTeamRequest) (*api.CreateTeamResponse, error)
	UpdateTeam(ctx context.Context, input *api.UpdateTeamRequest) (*api.UpdateTeamResponse, error)
	DeleteTeam(ctx context.Context, input *api.TeamRequest) (*api.TeamResponse, error)
	JoinTeam(ctx context.Context, input *api.JoinTeamRequest) (*api.JoinTeamResponse, error)
	LeaveTeam(ctx context.Context, input *api.TeamMemberRequest) (*api.LeaveTeamResponse, error)
	UpdateTeamMember(ctx context.Context, input *api.UpdateTeamMemberRequest) (*api.UpdateTeamMemberResponse, error)
	CreateTournamentUser(ctx context.Context, input *api.CreateTournamentUserRequest) (*api.CreateTournamentUserResponse, error)
	UpdateTournamentUser(ctx context.Context, input *api.UpdateTournamentUserRequest) (*api.UpdateTournamentUserResponse, error)
	DeleteTournamentUser(ctx context.Context, input *api.TournamentUserRequest) (*api.TournamentUserResponse, error)
	Webhook(ctx context.Context, input *api.WebhookRequest) (*api.WebhookResponse, error)
}
type QueryResolver interface {
	GetEvent(ctx context.Context, input *api.GetEventRequest) (*api.GetEventResponse, error)
	GetEventRound(ctx context.Context, input *api.GetEventRoundRequest) (*api.GetEventRoundResponse, error)
	GetEventUser(ctx context.Context, input *api.GetEventUserRequest) (*api.GetEventUserResponse, error)
	GetItem(ctx context.Context, input *api.ItemRequest) (*api.GetItemResponse, error)
	GetItems(ctx context.Context, input *api.GetItemsRequest) (*api.GetItemsResponse, error)
	GetArena(ctx context.Context, input *api.ArenaRequest) (*api.GetArenaResponse, error)
	GetArenas(ctx context.Context, input *api.Pagination) (*api.GetArenasResponse, error)
	GetMatchmakingUser(ctx context.Context, input *api.MatchmakingUserRequest) (*api.GetMatchmakingUserResponse, error)
	GetMatchmakingUsers(ctx context.Context, input *api.Pagination) (*api.GetMatchmakingUsersResponse, error)
	GetMatchmakingTicket(ctx context.Context, input *api.GetMatchmakingTicketRequest) (*api.GetMatchmakingTicketResponse, error)
	GetMatchmakingTickets(ctx context.Context, input *api.GetMatchmakingTicketsRequest) (*api.GetMatchmakingTicketsResponse, error)
	GetMatch(ctx context.Context, input *api.GetMatchRequest) (*api.GetMatchResponse, error)
	GetMatches(ctx context.Context, input *api.GetMatchesRequest) (*api.GetMatchesResponse, error)
	GetRecord(ctx context.Context, input *api.RecordRequest) (*api.GetRecordResponse, error)
	GetRecords(ctx context.Context, input *api.GetRecordsRequest) (*api.GetRecordsResponse, error)
	GetTask(ctx context.Context, input *api.TaskRequest) (*api.GetTaskResponse, error)
	GetTasks(ctx context.Context, input *api.GetTasksRequest) (*api.GetTasksResponse, error)
	GetTeam(ctx context.Context, input *api.GetTeamRequest) (*api.GetTeamResponse, error)
	GetTeams(ctx context.Context, input *api.GetTeamsRequest) (*api.GetTeamsResponse, error)
	GetTeamMember(ctx context.Context, input *api.TeamMemberRequest) (*api.GetTeamMemberResponse, error)
	SearchTeams(ctx context.Context, input *api.SearchTeamsRequest) (*api.SearchTeamsResponse, error)
	GetTournamentUser(ctx context.Context, input *api.TournamentUserRequest) (*api.GetTournamentUserResponse, error)
	GetTournamentUsers(ctx context.Context, input *api.GetTournamentUsersRequest) (*api.GetTournamentUsersResponse, error)
}
type RemoveEventResultResponseResolver interface {
	Error(ctx context.Context, obj *api.RemoveEventResultResponse) (model.RemoveEventResultError, error)
}
type SearchTeamsResponseResolver interface {
	Error(ctx context.Context, obj *api.SearchTeamsResponse) (model.SearchTeamsError, error)
}
type SetMatchPrivateServerResponseResolver interface {
	Error(ctx context.Context, obj *api.SetMatchPrivateServerResponse) (model.SetMatchPrivateServerError, error)
}
type StartMatchResponseResolver interface {
	Error(ctx context.Context, obj *api.StartMatchResponse) (model.StartMatchError, error)
}
type TaskResponseResolver interface {
	Error(ctx context.Context, obj *api.TaskResponse) (model.TaskError, error)
}
type TeamResponseResolver interface {
	Error(ctx context.Context, obj *api.TeamResponse) (model.TeamError, error)
}
type TournamentUserResolver interface {
	Interval(ctx context.Context, obj *api.TournamentUser) (graphqlEnums.TournamentInterval, error)
}
type TournamentUserResponseResolver interface {
	Error(ctx context.Context, obj *api.TournamentUserResponse) (model.TournamentUserError, error)
}
type UpdateArenaResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateArenaResponse) (model.UpdateArenaError, error)
}
type UpdateEventResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateEventResponse) (model.UpdateEventError, error)
}
type UpdateEventRoundResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateEventRoundResponse) (model.UpdateEventRoundError, error)
}
type UpdateEventUserResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateEventUserResponse) (model.UpdateEventUserError, error)
}
type UpdateItemResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateItemResponse) (model.UpdateItemError, error)
}
type UpdateMatchResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateMatchResponse) (model.UpdateMatchError, error)
}
type UpdateMatchmakingTicketResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateMatchmakingTicketResponse) (model.UpdateMatchmakingTicketError, error)
}
type UpdateMatchmakingUserResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateMatchmakingUserResponse) (model.UpdateMatchmakingUserError, error)
}
type UpdateRecordResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateRecordResponse) (model.UpdateRecordError, error)
}
type UpdateTaskResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateTaskResponse) (model.UpdateTaskError, error)
}
type UpdateTeamMemberResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateTeamMemberResponse) (model.UpdateTeamMemberError, error)
}
type UpdateTeamResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateTeamResponse) (model.UpdateTeamError, error)
}
type UpdateTournamentUserResponseResolver interface {
	Error(ctx context.Context, obj *api.UpdateTournamentUserResponse) (model.UpdateTournamentUserError, error)
}

type CreateTournamentUserRequestResolver interface {
	Interval(ctx context.Context, obj *api.CreateTournamentUserRequest, data graphqlEnums.TournamentInterval) error
}
type GetMatchesRequestResolver interface {
	Statuses(ctx context.Context, obj *api.GetMatchesRequest, data []*model.MatchStatus) error
}
type GetMatchmakingTicketsRequestResolver interface {
	Statuses(ctx context.Context, obj *api.GetMatchmakingTicketsRequest, data []*model.MatchmakingTicketStatus) error
}
type GetTournamentUsersRequestResolver interface {
	Interval(ctx context.Context, obj *api.GetTournamentUsersRequest, data graphqlEnums.TournamentInterval) error
}
type TournamentIntervalUserIdResolver interface {
	Interval(ctx context.Context, obj *api.TournamentIntervalUserId, data graphqlEnums.TournamentInterval) error
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AddEventResultResponse.error":
		if e.complexity.AddEventResultResponse.Error == nil {
			break
		}

		return e.complexity.AddEventResultResponse.Error(childComplexity), true

	case "AddEventResultResponse.success":
		if e.complexity.AddEventResultResponse.Success == nil {
			break
		}

		return e.complexity.AddEventResultResponse.Success(childComplexity), true

	case "Arena.createdAt":
		if e.complexity.Arena.CreatedAt == nil {
			break
		}

		return e.complexity.Arena.CreatedAt(childComplexity), true

	case "Arena.data":
		if e.complexity.Arena.Data == nil {
			break
		}

		return e.complexity.Arena.Data(childComplexity), true

	case "Arena.id":
		if e.complexity.Arena.Id == nil {
			break
		}

		return e.complexity.Arena.Id(childComplexity), true

	case "Arena.maxPlayers":
		if e.complexity.Arena.MaxPlayers == nil {
			break
		}

		return e.complexity.Arena.MaxPlayers(childComplexity), true

	case "Arena.maxPlayersPerTicket":
		if e.complexity.Arena.MaxPlayersPerTicket == nil {
			break
		}

		return e.complexity.Arena.MaxPlayersPerTicket(childComplexity), true

	case "Arena.minPlayers":
		if e.complexity.Arena.MinPlayers == nil {
			break
		}

		return e.complexity.Arena.MinPlayers(childComplexity), true

	case "Arena.name":
		if e.complexity.Arena.Name == nil {
			break
		}

		return e.complexity.Arena.Name(childComplexity), true

	case "Arena.updatedAt":
		if e.complexity.Arena.UpdatedAt == nil {
			break
		}

		return e.complexity.Arena.UpdatedAt(childComplexity), true

	case "CompleteTaskResponse.error":
		if e.complexity.CompleteTaskResponse.Error == nil {
			break
		}

		return e.complexity.CompleteTaskResponse.Error(childComplexity), true

	case "CompleteTaskResponse.success":
		if e.complexity.CompleteTaskResponse.Success == nil {
			break
		}

		return e.complexity.CompleteTaskResponse.Success(childComplexity), true

	case "CreateArenaResponse.error":
		if e.complexity.CreateArenaResponse.Error == nil {
			break
		}

		return e.complexity.CreateArenaResponse.Error(childComplexity), true

	case "CreateArenaResponse.id":
		if e.complexity.CreateArenaResponse.Id == nil {
			break
		}

		return e.complexity.CreateArenaResponse.Id(childComplexity), true

	case "CreateArenaResponse.success":
		if e.complexity.CreateArenaResponse.Success == nil {
			break
		}

		return e.complexity.CreateArenaResponse.Success(childComplexity), true

	case "CreateEventResponse.error":
		if e.complexity.CreateEventResponse.Error == nil {
			break
		}

		return e.complexity.CreateEventResponse.Error(childComplexity), true

	case "CreateEventResponse.id":
		if e.complexity.CreateEventResponse.Id == nil {
			break
		}

		return e.complexity.CreateEventResponse.Id(childComplexity), true

	case "CreateEventResponse.success":
		if e.complexity.CreateEventResponse.Success == nil {
			break
		}

		return e.complexity.CreateEventResponse.Success(childComplexity), true

	case "CreateEventRoundResponse.error":
		if e.complexity.CreateEventRoundResponse.Error == nil {
			break
		}

		return e.complexity.CreateEventRoundResponse.Error(childComplexity), true

	case "CreateEventRoundResponse.id":
		if e.complexity.CreateEventRoundResponse.Id == nil {
			break
		}

		return e.complexity.CreateEventRoundResponse.Id(childComplexity), true

	case "CreateEventRoundResponse.success":
		if e.complexity.CreateEventRoundResponse.Success == nil {
			break
		}

		return e.complexity.CreateEventRoundResponse.Success(childComplexity), true

	case "CreateItemResponse.error":
		if e.complexity.CreateItemResponse.Error == nil {
			break
		}

		return e.complexity.CreateItemResponse.Error(childComplexity), true

	case "CreateItemResponse.success":
		if e.complexity.CreateItemResponse.Success == nil {
			break
		}

		return e.complexity.CreateItemResponse.Success(childComplexity), true

	case "CreateMatchmakingTicketResponse.error":
		if e.complexity.CreateMatchmakingTicketResponse.Error == nil {
			break
		}

		return e.complexity.CreateMatchmakingTicketResponse.Error(childComplexity), true

	case "CreateMatchmakingTicketResponse.id":
		if e.complexity.CreateMatchmakingTicketResponse.Id == nil {
			break
		}

		return e.complexity.CreateMatchmakingTicketResponse.Id(childComplexity), true

	case "CreateMatchmakingTicketResponse.success":
		if e.complexity.CreateMatchmakingTicketResponse.Success == nil {
			break
		}

		return e.complexity.CreateMatchmakingTicketResponse.Success(childComplexity), true

	case "CreateMatchmakingUserResponse.error":
		if e.complexity.CreateMatchmakingUserResponse.Error == nil {
			break
		}

		return e.complexity.CreateMatchmakingUserResponse.Error(childComplexity), true

	case "CreateMatchmakingUserResponse.id":
		if e.complexity.CreateMatchmakingUserResponse.Id == nil {
			break
		}

		return e.complexity.CreateMatchmakingUserResponse.Id(childComplexity), true

	case "CreateMatchmakingUserResponse.success":
		if e.complexity.CreateMatchmakingUserResponse.Success == nil {
			break
		}

		return e.complexity.CreateMatchmakingUserResponse.Success(childComplexity), true

	case "CreateRecordResponse.error":
		if e.complexity.CreateRecordResponse.Error == nil {
			break
		}

		return e.complexity.CreateRecordResponse.Error(childComplexity), true

	case "CreateRecordResponse.id":
		if e.complexity.CreateRecordResponse.Id == nil {
			break
		}

		return e.complexity.CreateRecordResponse.Id(childComplexity), true

	case "CreateRecordResponse.success":
		if e.complexity.CreateRecordResponse.Success == nil {
			break
		}

		return e.complexity.CreateRecordResponse.Success(childComplexity), true

	case "CreateTaskResponse.error":
		if e.complexity.CreateTaskResponse.Error == nil {
			break
		}

		return e.complexity.CreateTaskResponse.Error(childComplexity), true

	case "CreateTaskResponse.success":
		if e.complexity.CreateTaskResponse.Success == nil {
			break
		}

		return e.complexity.CreateTaskResponse.Success(childComplexity), true

	case "CreateTeamResponse.error":
		if e.complexity.CreateTeamResponse.Error == nil {
			break
		}

		return e.complexity.CreateTeamResponse.Error(childComplexity), true

	case "CreateTeamResponse.id":
		if e.complexity.CreateTeamResponse.Id == nil {
			break
		}

		return e.complexity.CreateTeamResponse.Id(childComplexity), true

	case "CreateTeamResponse.success":
		if e.complexity.CreateTeamResponse.Success == nil {
			break
		}

		return e.complexity.CreateTeamResponse.Success(childComplexity), true

	case "CreateTournamentUserResponse.error":
		if e.complexity.CreateTournamentUserResponse.Error == nil {
			break
		}

		return e.complexity.CreateTournamentUserResponse.Error(childComplexity), true

	case "CreateTournamentUserResponse.id":
		if e.complexity.CreateTournamentUserResponse.Id == nil {
			break
		}

		return e.complexity.CreateTournamentUserResponse.Id(childComplexity), true

	case "CreateTournamentUserResponse.success":
		if e.complexity.CreateTournamentUserResponse.Success == nil {
			break
		}

		return e.complexity.CreateTournamentUserResponse.Success(childComplexity), true

	case "DeleteMatchResponse.error":
		if e.complexity.DeleteMatchResponse.Error == nil {
			break
		}

		return e.complexity.DeleteMatchResponse.Error(childComplexity), true

	case "DeleteMatchResponse.success":
		if e.complexity.DeleteMatchResponse.Success == nil {
			break
		}

		return e.complexity.DeleteMatchResponse.Success(childComplexity), true

	case "DeleteMatchmakingTicketResponse.error":
		if e.complexity.DeleteMatchmakingTicketResponse.Error == nil {
			break
		}

		return e.complexity.DeleteMatchmakingTicketResponse.Error(childComplexity), true

	case "DeleteMatchmakingTicketResponse.success":
		if e.complexity.DeleteMatchmakingTicketResponse.Success == nil {
			break
		}

		return e.complexity.DeleteMatchmakingTicketResponse.Success(childComplexity), true

	case "DeleteMatchmakingUserResponse.error":
		if e.complexity.DeleteMatchmakingUserResponse.Error == nil {
			break
		}

		return e.complexity.DeleteMatchmakingUserResponse.Error(childComplexity), true

	case "DeleteMatchmakingUserResponse.success":
		if e.complexity.DeleteMatchmakingUserResponse.Success == nil {
			break
		}

		return e.complexity.DeleteMatchmakingUserResponse.Success(childComplexity), true

	case "DeleteRecordResponse.error":
		if e.complexity.DeleteRecordResponse.Error == nil {
			break
		}

		return e.complexity.DeleteRecordResponse.Error(childComplexity), true

	case "DeleteRecordResponse.success":
		if e.complexity.DeleteRecordResponse.Success == nil {
			break
		}

		return e.complexity.DeleteRecordResponse.Success(childComplexity), true

	case "EndMatchResponse.error":
		if e.complexity.EndMatchResponse.Error == nil {
			break
		}

		return e.complexity.EndMatchResponse.Error(childComplexity), true

	case "EndMatchResponse.success":
		if e.complexity.EndMatchResponse.Success == nil {
			break
		}

		return e.complexity.EndMatchResponse.Success(childComplexity), true

	case "Event.createdAt":
		if e.complexity.Event.CreatedAt == nil {
			break
		}

		return e.complexity.Event.CreatedAt(childComplexity), true

	case "Event.currentRoundId":
		if e.complexity.Event.CurrentRoundId == nil {
			break
		}

		return e.complexity.Event.CurrentRoundId(childComplexity), true

	case "Event.currentRoundName":
		if e.complexity.Event.CurrentRoundName == nil {
			break
		}

		return e.complexity.Event.CurrentRoundName(childComplexity), true

	case "Event.data":
		if e.complexity.Event.Data == nil {
			break
		}

		return e.complexity.Event.Data(childComplexity), true

	case "Event.id":
		if e.complexity.Event.Id == nil {
			break
		}

		return e.complexity.Event.Id(childComplexity), true

	case "Event.name":
		if e.complexity.Event.Name == nil {
			break
		}

		return e.complexity.Event.Name(childComplexity), true

	case "Event.rounds":
		if e.complexity.Event.Rounds == nil {
			break
		}

		return e.complexity.Event.Rounds(childComplexity), true

	case "Event.startedAt":
		if e.complexity.Event.StartedAt == nil {
			break
		}

		return e.complexity.Event.StartedAt(childComplexity), true

	case "Event.updatedAt":
		if e.complexity.Event.UpdatedAt == nil {
			break
		}

		return e.complexity.Event.UpdatedAt(childComplexity), true

	case "EventResponse.error":
		if e.complexity.EventResponse.Error == nil {
			break
		}

		return e.complexity.EventResponse.Error(childComplexity), true

	case "EventResponse.success":
		if e.complexity.EventResponse.Success == nil {
			break
		}

		return e.complexity.EventResponse.Success(childComplexity), true

	case "EventRound.createdAt":
		if e.complexity.EventRound.CreatedAt == nil {
			break
		}

		return e.complexity.EventRound.CreatedAt(childComplexity), true

	case "EventRound.data":
		if e.complexity.EventRound.Data == nil {
			break
		}

		return e.complexity.EventRound.Data(childComplexity), true

	case "EventRound.endedAt":
		if e.complexity.EventRound.EndedAt == nil {
			break
		}

		return e.complexity.EventRound.EndedAt(childComplexity), true

	case "EventRound.eventId":
		if e.complexity.EventRound.EventId == nil {
			break
		}

		return e.complexity.EventRound.EventId(childComplexity), true

	case "EventRound.id":
		if e.complexity.EventRound.Id == nil {
			break
		}

		return e.complexity.EventRound.Id(childComplexity), true

	case "EventRound.name":
		if e.complexity.EventRound.Name == nil {
			break
		}

		return e.complexity.EventRound.Name(childComplexity), true

	case "EventRound.scoring":
		if e.complexity.EventRound.Scoring == nil {
			break
		}

		return e.complexity.EventRound.Scoring(childComplexity), true

	case "EventRound.updatedAt":
		if e.complexity.EventRound.UpdatedAt == nil {
			break
		}

		return e.complexity.EventRound.UpdatedAt(childComplexity), true

	case "EventRoundUser.clientUserId":
		if e.complexity.EventRoundUser.ClientUserId == nil {
			break
		}

		return e.complexity.EventRoundUser.ClientUserId(childComplexity), true

	case "EventRoundUser.createdAt":
		if e.complexity.EventRoundUser.CreatedAt == nil {
			break
		}

		return e.complexity.EventRoundUser.CreatedAt(childComplexity), true

	case "EventRoundUser.data":
		if e.complexity.EventRoundUser.Data == nil {
			break
		}

		return e.complexity.EventRoundUser.Data(childComplexity), true

	case "EventRoundUser.eventRoundId":
		if e.complexity.EventRoundUser.EventRoundId == nil {
			break
		}

		return e.complexity.EventRoundUser.EventRoundId(childComplexity), true

	case "EventRoundUser.eventUserId":
		if e.complexity.EventRoundUser.EventUserId == nil {
			break
		}

		return e.complexity.EventRoundUser.EventUserId(childComplexity), true

	case "EventRoundUser.id":
		if e.complexity.EventRoundUser.Id == nil {
			break
		}

		return e.complexity.EventRoundUser.Id(childComplexity), true

	case "EventRoundUser.ranking":
		if e.complexity.EventRoundUser.Ranking == nil {
			break
		}

		return e.complexity.EventRoundUser.Ranking(childComplexity), true

	case "EventRoundUser.result":
		if e.complexity.EventRoundUser.Result == nil {
			break
		}

		return e.complexity.EventRoundUser.Result(childComplexity), true

	case "EventRoundUser.updatedAt":
		if e.complexity.EventRoundUser.UpdatedAt == nil {
			break
		}

		return e.complexity.EventRoundUser.UpdatedAt(childComplexity), true

	case "EventUser.clientUserId":
		if e.complexity.EventUser.ClientUserId == nil {
			break
		}

		return e.complexity.EventUser.ClientUserId(childComplexity), true

	case "EventUser.createdAt":
		if e.complexity.EventUser.CreatedAt == nil {
			break
		}

		return e.complexity.EventUser.CreatedAt(childComplexity), true

	case "EventUser.data":
		if e.complexity.EventUser.Data == nil {
			break
		}

		return e.complexity.EventUser.Data(childComplexity), true

	case "EventUser.eventId":
		if e.complexity.EventUser.EventId == nil {
			break
		}

		return e.complexity.EventUser.EventId(childComplexity), true

	case "EventUser.id":
		if e.complexity.EventUser.Id == nil {
			break
		}

		return e.complexity.EventUser.Id(childComplexity), true

	case "EventUser.ranking":
		if e.complexity.EventUser.Ranking == nil {
			break
		}

		return e.complexity.EventUser.Ranking(childComplexity), true

	case "EventUser.score":
		if e.complexity.EventUser.Score == nil {
			break
		}

		return e.complexity.EventUser.Score(childComplexity), true

	case "EventUser.updatedAt":
		if e.complexity.EventUser.UpdatedAt == nil {
			break
		}

		return e.complexity.EventUser.UpdatedAt(childComplexity), true

	case "EventUserResponse.error":
		if e.complexity.EventUserResponse.Error == nil {
			break
		}

		return e.complexity.EventUserResponse.Error(childComplexity), true

	case "EventUserResponse.success":
		if e.complexity.EventUserResponse.Success == nil {
			break
		}

		return e.complexity.EventUserResponse.Success(childComplexity), true

	case "GetArenaResponse.arena":
		if e.complexity.GetArenaResponse.Arena == nil {
			break
		}

		return e.complexity.GetArenaResponse.Arena(childComplexity), true

	case "GetArenaResponse.error":
		if e.complexity.GetArenaResponse.Error == nil {
			break
		}

		return e.complexity.GetArenaResponse.Error(childComplexity), true

	case "GetArenaResponse.success":
		if e.complexity.GetArenaResponse.Success == nil {
			break
		}

		return e.complexity.GetArenaResponse.Success(childComplexity), true

	case "GetArenasResponse.arenas":
		if e.complexity.GetArenasResponse.Arenas == nil {
			break
		}

		return e.complexity.GetArenasResponse.Arenas(childComplexity), true

	case "GetArenasResponse.success":
		if e.complexity.GetArenasResponse.Success == nil {
			break
		}

		return e.complexity.GetArenasResponse.Success(childComplexity), true

	case "GetEventResponse.error":
		if e.complexity.GetEventResponse.Error == nil {
			break
		}

		return e.complexity.GetEventResponse.Error(childComplexity), true

	case "GetEventResponse.event":
		if e.complexity.GetEventResponse.Event == nil {
			break
		}

		return e.complexity.GetEventResponse.Event(childComplexity), true

	case "GetEventResponse.leaderboard":
		if e.complexity.GetEventResponse.Leaderboard == nil {
			break
		}

		return e.complexity.GetEventResponse.Leaderboard(childComplexity), true

	case "GetEventResponse.success":
		if e.complexity.GetEventResponse.Success == nil {
			break
		}

		return e.complexity.GetEventResponse.Success(childComplexity), true

	case "GetEventRoundResponse.error":
		if e.complexity.GetEventRoundResponse.Error == nil {
			break
		}

		return e.complexity.GetEventRoundResponse.Error(childComplexity), true

	case "GetEventRoundResponse.results":
		if e.complexity.GetEventRoundResponse.Results == nil {
			break
		}

		return e.complexity.GetEventRoundResponse.Results(childComplexity), true

	case "GetEventRoundResponse.round":
		if e.complexity.GetEventRoundResponse.Round == nil {
			break
		}

		return e.complexity.GetEventRoundResponse.Round(childComplexity), true

	case "GetEventRoundResponse.success":
		if e.complexity.GetEventRoundResponse.Success == nil {
			break
		}

		return e.complexity.GetEventRoundResponse.Success(childComplexity), true

	case "GetEventUserResponse.error":
		if e.complexity.GetEventUserResponse.Error == nil {
			break
		}

		return e.complexity.GetEventUserResponse.Error(childComplexity), true

	case "GetEventUserResponse.results":
		if e.complexity.GetEventUserResponse.Results == nil {
			break
		}

		return e.complexity.GetEventUserResponse.Results(childComplexity), true

	case "GetEventUserResponse.success":
		if e.complexity.GetEventUserResponse.Success == nil {
			break
		}

		return e.complexity.GetEventUserResponse.Success(childComplexity), true

	case "GetEventUserResponse.user":
		if e.complexity.GetEventUserResponse.User == nil {
			break
		}

		return e.complexity.GetEventUserResponse.User(childComplexity), true

	case "GetItemResponse.error":
		if e.complexity.GetItemResponse.Error == nil {
			break
		}

		return e.complexity.GetItemResponse.Error(childComplexity), true

	case "GetItemResponse.item":
		if e.complexity.GetItemResponse.Item == nil {
			break
		}

		return e.complexity.GetItemResponse.Item(childComplexity), true

	case "GetItemResponse.success":
		if e.complexity.GetItemResponse.Success == nil {
			break
		}

		return e.complexity.GetItemResponse.Success(childComplexity), true

	case "GetItemsResponse.items":
		if e.complexity.GetItemsResponse.Items == nil {
			break
		}

		return e.complexity.GetItemsResponse.Items(childComplexity), true

	case "GetItemsResponse.success":
		if e.complexity.GetItemsResponse.Success == nil {
			break
		}

		return e.complexity.GetItemsResponse.Success(childComplexity), true

	case "GetMatchResponse.error":
		if e.complexity.GetMatchResponse.Error == nil {
			break
		}

		return e.complexity.GetMatchResponse.Error(childComplexity), true

	case "GetMatchResponse.match":
		if e.complexity.GetMatchResponse.Match == nil {
			break
		}

		return e.complexity.GetMatchResponse.Match(childComplexity), true

	case "GetMatchResponse.success":
		if e.complexity.GetMatchResponse.Success == nil {
			break
		}

		return e.complexity.GetMatchResponse.Success(childComplexity), true

	case "GetMatchesResponse.matches":
		if e.complexity.GetMatchesResponse.Matches == nil {
			break
		}

		return e.complexity.GetMatchesResponse.Matches(childComplexity), true

	case "GetMatchesResponse.success":
		if e.complexity.GetMatchesResponse.Success == nil {
			break
		}

		return e.complexity.GetMatchesResponse.Success(childComplexity), true

	case "GetMatchmakingTicketResponse.error":
		if e.complexity.GetMatchmakingTicketResponse.Error == nil {
			break
		}

		return e.complexity.GetMatchmakingTicketResponse.Error(childComplexity), true

	case "GetMatchmakingTicketResponse.matchmakingTicket":
		if e.complexity.GetMatchmakingTicketResponse.MatchmakingTicket == nil {
			break
		}

		return e.complexity.GetMatchmakingTicketResponse.MatchmakingTicket(childComplexity), true

	case "GetMatchmakingTicketResponse.success":
		if e.complexity.GetMatchmakingTicketResponse.Success == nil {
			break
		}

		return e.complexity.GetMatchmakingTicketResponse.Success(childComplexity), true

	case "GetMatchmakingTicketsResponse.error":
		if e.complexity.GetMatchmakingTicketsResponse.Error == nil {
			break
		}

		return e.complexity.GetMatchmakingTicketsResponse.Error(childComplexity), true

	case "GetMatchmakingTicketsResponse.matchmakingTickets":
		if e.complexity.GetMatchmakingTicketsResponse.MatchmakingTickets == nil {
			break
		}

		return e.complexity.GetMatchmakingTicketsResponse.MatchmakingTickets(childComplexity), true

	case "GetMatchmakingTicketsResponse.success":
		if e.complexity.GetMatchmakingTicketsResponse.Success == nil {
			break
		}

		return e.complexity.GetMatchmakingTicketsResponse.Success(childComplexity), true

	case "GetMatchmakingUserResponse.error":
		if e.complexity.GetMatchmakingUserResponse.Error == nil {
			break
		}

		return e.complexity.GetMatchmakingUserResponse.Error(childComplexity), true

	case "GetMatchmakingUserResponse.matchmakingUser":
		if e.complexity.GetMatchmakingUserResponse.MatchmakingUser == nil {
			break
		}

		return e.complexity.GetMatchmakingUserResponse.MatchmakingUser(childComplexity), true

	case "GetMatchmakingUserResponse.success":
		if e.complexity.GetMatchmakingUserResponse.Success == nil {
			break
		}

		return e.complexity.GetMatchmakingUserResponse.Success(childComplexity), true

	case "GetMatchmakingUsersResponse.matchmakingUsers":
		if e.complexity.GetMatchmakingUsersResponse.MatchmakingUsers == nil {
			break
		}

		return e.complexity.GetMatchmakingUsersResponse.MatchmakingUsers(childComplexity), true

	case "GetMatchmakingUsersResponse.success":
		if e.complexity.GetMatchmakingUsersResponse.Success == nil {
			break
		}

		return e.complexity.GetMatchmakingUsersResponse.Success(childComplexity), true

	case "GetRecordResponse.error":
		if e.complexity.GetRecordResponse.Error == nil {
			break
		}

		return e.complexity.GetRecordResponse.Error(childComplexity), true

	case "GetRecordResponse.record":
		if e.complexity.GetRecordResponse.Record == nil {
			break
		}

		return e.complexity.GetRecordResponse.Record(childComplexity), true

	case "GetRecordResponse.success":
		if e.complexity.GetRecordResponse.Success == nil {
			break
		}

		return e.complexity.GetRecordResponse.Success(childComplexity), true

	case "GetRecordsResponse.error":
		if e.complexity.GetRecordsResponse.Error == nil {
			break
		}

		return e.complexity.GetRecordsResponse.Error(childComplexity), true

	case "GetRecordsResponse.records":
		if e.complexity.GetRecordsResponse.Records == nil {
			break
		}

		return e.complexity.GetRecordsResponse.Records(childComplexity), true

	case "GetRecordsResponse.success":
		if e.complexity.GetRecordsResponse.Success == nil {
			break
		}

		return e.complexity.GetRecordsResponse.Success(childComplexity), true

	case "GetTaskResponse.error":
		if e.complexity.GetTaskResponse.Error == nil {
			break
		}

		return e.complexity.GetTaskResponse.Error(childComplexity), true

	case "GetTaskResponse.success":
		if e.complexity.GetTaskResponse.Success == nil {
			break
		}

		return e.complexity.GetTaskResponse.Success(childComplexity), true

	case "GetTaskResponse.task":
		if e.complexity.GetTaskResponse.Task == nil {
			break
		}

		return e.complexity.GetTaskResponse.Task(childComplexity), true

	case "GetTasksResponse.success":
		if e.complexity.GetTasksResponse.Success == nil {
			break
		}

		return e.complexity.GetTasksResponse.Success(childComplexity), true

	case "GetTasksResponse.tasks":
		if e.complexity.GetTasksResponse.Tasks == nil {
			break
		}

		return e.complexity.GetTasksResponse.Tasks(childComplexity), true

	case "GetTeamMemberResponse.error":
		if e.complexity.GetTeamMemberResponse.Error == nil {
			break
		}

		return e.complexity.GetTeamMemberResponse.Error(childComplexity), true

	case "GetTeamMemberResponse.member":
		if e.complexity.GetTeamMemberResponse.Member == nil {
			break
		}

		return e.complexity.GetTeamMemberResponse.Member(childComplexity), true

	case "GetTeamMemberResponse.success":
		if e.complexity.GetTeamMemberResponse.Success == nil {
			break
		}

		return e.complexity.GetTeamMemberResponse.Success(childComplexity), true

	case "GetTeamResponse.error":
		if e.complexity.GetTeamResponse.Error == nil {
			break
		}

		return e.complexity.GetTeamResponse.Error(childComplexity), true

	case "GetTeamResponse.success":
		if e.complexity.GetTeamResponse.Success == nil {
			break
		}

		return e.complexity.GetTeamResponse.Success(childComplexity), true

	case "GetTeamResponse.team":
		if e.complexity.GetTeamResponse.Team == nil {
			break
		}

		return e.complexity.GetTeamResponse.Team(childComplexity), true

	case "GetTeamsResponse.success":
		if e.complexity.GetTeamsResponse.Success == nil {
			break
		}

		return e.complexity.GetTeamsResponse.Success(childComplexity), true

	case "GetTeamsResponse.teams":
		if e.complexity.GetTeamsResponse.Teams == nil {
			break
		}

		return e.complexity.GetTeamsResponse.Teams(childComplexity), true

	case "GetTournamentUserResponse.error":
		if e.complexity.GetTournamentUserResponse.Error == nil {
			break
		}

		return e.complexity.GetTournamentUserResponse.Error(childComplexity), true

	case "GetTournamentUserResponse.success":
		if e.complexity.GetTournamentUserResponse.Success == nil {
			break
		}

		return e.complexity.GetTournamentUserResponse.Success(childComplexity), true

	case "GetTournamentUserResponse.tournamentUser":
		if e.complexity.GetTournamentUserResponse.TournamentUser == nil {
			break
		}

		return e.complexity.GetTournamentUserResponse.TournamentUser(childComplexity), true

	case "GetTournamentUsersResponse.error":
		if e.complexity.GetTournamentUsersResponse.Error == nil {
			break
		}

		return e.complexity.GetTournamentUsersResponse.Error(childComplexity), true

	case "GetTournamentUsersResponse.success":
		if e.complexity.GetTournamentUsersResponse.Success == nil {
			break
		}

		return e.complexity.GetTournamentUsersResponse.Success(childComplexity), true

	case "GetTournamentUsersResponse.tournamentUsers":
		if e.complexity.GetTournamentUsersResponse.TournamentUsers == nil {
			break
		}

		return e.complexity.GetTournamentUsersResponse.TournamentUsers(childComplexity), true

	case "Item.createdAt":
		if e.complexity.Item.CreatedAt == nil {
			break
		}

		return e.complexity.Item.CreatedAt(childComplexity), true

	case "Item.data":
		if e.complexity.Item.Data == nil {
			break
		}

		return e.complexity.Item.Data(childComplexity), true

	case "Item.expiresAt":
		if e.complexity.Item.ExpiresAt == nil {
			break
		}

		return e.complexity.Item.ExpiresAt(childComplexity), true

	case "Item.id":
		if e.complexity.Item.Id == nil {
			break
		}

		return e.complexity.Item.Id(childComplexity), true

	case "Item.type":
		if e.complexity.Item.Type == nil {
			break
		}

		return e.complexity.Item.Type(childComplexity), true

	case "Item.updatedAt":
		if e.complexity.Item.UpdatedAt == nil {
			break
		}

		return e.complexity.Item.UpdatedAt(childComplexity), true

	case "ItemResponse.error":
		if e.complexity.ItemResponse.Error == nil {
			break
		}

		return e.complexity.ItemResponse.Error(childComplexity), true

	case "ItemResponse.success":
		if e.complexity.ItemResponse.Success == nil {
			break
		}

		return e.complexity.ItemResponse.Success(childComplexity), true

	case "JoinTeamResponse.error":
		if e.complexity.JoinTeamResponse.Error == nil {
			break
		}

		return e.complexity.JoinTeamResponse.Error(childComplexity), true

	case "JoinTeamResponse.success":
		if e.complexity.JoinTeamResponse.Success == nil {
			break
		}

		return e.complexity.JoinTeamResponse.Success(childComplexity), true

	case "LeaveTeamResponse.error":
		if e.complexity.LeaveTeamResponse.Error == nil {
			break
		}

		return e.complexity.LeaveTeamResponse.Error(childComplexity), true

	case "LeaveTeamResponse.success":
		if e.complexity.LeaveTeamResponse.Success == nil {
			break
		}

		return e.complexity.LeaveTeamResponse.Success(childComplexity), true

	case "Match.arena":
		if e.complexity.Match.Arena == nil {
			break
		}

		return e.complexity.Match.Arena(childComplexity), true

	case "Match.createdAt":
		if e.complexity.Match.CreatedAt == nil {
			break
		}

		return e.complexity.Match.CreatedAt(childComplexity), true

	case "Match.data":
		if e.complexity.Match.Data == nil {
			break
		}

		return e.complexity.Match.Data(childComplexity), true

	case "Match.endedAt":
		if e.complexity.Match.EndedAt == nil {
			break
		}

		return e.complexity.Match.EndedAt(childComplexity), true

	case "Match.id":
		if e.complexity.Match.Id == nil {
			break
		}

		return e.complexity.Match.Id(childComplexity), true

	case "Match.lockedAt":
		if e.complexity.Match.LockedAt == nil {
			break
		}

		return e.complexity.Match.LockedAt(childComplexity), true

	case "Match.privateServerId":
		if e.complexity.Match.PrivateServerId == nil {
			break
		}

		return e.complexity.Match.PrivateServerId(childComplexity), true

	case "Match.startedAt":
		if e.complexity.Match.StartedAt == nil {
			break
		}

		return e.complexity.Match.StartedAt(childComplexity), true

	case "Match.status":
		if e.complexity.Match.Status == nil {
			break
		}

		return e.complexity.Match.Status(childComplexity), true

	case "Match.tickets":
		if e.complexity.Match.Tickets == nil {
			break
		}

		return e.complexity.Match.Tickets(childComplexity), true

	case "Match.updatedAt":
		if e.complexity.Match.UpdatedAt == nil {
			break
		}

		return e.complexity.Match.UpdatedAt(childComplexity), true

	case "MatchmakingTicket.arenas":
		if e.complexity.MatchmakingTicket.Arenas == nil {
			break
		}

		return e.complexity.MatchmakingTicket.Arenas(childComplexity), true

	case "MatchmakingTicket.createdAt":
		if e.complexity.MatchmakingTicket.CreatedAt == nil {
			break
		}

		return e.complexity.MatchmakingTicket.CreatedAt(childComplexity), true

	case "MatchmakingTicket.data":
		if e.complexity.MatchmakingTicket.Data == nil {
			break
		}

		return e.complexity.MatchmakingTicket.Data(childComplexity), true

	case "MatchmakingTicket.id":
		if e.complexity.MatchmakingTicket.Id == nil {
			break
		}

		return e.complexity.MatchmakingTicket.Id(childComplexity), true

	case "MatchmakingTicket.matchId":
		if e.complexity.MatchmakingTicket.MatchId == nil {
			break
		}

		return e.complexity.MatchmakingTicket.MatchId(childComplexity), true

	case "MatchmakingTicket.matchmakingUsers":
		if e.complexity.MatchmakingTicket.MatchmakingUsers == nil {
			break
		}

		return e.complexity.MatchmakingTicket.MatchmakingUsers(childComplexity), true

	case "MatchmakingTicket.status":
		if e.complexity.MatchmakingTicket.Status == nil {
			break
		}

		return e.complexity.MatchmakingTicket.Status(childComplexity), true

	case "MatchmakingTicket.updatedAt":
		if e.complexity.MatchmakingTicket.UpdatedAt == nil {
			break
		}

		return e.complexity.MatchmakingTicket.UpdatedAt(childComplexity), true

	case "MatchmakingUser.clientUserId":
		if e.complexity.MatchmakingUser.ClientUserId == nil {
			break
		}

		return e.complexity.MatchmakingUser.ClientUserId(childComplexity), true

	case "MatchmakingUser.createdAt":
		if e.complexity.MatchmakingUser.CreatedAt == nil {
			break
		}

		return e.complexity.MatchmakingUser.CreatedAt(childComplexity), true

	case "MatchmakingUser.data":
		if e.complexity.MatchmakingUser.Data == nil {
			break
		}

		return e.complexity.MatchmakingUser.Data(childComplexity), true

	case "MatchmakingUser.elo":
		if e.complexity.MatchmakingUser.Elo == nil {
			break
		}

		return e.complexity.MatchmakingUser.Elo(childComplexity), true

	case "MatchmakingUser.id":
		if e.complexity.MatchmakingUser.Id == nil {
			break
		}

		return e.complexity.MatchmakingUser.Id(childComplexity), true

	case "MatchmakingUser.updatedAt":
		if e.complexity.MatchmakingUser.UpdatedAt == nil {
			break
		}

		return e.complexity.MatchmakingUser.UpdatedAt(childComplexity), true

	case "Mutation.AddEventResult":
		if e.complexity.Mutation.AddEventResult == nil {
			break
		}

		args, err := ec.field_Mutation_AddEventResult_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEventResult(childComplexity, args["input"].(*api.AddEventResultRequest)), true

	case "Mutation.CompleteTask":
		if e.complexity.Mutation.CompleteTask == nil {
			break
		}

		args, err := ec.field_Mutation_CompleteTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CompleteTask(childComplexity, args["input"].(*api.TaskRequest)), true

	case "Mutation.CreateArena":
		if e.complexity.Mutation.CreateArena == nil {
			break
		}

		args, err := ec.field_Mutation_CreateArena_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateArena(childComplexity, args["input"].(*api.CreateArenaRequest)), true

	case "Mutation.CreateEvent":
		if e.complexity.Mutation.CreateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_CreateEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEvent(childComplexity, args["input"].(*api.CreateEventRequest)), true

	case "Mutation.CreateEventRound":
		if e.complexity.Mutation.CreateEventRound == nil {
			break
		}

		args, err := ec.field_Mutation_CreateEventRound_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEventRound(childComplexity, args["input"].(*api.CreateEventRoundRequest)), true

	case "Mutation.CreateItem":
		if e.complexity.Mutation.CreateItem == nil {
			break
		}

		args, err := ec.field_Mutation_CreateItem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateItem(childComplexity, args["input"].(*api.CreateItemRequest)), true

	case "Mutation.CreateMatchmakingTicket":
		if e.complexity.Mutation.CreateMatchmakingTicket == nil {
			break
		}

		args, err := ec.field_Mutation_CreateMatchmakingTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatchmakingTicket(childComplexity, args["input"].(*api.CreateMatchmakingTicketRequest)), true

	case "Mutation.CreateMatchmakingUser":
		if e.complexity.Mutation.CreateMatchmakingUser == nil {
			break
		}

		args, err := ec.field_Mutation_CreateMatchmakingUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatchmakingUser(childComplexity, args["input"].(*api.CreateMatchmakingUserRequest)), true

	case "Mutation.CreateRecord":
		if e.complexity.Mutation.CreateRecord == nil {
			break
		}

		args, err := ec.field_Mutation_CreateRecord_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRecord(childComplexity, args["input"].(*api.CreateRecordRequest)), true

	case "Mutation.CreateTask":
		if e.complexity.Mutation.CreateTask == nil {
			break
		}

		args, err := ec.field_Mutation_CreateTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTask(childComplexity, args["input"].(*api.CreateTaskRequest)), true

	case "Mutation.CreateTeam":
		if e.complexity.Mutation.CreateTeam == nil {
			break
		}

		args, err := ec.field_Mutation_CreateTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTeam(childComplexity, args["input"].(*api.CreateTeamRequest)), true

	case "Mutation.CreateTournamentUser":
		if e.complexity.Mutation.CreateTournamentUser == nil {
			break
		}

		args, err := ec.field_Mutation_CreateTournamentUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTournamentUser(childComplexity, args["input"].(*api.CreateTournamentUserRequest)), true

	case "Mutation.DeleteEvent":
		if e.complexity.Mutation.DeleteEvent == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEvent(childComplexity, args["input"].(*api.EventRequest)), true

	case "Mutation.DeleteEventUser":
		if e.complexity.Mutation.DeleteEventUser == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteEventUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEventUser(childComplexity, args["input"].(*api.EventUserRequest)), true

	case "Mutation.DeleteItem":
		if e.complexity.Mutation.DeleteItem == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteItem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteItem(childComplexity, args["input"].(*api.ItemRequest)), true

	case "Mutation.DeleteMatch":
		if e.complexity.Mutation.DeleteMatch == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteMatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMatch(childComplexity, args["input"].(*api.MatchRequest)), true

	case "Mutation.DeleteMatchmakingTicket":
		if e.complexity.Mutation.DeleteMatchmakingTicket == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteMatchmakingTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMatchmakingTicket(childComplexity, args["input"].(*api.MatchmakingTicketRequest)), true

	case "Mutation.DeleteMatchmakingUser":
		if e.complexity.Mutation.DeleteMatchmakingUser == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteMatchmakingUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMatchmakingUser(childComplexity, args["input"].(*api.MatchmakingUserRequest)), true

	case "Mutation.DeleteRecord":
		if e.complexity.Mutation.DeleteRecord == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteRecord_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRecord(childComplexity, args["input"].(*api.RecordRequest)), true

	case "Mutation.DeleteTask":
		if e.complexity.Mutation.DeleteTask == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTask(childComplexity, args["input"].(*api.TaskRequest)), true

	case "Mutation.DeleteTeam":
		if e.complexity.Mutation.DeleteTeam == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTeam(childComplexity, args["input"].(*api.TeamRequest)), true

	case "Mutation.DeleteTournamentUser":
		if e.complexity.Mutation.DeleteTournamentUser == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteTournamentUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTournamentUser(childComplexity, args["input"].(*api.TournamentUserRequest)), true

	case "Mutation.EndMatch":
		if e.complexity.Mutation.EndMatch == nil {
			break
		}

		args, err := ec.field_Mutation_EndMatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EndMatch(childComplexity, args["input"].(*api.EndMatchRequest)), true

	case "Mutation.JoinTeam":
		if e.complexity.Mutation.JoinTeam == nil {
			break
		}

		args, err := ec.field_Mutation_JoinTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.JoinTeam(childComplexity, args["input"].(*api.JoinTeamRequest)), true

	case "Mutation.LeaveTeam":
		if e.complexity.Mutation.LeaveTeam == nil {
			break
		}

		args, err := ec.field_Mutation_LeaveTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LeaveTeam(childComplexity, args["input"].(*api.TeamMemberRequest)), true

	case "Mutation.RemoveEventResult":
		if e.complexity.Mutation.RemoveEventResult == nil {
			break
		}

		args, err := ec.field_Mutation_RemoveEventResult_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveEventResult(childComplexity, args["input"].(*api.EventRoundUserRequest)), true

	case "Mutation.SetMatchPrivateServer":
		if e.complexity.Mutation.SetMatchPrivateServer == nil {
			break
		}

		args, err := ec.field_Mutation_SetMatchPrivateServer_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetMatchPrivateServer(childComplexity, args["input"].(*api.SetMatchPrivateServerRequest)), true

	case "Mutation.StartMatch":
		if e.complexity.Mutation.StartMatch == nil {
			break
		}

		args, err := ec.field_Mutation_StartMatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StartMatch(childComplexity, args["input"].(*api.StartMatchRequest)), true

	case "Mutation.UpdateArena":
		if e.complexity.Mutation.UpdateArena == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateArena_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateArena(childComplexity, args["input"].(*api.UpdateArenaRequest)), true

	case "Mutation.UpdateEvent":
		if e.complexity.Mutation.UpdateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEvent(childComplexity, args["input"].(*api.UpdateEventRequest)), true

	case "Mutation.UpdateEventRound":
		if e.complexity.Mutation.UpdateEventRound == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateEventRound_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventRound(childComplexity, args["input"].(*api.UpdateEventRoundRequest)), true

	case "Mutation.UpdateEventUser":
		if e.complexity.Mutation.UpdateEventUser == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateEventUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventUser(childComplexity, args["input"].(*api.UpdateEventUserRequest)), true

	case "Mutation.UpdateItem":
		if e.complexity.Mutation.UpdateItem == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateItem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateItem(childComplexity, args["input"].(*api.UpdateItemRequest)), true

	case "Mutation.UpdateMatch":
		if e.complexity.Mutation.UpdateMatch == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateMatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatch(childComplexity, args["input"].(*api.UpdateMatchRequest)), true

	case "Mutation.UpdateMatchmakingTicket":
		if e.complexity.Mutation.UpdateMatchmakingTicket == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateMatchmakingTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatchmakingTicket(childComplexity, args["input"].(*api.UpdateMatchmakingTicketRequest)), true

	case "Mutation.UpdateMatchmakingUser":
		if e.complexity.Mutation.UpdateMatchmakingUser == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateMatchmakingUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatchmakingUser(childComplexity, args["input"].(*api.UpdateMatchmakingUserRequest)), true

	case "Mutation.UpdateRecord":
		if e.complexity.Mutation.UpdateRecord == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateRecord_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRecord(childComplexity, args["input"].(*api.UpdateRecordRequest)), true

	case "Mutation.UpdateTask":
		if e.complexity.Mutation.UpdateTask == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTask(childComplexity, args["input"].(*api.UpdateTaskRequest)), true

	case "Mutation.UpdateTeam":
		if e.complexity.Mutation.UpdateTeam == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTeam(childComplexity, args["input"].(*api.UpdateTeamRequest)), true

	case "Mutation.UpdateTeamMember":
		if e.complexity.Mutation.UpdateTeamMember == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateTeamMember_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTeamMember(childComplexity, args["input"].(*api.UpdateTeamMemberRequest)), true

	case "Mutation.UpdateTournamentUser":
		if e.complexity.Mutation.UpdateTournamentUser == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateTournamentUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTournamentUser(childComplexity, args["input"].(*api.UpdateTournamentUserRequest)), true

	case "Mutation.Webhook":
		if e.complexity.Mutation.Webhook == nil {
			break
		}

		args, err := ec.field_Mutation_Webhook_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Webhook(childComplexity, args["input"].(*api.WebhookRequest)), true

	case "Query.GetArena":
		if e.complexity.Query.GetArena == nil {
			break
		}

		args, err := ec.field_Query_GetArena_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetArena(childComplexity, args["input"].(*api.ArenaRequest)), true

	case "Query.GetArenas":
		if e.complexity.Query.GetArenas == nil {
			break
		}

		args, err := ec.field_Query_GetArenas_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetArenas(childComplexity, args["input"].(*api.Pagination)), true

	case "Query.GetEvent":
		if e.complexity.Query.GetEvent == nil {
			break
		}

		args, err := ec.field_Query_GetEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetEvent(childComplexity, args["input"].(*api.GetEventRequest)), true

	case "Query.GetEventRound":
		if e.complexity.Query.GetEventRound == nil {
			break
		}

		args, err := ec.field_Query_GetEventRound_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetEventRound(childComplexity, args["input"].(*api.GetEventRoundRequest)), true

	case "Query.GetEventUser":
		if e.complexity.Query.GetEventUser == nil {
			break
		}

		args, err := ec.field_Query_GetEventUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetEventUser(childComplexity, args["input"].(*api.GetEventUserRequest)), true

	case "Query.GetItem":
		if e.complexity.Query.GetItem == nil {
			break
		}

		args, err := ec.field_Query_GetItem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetItem(childComplexity, args["input"].(*api.ItemRequest)), true

	case "Query.GetItems":
		if e.complexity.Query.GetItems == nil {
			break
		}

		args, err := ec.field_Query_GetItems_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetItems(childComplexity, args["input"].(*api.GetItemsRequest)), true

	case "Query.GetMatch":
		if e.complexity.Query.GetMatch == nil {
			break
		}

		args, err := ec.field_Query_GetMatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMatch(childComplexity, args["input"].(*api.GetMatchRequest)), true

	case "Query.GetMatches":
		if e.complexity.Query.GetMatches == nil {
			break
		}

		args, err := ec.field_Query_GetMatches_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMatches(childComplexity, args["input"].(*api.GetMatchesRequest)), true

	case "Query.GetMatchmakingTicket":
		if e.complexity.Query.GetMatchmakingTicket == nil {
			break
		}

		args, err := ec.field_Query_GetMatchmakingTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMatchmakingTicket(childComplexity, args["input"].(*api.GetMatchmakingTicketRequest)), true

	case "Query.GetMatchmakingTickets":
		if e.complexity.Query.GetMatchmakingTickets == nil {
			break
		}

		args, err := ec.field_Query_GetMatchmakingTickets_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMatchmakingTickets(childComplexity, args["input"].(*api.GetMatchmakingTicketsRequest)), true

	case "Query.GetMatchmakingUser":
		if e.complexity.Query.GetMatchmakingUser == nil {
			break
		}

		args, err := ec.field_Query_GetMatchmakingUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMatchmakingUser(childComplexity, args["input"].(*api.MatchmakingUserRequest)), true

	case "Query.GetMatchmakingUsers":
		if e.complexity.Query.GetMatchmakingUsers == nil {
			break
		}

		args, err := ec.field_Query_GetMatchmakingUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMatchmakingUsers(childComplexity, args["input"].(*api.Pagination)), true

	case "Query.GetRecord":
		if e.complexity.Query.GetRecord == nil {
			break
		}

		args, err := ec.field_Query_GetRecord_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetRecord(childComplexity, args["input"].(*api.RecordRequest)), true

	case "Query.GetRecords":
		if e.complexity.Query.GetRecords == nil {
			break
		}

		args, err := ec.field_Query_GetRecords_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetRecords(childComplexity, args["input"].(*api.GetRecordsRequest)), true

	case "Query.GetTask":
		if e.complexity.Query.GetTask == nil {
			break
		}

		args, err := ec.field_Query_GetTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTask(childComplexity, args["input"].(*api.TaskRequest)), true

	case "Query.GetTasks":
		if e.complexity.Query.GetTasks == nil {
			break
		}

		args, err := ec.field_Query_GetTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTasks(childComplexity, args["input"].(*api.GetTasksRequest)), true

	case "Query.GetTeam":
		if e.complexity.Query.GetTeam == nil {
			break
		}

		args, err := ec.field_Query_GetTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTeam(childComplexity, args["input"].(*api.GetTeamRequest)), true

	case "Query.GetTeamMember":
		if e.complexity.Query.GetTeamMember == nil {
			break
		}

		args, err := ec.field_Query_GetTeamMember_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTeamMember(childComplexity, args["input"].(*api.TeamMemberRequest)), true

	case "Query.GetTeams":
		if e.complexity.Query.GetTeams == nil {
			break
		}

		args, err := ec.field_Query_GetTeams_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTeams(childComplexity, args["input"].(*api.GetTeamsRequest)), true

	case "Query.GetTournamentUser":
		if e.complexity.Query.GetTournamentUser == nil {
			break
		}

		args, err := ec.field_Query_GetTournamentUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTournamentUser(childComplexity, args["input"].(*api.TournamentUserRequest)), true

	case "Query.GetTournamentUsers":
		if e.complexity.Query.GetTournamentUsers == nil {
			break
		}

		args, err := ec.field_Query_GetTournamentUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTournamentUsers(childComplexity, args["input"].(*api.GetTournamentUsersRequest)), true

	case "Query.SearchTeams":
		if e.complexity.Query.SearchTeams == nil {
			break
		}

		args, err := ec.field_Query_SearchTeams_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchTeams(childComplexity, args["input"].(*api.SearchTeamsRequest)), true

	case "Record.createdAt":
		if e.complexity.Record.CreatedAt == nil {
			break
		}

		return e.complexity.Record.CreatedAt(childComplexity), true

	case "Record.data":
		if e.complexity.Record.Data == nil {
			break
		}

		return e.complexity.Record.Data(childComplexity), true

	case "Record.id":
		if e.complexity.Record.Id == nil {
			break
		}

		return e.complexity.Record.Id(childComplexity), true

	case "Record.name":
		if e.complexity.Record.Name == nil {
			break
		}

		return e.complexity.Record.Name(childComplexity), true

	case "Record.ranking":
		if e.complexity.Record.Ranking == nil {
			break
		}

		return e.complexity.Record.Ranking(childComplexity), true

	case "Record.record":
		if e.complexity.Record.Record == nil {
			break
		}

		return e.complexity.Record.Record(childComplexity), true

	case "Record.updatedAt":
		if e.complexity.Record.UpdatedAt == nil {
			break
		}

		return e.complexity.Record.UpdatedAt(childComplexity), true

	case "Record.userId":
		if e.complexity.Record.UserId == nil {
			break
		}

		return e.complexity.Record.UserId(childComplexity), true

	case "RemoveEventResultResponse.error":
		if e.complexity.RemoveEventResultResponse.Error == nil {
			break
		}

		return e.complexity.RemoveEventResultResponse.Error(childComplexity), true

	case "RemoveEventResultResponse.success":
		if e.complexity.RemoveEventResultResponse.Success == nil {
			break
		}

		return e.complexity.RemoveEventResultResponse.Success(childComplexity), true

	case "SearchTeamsResponse.error":
		if e.complexity.SearchTeamsResponse.Error == nil {
			break
		}

		return e.complexity.SearchTeamsResponse.Error(childComplexity), true

	case "SearchTeamsResponse.success":
		if e.complexity.SearchTeamsResponse.Success == nil {
			break
		}

		return e.complexity.SearchTeamsResponse.Success(childComplexity), true

	case "SearchTeamsResponse.teams":
		if e.complexity.SearchTeamsResponse.Teams == nil {
			break
		}

		return e.complexity.SearchTeamsResponse.Teams(childComplexity), true

	case "SetMatchPrivateServerResponse.error":
		if e.complexity.SetMatchPrivateServerResponse.Error == nil {
			break
		}

		return e.complexity.SetMatchPrivateServerResponse.Error(childComplexity), true

	case "SetMatchPrivateServerResponse.privateServerId":
		if e.complexity.SetMatchPrivateServerResponse.PrivateServerId == nil {
			break
		}

		return e.complexity.SetMatchPrivateServerResponse.PrivateServerId(childComplexity), true

	case "SetMatchPrivateServerResponse.success":
		if e.complexity.SetMatchPrivateServerResponse.Success == nil {
			break
		}

		return e.complexity.SetMatchPrivateServerResponse.Success(childComplexity), true

	case "StartMatchResponse.error":
		if e.complexity.StartMatchResponse.Error == nil {
			break
		}

		return e.complexity.StartMatchResponse.Error(childComplexity), true

	case "StartMatchResponse.success":
		if e.complexity.StartMatchResponse.Success == nil {
			break
		}

		return e.complexity.StartMatchResponse.Success(childComplexity), true

	case "Task.completedAt":
		if e.complexity.Task.CompletedAt == nil {
			break
		}

		return e.complexity.Task.CompletedAt(childComplexity), true

	case "Task.createdAt":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true

	case "Task.data":
		if e.complexity.Task.Data == nil {
			break
		}

		return e.complexity.Task.Data(childComplexity), true

	case "Task.expiresAt":
		if e.complexity.Task.ExpiresAt == nil {
			break
		}

		return e.complexity.Task.ExpiresAt(childComplexity), true

	case "Task.id":
		if e.complexity.Task.Id == nil {
			break
		}

		return e.complexity.Task.Id(childComplexity), true

	case "Task.type":
		if e.complexity.Task.Type == nil {
			break
		}

		return e.complexity.Task.Type(childComplexity), true

	case "Task.updatedAt":
		if e.complexity.Task.UpdatedAt == nil {
			break
		}

		return e.complexity.Task.UpdatedAt(childComplexity), true

	case "TaskResponse.error":
		if e.complexity.TaskResponse.Error == nil {
			break
		}

		return e.complexity.TaskResponse.Error(childComplexity), true

	case "TaskResponse.success":
		if e.complexity.TaskResponse.Success == nil {
			break
		}

		return e.complexity.TaskResponse.Success(childComplexity), true

	case "Team.createdAt":
		if e.complexity.Team.CreatedAt == nil {
			break
		}

		return e.complexity.Team.CreatedAt(childComplexity), true

	case "Team.data":
		if e.complexity.Team.Data == nil {
			break
		}

		return e.complexity.Team.Data(childComplexity), true

	case "Team.id":
		if e.complexity.Team.Id == nil {
			break
		}

		return e.complexity.Team.Id(childComplexity), true

	case "Team.members":
		if e.complexity.Team.Members == nil {
			break
		}

		return e.complexity.Team.Members(childComplexity), true

	case "Team.name":
		if e.complexity.Team.Name == nil {
			break
		}

		return e.complexity.Team.Name(childComplexity), true

	case "Team.ranking":
		if e.complexity.Team.Ranking == nil {
			break
		}

		return e.complexity.Team.Ranking(childComplexity), true

	case "Team.score":
		if e.complexity.Team.Score == nil {
			break
		}

		return e.complexity.Team.Score(childComplexity), true

	case "Team.updatedAt":
		if e.complexity.Team.UpdatedAt == nil {
			break
		}

		return e.complexity.Team.UpdatedAt(childComplexity), true

	case "TeamMember.data":
		if e.complexity.TeamMember.Data == nil {
			break
		}

		return e.complexity.TeamMember.Data(childComplexity), true

	case "TeamMember.id":
		if e.complexity.TeamMember.Id == nil {
			break
		}

		return e.complexity.TeamMember.Id(childComplexity), true

	case "TeamMember.joinedAt":
		if e.complexity.TeamMember.JoinedAt == nil {
			break
		}

		return e.complexity.TeamMember.JoinedAt(childComplexity), true

	case "TeamMember.teamId":
		if e.complexity.TeamMember.TeamId == nil {
			break
		}

		return e.complexity.TeamMember.TeamId(childComplexity), true

	case "TeamMember.updatedAt":
		if e.complexity.TeamMember.UpdatedAt == nil {
			break
		}

		return e.complexity.TeamMember.UpdatedAt(childComplexity), true

	case "TeamMember.userId":
		if e.complexity.TeamMember.UserId == nil {
			break
		}

		return e.complexity.TeamMember.UserId(childComplexity), true

	case "TeamResponse.error":
		if e.complexity.TeamResponse.Error == nil {
			break
		}

		return e.complexity.TeamResponse.Error(childComplexity), true

	case "TeamResponse.success":
		if e.complexity.TeamResponse.Success == nil {
			break
		}

		return e.complexity.TeamResponse.Success(childComplexity), true

	case "TournamentUser.createdAt":
		if e.complexity.TournamentUser.CreatedAt == nil {
			break
		}

		return e.complexity.TournamentUser.CreatedAt(childComplexity), true

	case "TournamentUser.data":
		if e.complexity.TournamentUser.Data == nil {
			break
		}

		return e.complexity.TournamentUser.Data(childComplexity), true

	case "TournamentUser.id":
		if e.complexity.TournamentUser.Id == nil {
			break
		}

		return e.complexity.TournamentUser.Id(childComplexity), true

	case "TournamentUser.interval":
		if e.complexity.TournamentUser.Interval == nil {
			break
		}

		return e.complexity.TournamentUser.Interval(childComplexity), true

	case "TournamentUser.ranking":
		if e.complexity.TournamentUser.Ranking == nil {
			break
		}

		return e.complexity.TournamentUser.Ranking(childComplexity), true

	case "TournamentUser.score":
		if e.complexity.TournamentUser.Score == nil {
			break
		}

		return e.complexity.TournamentUser.Score(childComplexity), true

	case "TournamentUser.tournament":
		if e.complexity.TournamentUser.Tournament == nil {
			break
		}

		return e.complexity.TournamentUser.Tournament(childComplexity), true

	case "TournamentUser.tournamentStartedAt":
		if e.complexity.TournamentUser.TournamentStartedAt == nil {
			break
		}

		return e.complexity.TournamentUser.TournamentStartedAt(childComplexity), true

	case "TournamentUser.updatedAt":
		if e.complexity.TournamentUser.UpdatedAt == nil {
			break
		}

		return e.complexity.TournamentUser.UpdatedAt(childComplexity), true

	case "TournamentUser.userId":
		if e.complexity.TournamentUser.UserId == nil {
			break
		}

		return e.complexity.TournamentUser.UserId(childComplexity), true

	case "TournamentUserResponse.error":
		if e.complexity.TournamentUserResponse.Error == nil {
			break
		}

		return e.complexity.TournamentUserResponse.Error(childComplexity), true

	case "TournamentUserResponse.success":
		if e.complexity.TournamentUserResponse.Success == nil {
			break
		}

		return e.complexity.TournamentUserResponse.Success(childComplexity), true

	case "UpdateArenaResponse.error":
		if e.complexity.UpdateArenaResponse.Error == nil {
			break
		}

		return e.complexity.UpdateArenaResponse.Error(childComplexity), true

	case "UpdateArenaResponse.success":
		if e.complexity.UpdateArenaResponse.Success == nil {
			break
		}

		return e.complexity.UpdateArenaResponse.Success(childComplexity), true

	case "UpdateEventResponse.error":
		if e.complexity.UpdateEventResponse.Error == nil {
			break
		}

		return e.complexity.UpdateEventResponse.Error(childComplexity), true

	case "UpdateEventResponse.success":
		if e.complexity.UpdateEventResponse.Success == nil {
			break
		}

		return e.complexity.UpdateEventResponse.Success(childComplexity), true

	case "UpdateEventRoundResponse.error":
		if e.complexity.UpdateEventRoundResponse.Error == nil {
			break
		}

		return e.complexity.UpdateEventRoundResponse.Error(childComplexity), true

	case "UpdateEventRoundResponse.success":
		if e.complexity.UpdateEventRoundResponse.Success == nil {
			break
		}

		return e.complexity.UpdateEventRoundResponse.Success(childComplexity), true

	case "UpdateEventUserResponse.error":
		if e.complexity.UpdateEventUserResponse.Error == nil {
			break
		}

		return e.complexity.UpdateEventUserResponse.Error(childComplexity), true

	case "UpdateEventUserResponse.success":
		if e.complexity.UpdateEventUserResponse.Success == nil {
			break
		}

		return e.complexity.UpdateEventUserResponse.Success(childComplexity), true

	case "UpdateItemResponse.error":
		if e.complexity.UpdateItemResponse.Error == nil {
			break
		}

		return e.complexity.UpdateItemResponse.Error(childComplexity), true

	case "UpdateItemResponse.success":
		if e.complexity.UpdateItemResponse.Success == nil {
			break
		}

		return e.complexity.UpdateItemResponse.Success(childComplexity), true

	case "UpdateMatchResponse.error":
		if e.complexity.UpdateMatchResponse.Error == nil {
			break
		}

		return e.complexity.UpdateMatchResponse.Error(childComplexity), true

	case "UpdateMatchResponse.success":
		if e.complexity.UpdateMatchResponse.Success == nil {
			break
		}

		return e.complexity.UpdateMatchResponse.Success(childComplexity), true

	case "UpdateMatchmakingTicketResponse.error":
		if e.complexity.UpdateMatchmakingTicketResponse.Error == nil {
			break
		}

		return e.complexity.UpdateMatchmakingTicketResponse.Error(childComplexity), true

	case "UpdateMatchmakingTicketResponse.success":
		if e.complexity.UpdateMatchmakingTicketResponse.Success == nil {
			break
		}

		return e.complexity.UpdateMatchmakingTicketResponse.Success(childComplexity), true

	case "UpdateMatchmakingUserResponse.error":
		if e.complexity.UpdateMatchmakingUserResponse.Error == nil {
			break
		}

		return e.complexity.UpdateMatchmakingUserResponse.Error(childComplexity), true

	case "UpdateMatchmakingUserResponse.success":
		if e.complexity.UpdateMatchmakingUserResponse.Success == nil {
			break
		}

		return e.complexity.UpdateMatchmakingUserResponse.Success(childComplexity), true

	case "UpdateRecordResponse.error":
		if e.complexity.UpdateRecordResponse.Error == nil {
			break
		}

		return e.complexity.UpdateRecordResponse.Error(childComplexity), true

	case "UpdateRecordResponse.success":
		if e.complexity.UpdateRecordResponse.Success == nil {
			break
		}

		return e.complexity.UpdateRecordResponse.Success(childComplexity), true

	case "UpdateTaskResponse.error":
		if e.complexity.UpdateTaskResponse.Error == nil {
			break
		}

		return e.complexity.UpdateTaskResponse.Error(childComplexity), true

	case "UpdateTaskResponse.success":
		if e.complexity.UpdateTaskResponse.Success == nil {
			break
		}

		return e.complexity.UpdateTaskResponse.Success(childComplexity), true

	case "UpdateTeamMemberResponse.error":
		if e.complexity.UpdateTeamMemberResponse.Error == nil {
			break
		}

		return e.complexity.UpdateTeamMemberResponse.Error(childComplexity), true

	case "UpdateTeamMemberResponse.success":
		if e.complexity.UpdateTeamMemberResponse.Success == nil {
			break
		}

		return e.complexity.UpdateTeamMemberResponse.Success(childComplexity), true

	case "UpdateTeamResponse.error":
		if e.complexity.UpdateTeamResponse.Error == nil {
			break
		}

		return e.complexity.UpdateTeamResponse.Error(childComplexity), true

	case "UpdateTeamResponse.success":
		if e.complexity.UpdateTeamResponse.Success == nil {
			break
		}

		return e.complexity.UpdateTeamResponse.Success(childComplexity), true

	case "UpdateTournamentUserResponse.error":
		if e.complexity.UpdateTournamentUserResponse.Error == nil {
			break
		}

		return e.complexity.UpdateTournamentUserResponse.Error(childComplexity), true

	case "UpdateTournamentUserResponse.success":
		if e.complexity.UpdateTournamentUserResponse.Success == nil {
			break
		}

		return e.complexity.UpdateTournamentUserResponse.Success(childComplexity), true

	case "WebhookResponse.body":
		if e.complexity.WebhookResponse.Body == nil {
			break
		}

		return e.complexity.WebhookResponse.Body(childComplexity), true

	case "WebhookResponse.headers":
		if e.complexity.WebhookResponse.Headers == nil {
			break
		}

		return e.complexity.WebhookResponse.Headers(childComplexity), true

	case "WebhookResponse.status":
		if e.complexity.WebhookResponse.Status == nil {
			break
		}

		return e.complexity.WebhookResponse.Status(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddEventResultRequest,
		ec.unmarshalInputArenaRequest,
		ec.unmarshalInputCreateArenaRequest,
		ec.unmarshalInputCreateEventRequest,
		ec.unmarshalInputCreateEventRound,
		ec.unmarshalInputCreateEventRoundRequest,
		ec.unmarshalInputCreateItemRequest,
		ec.unmarshalInputCreateMatchmakingTicketRequest,
		ec.unmarshalInputCreateMatchmakingUserRequest,
		ec.unmarshalInputCreateRecordRequest,
		ec.unmarshalInputCreateTaskRequest,
		ec.unmarshalInputCreateTeamRequest,
		ec.unmarshalInputCreateTournamentUserRequest,
		ec.unmarshalInputEndMatchRequest,
		ec.unmarshalInputEventRequest,
		ec.unmarshalInputEventRoundRequest,
		ec.unmarshalInputEventRoundUserRequest,
		ec.unmarshalInputEventUserRequest,
		ec.unmarshalInputGetEventRequest,
		ec.unmarshalInputGetEventRoundRequest,
		ec.unmarshalInputGetEventUserRequest,
		ec.unmarshalInputGetItemsRequest,
		ec.unmarshalInputGetMatchRequest,
		ec.unmarshalInputGetMatchesRequest,
		ec.unmarshalInputGetMatchmakingTicketRequest,
		ec.unmarshalInputGetMatchmakingTicketsRequest,
		ec.unmarshalInputGetRecordsRequest,
		ec.unmarshalInputGetTasksRequest,
		ec.unmarshalInputGetTeamRequest,
		ec.unmarshalInputGetTeamsRequest,
		ec.unmarshalInputGetTournamentUsersRequest,
		ec.unmarshalInputItemRequest,
		ec.unmarshalInputJoinTeamRequest,
		ec.unmarshalInputMatchRequest,
		ec.unmarshalInputMatchmakingTicketRequest,
		ec.unmarshalInputMatchmakingUserRequest,
		ec.unmarshalInputNameUserId,
		ec.unmarshalInputPagination,
		ec.unmarshalInputRecordRequest,
		ec.unmarshalInputSearchTeamsRequest,
		ec.unmarshalInputSetMatchPrivateServerRequest,
		ec.unmarshalInputStartMatchRequest,
		ec.unmarshalInputTaskRequest,
		ec.unmarshalInputTeamMemberRequest,
		ec.unmarshalInputTeamRequest,
		ec.unmarshalInputTournamentIntervalUserId,
		ec.unmarshalInputTournamentUserRequest,
		ec.unmarshalInputUpdateArenaRequest,
		ec.unmarshalInputUpdateEventRequest,
		ec.unmarshalInputUpdateEventRoundRequest,
		ec.unmarshalInputUpdateEventUserRequest,
		ec.unmarshalInputUpdateItemRequest,
		ec.unmarshalInputUpdateMatchRequest,
		ec.unmarshalInputUpdateMatchmakingTicketRequest,
		ec.unmarshalInputUpdateMatchmakingUserRequest,
		ec.unmarshalInputUpdateRecordRequest,
		ec.unmarshalInputUpdateTaskRequest,
		ec.unmarshalInputUpdateTeamMemberRequest,
		ec.unmarshalInputUpdateTeamRequest,
		ec.unmarshalInputUpdateTournamentUserRequest,
		ec.unmarshalInputWebhookRequest,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../api/event.graphql", Input: `extend type Query {
	" Get an event by ID or name. Also returns a leaderboard of event users. "
	GetEvent(input: GetEventRequest): GetEventResponse! @doc(category: "Event")
	" Get an event round by ID, or by event object and round name. Also returns leaderboard for the round. If a round name is not provided, the current round is returned."
	GetEventRound(input: GetEventRoundRequest): GetEventRoundResponse! @doc(category: "Event")
	" Get an event user by ID, or by event object and user ID. Also returns the user's results for each round."
	GetEventUser(input: GetEventUserRequest): GetEventUserResponse! @doc(category: "Event")
}

extend type Mutation {
	" Create a new event. "
	CreateEvent(input: CreateEventRequest): CreateEventResponse! @doc(category: "Event")
	" Update an existing event, identified by ID or name. "
	UpdateEvent(input: UpdateEventRequest): UpdateEventResponse! @doc(category: "Event")
	" Delete an event by ID or name. "
	DeleteEvent(input: EventRequest): EventResponse! @doc(category: "Event")
	" Create a new event round by providing an event object and round data. "
	CreateEventRound(input: CreateEventRoundRequest): CreateEventRoundResponse! @doc(category: "Event")
	" Update an existing event round, identified by ID, or event object and round name. "
	UpdateEventRound(input: UpdateEventRoundRequest): UpdateEventRoundResponse! @doc(category: "Event")
	" Update an existing event user, identified by ID, or event object and user ID. "
	UpdateEventUser(input: UpdateEventUserRequest): UpdateEventUserResponse! @doc(category: "Event")
	" Delete an event user by ID, or event object and user ID. "
	DeleteEventUser(input: EventUserRequest): EventUserResponse! @doc(category: "Event")
	" Add a result to the event for a user, identified by ID. The result is added to the current round. "
	AddEventResult(input: AddEventResultRequest): AddEventResultResponse! @doc(category: "Event")
	" Remove a result for a user in an event round, identified by ID, or event user object and round name. If the round name is not provided, the current round is used. "
	RemoveEventResult(input: EventRoundUserRequest): RemoveEventResultResponse! @doc(category: "Event")
}

" Input type for creating an event round. The difference between the endedAt fields of the different rounds signifies the start and end of the round. The scoring field is an array of integers that represent the score for each rank. The first element is the score for the first rank, the second element is the score for the second rank, and so on."
input CreateEventRound @doc(category: "Event") {
	name: String!
	data: Struct!
	endedAt: Timestamp!
	scoring: [Uint64!]!
}

" Input type for creating an event. The rounds field is an array of CreateEventRound objects."
input CreateEventRequest @doc(category: "Event") {
	name: String!
	data: Struct!
	startedAt: Timestamp!
	rounds: [CreateEventRound]!
}

" Response type for creating an event. "
type CreateEventResponse @doc(category: "Event") {
	success: Boolean!
	id: Uint64
	error: CreateEventError!
}

" Possible errors when creating an event. "
enum CreateEventError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	DATA_REQUIRED
	STARTED_AT_REQUIRED
	STARTED_AT_IN_THE_PAST
	ROUNDS_REQUIRED
	TOO_MANY_ROUNDS
	ROUND_NAME_TOO_SHORT
	ROUND_NAME_TOO_LONG
	ROUND_DATA_REQUIRED
	ROUND_ENDED_AT_REQUIRED
	ROUND_ENDED_AT_BEFORE_STARTED_AT
	ROUND_SCORING_REQUIRED
	ALREADY_EXISTS
	DUPLICATE_ROUND_NAME
	DUPLICATE_ROUND_ENDED_AT
}

" The event object is used to identify an event by ID or name. "
input EventRequest @doc(category: "Event") {
	id: Uint64
	name: String
}

" Input type for getting an event. The pagination field is used to paginate the leaderboard."
input GetEventRequest @doc(category: "Event") {
	event: EventRequest!
	pagination: Pagination
}

" Response type for getting an event. "
type GetEventResponse @doc(category: "Event") {
	success: Boolean!
	event: Event
	leaderboard: [EventUser]!
	error: GetEventError!
}

" Possible errors when getting an event. "
enum GetEventError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	NOT_FOUND
}

" Input type for updating an event. "
input UpdateEventRequest @doc(category: "Event") {
	event: EventRequest!
	data: Struct!
}

" Response type for updating an event. "
type UpdateEventResponse @doc(category: "Event") {
	success: Boolean!
	error: UpdateEventError!
}

" Possible errors when updating an event. "
enum UpdateEventError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	DATA_REQUIRED
	NOT_FOUND
}

" Response type for deleting an event. "
type EventResponse @doc(category: "Event") {
	success: Boolean!
	error: EventError!
}

" Possible errors when deleting an event. "
enum EventError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	NOT_FOUND
}

" Input type for creating an event round. "
input CreateEventRoundRequest @doc(category: "Event") {
	event: EventRequest!
	round: CreateEventRound!
}

" Response type for creating an event round. "
type CreateEventRoundResponse @doc(category: "Event") {
	success: Boolean!
	id: Uint64
	error: CreateEventRoundError!
}

" Possible errors when creating an event round. "
enum CreateEventRoundError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	ROUND_REQUIRED
	ROUND_NAME_TOO_SHORT
	ROUND_NAME_TOO_LONG
	ROUND_DATA_REQUIRED
	ROUND_ENDED_AT_REQUIRED
	ROUND_ENDED_AT_IN_THE_PAST
	ROUND_ENDED_AT_BEFORE_EVENT_STARTED_AT
	ROUND_SCORING_REQUIRED
	NOT_FOUND
	DUPLICATE_ROUND_NAME
	DUPLICATE_ROUND_ENDED_AT
}

" Input type for getting an event round. If the round name is not provided, the current round is used. "
input EventRoundRequest @doc(category: "Event") {
	id: Uint64
	event: EventRequest
	roundName: String
}

" Input type for getting an event round. The pagination field is used to paginate the leaderboard."
input GetEventRoundRequest @doc(category: "Event") {
	round: EventRoundRequest!
	pagination: Pagination
}

" Response type for getting an event round. "
type GetEventRoundResponse @doc(category: "Event") {
	success: Boolean!
	round: EventRound
	results: [EventRoundUser]!
	error: GetEventRoundError!
}

" Possible errors when getting an event round. "
enum GetEventRoundError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	EVENT_ROUND_OR_ID_REQUIRED
	NOT_FOUND
}

" Input type for updating an event round. "
input UpdateEventRoundRequest @doc(category: "Event") {
	round: EventRoundRequest!
	data: Struct
	scoring: [Uint64!]
}

" Response type for updating an event round. "
type UpdateEventRoundResponse @doc(category: "Event") {
	success: Boolean!
	error: UpdateEventRoundError!
}

" Possible errors when updating an event round. "
enum UpdateEventRoundError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	EVENT_ROUND_OR_ID_REQUIRED
	NO_UPDATE_SPECIFIED
	NOT_FOUND
}

" Input type for getting an event user. "
input EventUserRequest @doc(category: "Event") {
	id: Uint64
	event: EventRequest
	clientUserId: Uint64
}

" Input type for getting an event user. "
input GetEventUserRequest @doc(category: "Event") {
	user: EventUserRequest!
	pagination: Pagination
}

" Response type for getting an event user. "
type GetEventUserResponse @doc(category: "Event") {
	success: Boolean!
	user: EventUser
	results: [EventRoundUser]!
	error: GetEventUserError!
}

" Possible errors when getting an event user. "
enum GetEventUserError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	CLIENT_USER_ID_REQUIRED
	EVENT_USER_OR_ID_REQUIRED
	NOT_FOUND
}

" Input type for updating an event user. "
input UpdateEventUserRequest @doc(category: "Event") {
	user: EventUserRequest!
	data: Struct!
}

" Response type for updating an event user. "
type UpdateEventUserResponse @doc(category: "Event") {
	success: Boolean!
	error: UpdateEventUserError!
}

" Possible errors when updating an event user. "
enum UpdateEventUserError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	CLIENT_USER_ID_REQUIRED
	EVENT_USER_OR_ID_REQUIRED
	DATA_REQUIRED
	NOT_FOUND
}

" Response type for deleting an event user. "
type EventUserResponse @doc(category: "Event") {
	success: Boolean!
	error: EventUserError!
}

" Possible errors when deleting an event user. "
enum EventUserError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	CLIENT_USER_ID_REQUIRED
	NOT_FOUND
}

" Input type for adding an event result. The result field is the time, score, or other value that the user achieved in the event, ranked from low to high. The userData field is a Struct that can contain any additional data that should be stored with the event user object. The roundUserData field is a Struct that can contain any additional data that should be stored with the user result for the round. If the event user already exists the data field will be updated. If the user already has a result for the round, the result and data fields will be updated. "
input AddEventResultRequest @doc(category: "Event") {
	event: EventRequest!
	clientUserId: Uint64!
	result: Uint64!
	userData: Struct!
	roundUserData: Struct!
}

" Response type for adding an event result. "
type AddEventResultResponse @doc(category: "Event") {
	success: Boolean!
	error: AddEventResultError!
}

" Possible errors when adding an event result. "
enum AddEventResultError @doc(category: "Event") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ID_OR_NAME_REQUIRED
	CLIENT_USER_ID_REQUIRED
	RESULT_REQUIRED
	USER_DATA_REQUIRED
	ROUND_USER_DATA_REQUIRED
	NOT_FOUND
	EVENT_ENDED
}

" Input type for removing an event result. "
input EventRoundUserRequest @doc(category: "Event") {
	id: Uint64!
}

" Response type for removing an event result. "
type RemoveEventResultResponse @doc(category: "Event") {
	success: Boolean!
	error: RemoveEventResultError!
}

" Possible errors when removing an event result. "
enum RemoveEventResultError @doc(category: "Event") {
	NONE
	ID_REQUIRED
	NOT_FOUND
	EVENT_ENDED
}

" Type representing an event. The current round is the round that is currently active, it will be the first round if the event has not started yet, or if all rounds have ended it will be null. "
type Event @doc(category: "Event") {
	id: Uint64!
	name: String!
	currentRoundId: Uint64
	currentRoundName: String
	data: Struct!
	rounds: [EventRound]!
	startedAt: Timestamp!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" Type representing an event round. "
type EventRound @doc(category: "Event") {
	id: Uint64!
	eventId: Uint64!
	name: String!
	scoring: [Uint64!]!
	data: Struct!
	endedAt: Timestamp!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" Type representing an event user. "
type EventUser @doc(category: "Event") {
	id: Uint64!
	eventId: Uint64!
	clientUserId: Uint64!
	score: Uint64!
	ranking: Uint64!
	data: Struct!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" Type representing an event round user. "
type EventRoundUser @doc(category: "Event") {
	id: Uint64!
	eventUserId: Uint64!
	clientUserId: Uint64!
	eventRoundId: Uint64!
	result: Uint64!
	ranking: Uint64!
	data: Struct!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/item.graphql", Input: `extend type Query {
	" Get an item by ID and type. "
	GetItem(input: ItemRequest): GetItemResponse! @doc(category: "Item")
	" Get a list of items based on type and pagination options. "
	GetItems(input: GetItemsRequest): GetItemsResponse! @doc(category: "Item")
}

extend type Mutation {
	" Create a new item with the specified ID, type, data, and optional expiration date. "
	CreateItem(input: CreateItemRequest): CreateItemResponse! @doc(category: "Item")
	" Update an existing item with the specified ID, type, data, and optional expiration date. "
	UpdateItem(input: UpdateItemRequest): UpdateItemResponse! @doc(category: "Item")
	" Delete an item by ID and type. "
	DeleteItem(input: ItemRequest): ItemResponse! @doc(category: "Item")
}

" Input object for creating a new item. An expiration date can be specified, but it is optional. You are free to use any value as an ID, but an ID and Type combination must be unique in the system. "
input CreateItemRequest @doc(category: "Item") {
	id: ID!
	type: String!
	data: Struct!
	expiresAt: Timestamp
}

" Response object for creating an item. "
type CreateItemResponse @doc(category: "Item") {
	success: Boolean!
	error: CreateItemError!
}

" Possible errors when creating an item. "
enum CreateItemError @doc(category: "Item") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	DATA_REQUIRED
	ALREADY_EXISTS
}

" Input object for requesting an item by ID and type. "
input ItemRequest @doc(category: "Item") {
	id: ID!
	type: String!
}

" Response object for getting an item. "
type GetItemResponse @doc(category: "Item") {
	success: Boolean!
	item: Item
	error: GetItemError!
}

" Possible errors when getting an item. "
enum GetItemError @doc(category: "Item") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
}

" Input object for requesting a list of items based on type and pagination options. "
input GetItemsRequest @doc(category: "Item") {
	type: String
	pagination: Pagination
}

" Response object for getting a list of items. "
type GetItemsResponse @doc(category: "Item") {
	success: Boolean!
	items: [Item]!
}

" Response object for item-related operations. "
type ItemResponse @doc(category: "Item") {
	success: Boolean!
	error: ItemError!
}

" Possible errors related to items. "
enum ItemError @doc(category: "Item") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
}

" Input object for updating an item. "
input UpdateItemRequest @doc(category: "Item") {
	item: ItemRequest!
	data: Struct!
}

" Response object for updating an item. "
type UpdateItemResponse @doc(category: "Item") {
	success: Boolean!
	error: UpdateItemError!
}

" Possible errors when updating an item. "
enum UpdateItemError @doc(category: "Item") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
	DATA_REQUIRED
}

" Represents an item. "
type Item @doc(category: "Item") {
	id: ID!
	type: String!
	data: Struct!
	expiresAt: Timestamp
	createdAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/matchmaking.graphql", Input: `extend type Query {
	" Get an arena by ID, or name. "
	GetArena(input: ArenaRequest): GetArenaResponse! @doc(category: "Matchmaking")
	" Get a list of arenas based on name and pagination options. "
	GetArenas(input: Pagination): GetArenasResponse! @doc(category: "Matchmaking")
	" Get a matchmaking user by ID, or client user ID. "
	GetMatchmakingUser(input: MatchmakingUserRequest): GetMatchmakingUserResponse! @doc(category: "Matchmaking")
	" Get a list of matchmaking users based on client user ID and pagination options. "
	GetMatchmakingUsers(input: Pagination): GetMatchmakingUsersResponse! @doc(category: "Matchmaking")
	" Get a matchmaking ticket by ID, or matchmaking user. "
	GetMatchmakingTicket(input: GetMatchmakingTicketRequest): GetMatchmakingTicketResponse! @doc(category: "Matchmaking")
	" Get a list of matchmaking tickets based on match ID, matchmaking user, status, and pagination options. "
	GetMatchmakingTickets(input: GetMatchmakingTicketsRequest): GetMatchmakingTicketsResponse! @doc(category: "Matchmaking")
	" Get a match by ID, or matchmaking ticket. "
	GetMatch(input: GetMatchRequest): GetMatchResponse! @doc(category: "Matchmaking")
	" Get a list of matches based on arena, matchmaking user, status, and pagination options. "
	GetMatches(input: GetMatchesRequest): GetMatchesResponse! @doc(category: "Matchmaking")
}

extend type Mutation {
	" Create a new arena with the specified name, min players, max players per ticket, max players, and data. "
	CreateArena(input: CreateArenaRequest): CreateArenaResponse! @doc(category: "Matchmaking")
	" Update an existing arena with the specified ID, name, min players, max players per ticket, max players, and data. "
	UpdateArena(input: UpdateArenaRequest): UpdateArenaResponse! @doc(category: "Matchmaking")
	" Create a new matchmaking user with the specified client user ID and data. "
	CreateMatchmakingUser(input: CreateMatchmakingUserRequest): CreateMatchmakingUserResponse! @doc(category: "Matchmaking")
	" Update an existing matchmaking user's data with the specified ID and client user ID. "
	UpdateMatchmakingUser(input: UpdateMatchmakingUserRequest): UpdateMatchmakingUserResponse! @doc(category: "Matchmaking")
	" Delete a matchmaking user by ID, or client user ID. If the user is currently in a matchmaking ticket, it cannot be deleted. Instead the ticket will need to be deleted first. "
	DeleteMatchmakingUser(input: MatchmakingUserRequest): DeleteMatchmakingUserResponse! @doc(category: "Matchmaking")
	" Create a new matchmaking ticket with the specified matchmaking users, arenas, and data. "
	CreateMatchmakingTicket(input: CreateMatchmakingTicketRequest): CreateMatchmakingTicketResponse! @doc(category: "Matchmaking")
	" Update an existing matchmaking ticket with the specified ID, or matchmaking user, and data. "
	UpdateMatchmakingTicket(input: UpdateMatchmakingTicketRequest): UpdateMatchmakingTicketResponse! @doc(category: "Matchmaking")
	" Delete a matchmaking ticket by ID, or matchmaking user. This will also delete the users associated with the ticket. If this ticket has been matched to a match, it cannot be deleted. Instead the match will need to be deleted. "
	DeleteMatchmakingTicket(input: MatchmakingTicketRequest): DeleteMatchmakingTicketResponse! @doc(category: "Matchmaking")
	" Start a match by ID, or matchmaking ticket. "
	StartMatch(input: StartMatchRequest): StartMatchResponse! @doc(category: "Matchmaking")
	" End a match by ID, or matchmaking ticket. "
	EndMatch(input: EndMatchRequest): EndMatchResponse! @doc(category: "Matchmaking")
	" Update an existing match with the specified ID, or matchmaking ticket, and data. "
	UpdateMatch(input: UpdateMatchRequest): UpdateMatchResponse! @doc(category: "Matchmaking")
	" Set the private server of the match. Once this is set it cannot be changed, to prevent race conditions from the server. "
	SetMatchPrivateServer(input: SetMatchPrivateServerRequest): SetMatchPrivateServerResponse! @doc(category: "Matchmaking")
	" Delete a match by ID, or matchmaking ticket. This will delete all the tickets and users associated with the match. "
	DeleteMatch(input: MatchRequest): DeleteMatchResponse! @doc(category: "Matchmaking")
}

" Input object for creating a new arena. "
input CreateArenaRequest @doc(category: "Matchmaking") {
	name: String!
	minPlayers: Uint32!
	maxPlayersPerTicket: Uint32!
	maxPlayers: Uint32!
	data: Struct!
}

" Response object for creating an arena. "
type CreateArenaResponse @doc(category: "Matchmaking") {
	success: Boolean!
	id: Uint64
	error: CreateArenaError!
}

" Possible errors when creating an arena. "
enum CreateArenaError @doc(category: "Matchmaking") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	MIN_PLAYERS_REQUIRED
	MAX_PLAYERS_PER_TICKET_REQUIRED
	MAX_PLAYERS_REQUIRED
	MIN_PLAYERS_CANNOT_BE_GREATER_THAN_MAX_PLAYERS
	MAX_PLAYERS_PER_TICKET_CANNOT_BE_GREATER_THAN_MAX_PLAYERS
	DATA_REQUIRED
	ALREADY_EXISTS
}

" Input object for requesting an arena by ID, or name. "
input ArenaRequest @doc(category: "Matchmaking") {
	id: Uint64
	name: String
}

" Response object for getting an arena. "
type GetArenaResponse @doc(category: "Matchmaking") {
	success: Boolean!
	arena: Arena
	error: GetArenaError!
}

" Possible errors when getting an arena. "
enum GetArenaError @doc(category: "Matchmaking") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ARENA_ID_OR_NAME_REQUIRED
	NOT_FOUND
}

" Response object for getting a list of arenas. "
type GetArenasResponse @doc(category: "Matchmaking") {
	success: Boolean!
	arenas: [Arena]
}

" Input object for updating an existing arena. "
input UpdateArenaRequest @doc(category: "Matchmaking") {
	arena: ArenaRequest!
	minPlayers: Uint32
	maxPlayersPerTicket: Uint32
	maxPlayers: Uint32
	data: Struct
}

" Response object for updating an arena. "
type UpdateArenaResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: UpdateArenaError!
}

" Possible errors when updating an arena. "
enum UpdateArenaError @doc(category: "Matchmaking") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	ARENA_ID_OR_NAME_REQUIRED
	NO_UPDATE_SPECIFIED
	IF_CAPACITY_CHANGED_MUST_CHANGE_ALL_PLAYERS
	MIN_PLAYERS_CANNOT_BE_GREATER_THAN_MAX_PLAYERS
	MAX_PLAYERS_PER_TICKET_CANNOT_BE_GREATER_THAN_MAX_PLAYERS
	ARENA_CURRENTLY_IN_USE
	NOT_FOUND
}

" Input object for creating a new matchmaking user. The elo that is set is the default elo for the user across all arenas. "
input CreateMatchmakingUserRequest @doc(category: "Matchmaking") {
	clientUserId: Uint64!
	elo: Int64!
	data: Struct!
}

" Response object for creating a matchmaking user. "
type CreateMatchmakingUserResponse @doc(category: "Matchmaking") {
	success: Boolean!
	id: Uint64
	error: CreateMatchmakingUserError!
}

" Possible errors when creating a matchmaking user. "
enum CreateMatchmakingUserError @doc(category: "Matchmaking") {
	NONE
	CLIENT_USER_ID_REQUIRED
	DATA_REQUIRED
	ALREADY_EXISTS
}

" Input object for requesting a matchmaking user by ID, or client user ID. "
input MatchmakingUserRequest @doc(category: "Matchmaking") {
	id: Uint64
	clientUserId: Uint64
}

" Response object for getting a matchmaking user. "
type GetMatchmakingUserResponse @doc(category: "Matchmaking") {
	success: Boolean!
	matchmakingUser: MatchmakingUser
	error: GetMatchmakingUserError!
}

" Possible errors when getting a matchmaking user. "
enum GetMatchmakingUserError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	NOT_FOUND
}

" Response object for getting a list of matchmaking users. "
type GetMatchmakingUsersResponse @doc(category: "Matchmaking") {
	success: Boolean!
	matchmakingUsers: [MatchmakingUser]
}

" Input object for updating an existing matchmaking user. "
input UpdateMatchmakingUserRequest @doc(category: "Matchmaking") {
	matchmakingUser: MatchmakingUserRequest!
	data: Struct
}

" Response object for updating a matchmaking user. "
type UpdateMatchmakingUserResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: UpdateMatchmakingUserError!
}

" Response object for deleting a matchmaking user. "
type DeleteMatchmakingUserResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: DeleteMatchmakingUserError!
}

" Possible errors when deleting a matchmaking user. "
enum DeleteMatchmakingUserError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	NOT_FOUND
	USER_CURRENTLY_IN_TICKET
	USER_CURRENTLY_IN_MATCH
}

" Possible errors when updating a matchmaking user. "
enum UpdateMatchmakingUserError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	DATA_REQUIRED
	NOT_FOUND
}

" Input object for creating a new matchmaking ticket. "
input CreateMatchmakingTicketRequest @doc(category: "Matchmaking") {
	matchmakingUsers: [MatchmakingUserRequest]!
	arenas: [ArenaRequest]!
	data: Struct!
}

" Response object for creating a matchmaking ticket. "
type CreateMatchmakingTicketResponse @doc(category: "Matchmaking") {
	success: Boolean!
	id: Uint64
	error: CreateMatchmakingTicketError!
}

" Possible errors when creating a matchmaking ticket. "
enum CreateMatchmakingTicketError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_USERS_REQUIRED
	ARENAS_REQUIRED
	DATA_REQUIRED
	TOO_MANY_PLAYERS
	USER_NOT_FOUND
	ARENA_NOT_FOUND
	USER_ALREADY_IN_TICKET
}

" Input object for requesting a matchmaking ticket by ID, or matchmaking user. "
input MatchmakingTicketRequest @doc(category: "Matchmaking") {
	id: Uint64
	matchmakingUser: MatchmakingUserRequest
}

" Input object for requesting a matchmaking ticket by ID, or matchmaking user. "
input GetMatchmakingTicketRequest @doc(category: "Matchmaking") {
	matchmakingTicket: MatchmakingTicketRequest!
	userPagination: Pagination
	arenaPagination: Pagination
}

" Response object for getting a matchmaking ticket. "
type GetMatchmakingTicketResponse @doc(category: "Matchmaking") {
	success: Boolean!
	matchmakingTicket: MatchmakingTicket
	error: GetMatchmakingTicketError!
}

" Possible errors when getting a matchmaking ticket. "
enum GetMatchmakingTicketError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	NOT_FOUND
}

" Input object for requesting a list of matchmaking tickets based on match ID, matchmaking user, status, and pagination options. "
input GetMatchmakingTicketsRequest @doc(category: "Matchmaking") {
	matchId: Uint64
	matchmakingUser: MatchmakingUserRequest
	statuses: [MatchmakingTicketStatus]
	pagination: Pagination
	userPagination: Pagination
	arenaPagination: Pagination
}

" Response object for getting a list of matchmaking tickets. "
type GetMatchmakingTicketsResponse @doc(category: "Matchmaking") {
	success: Boolean!
	matchmakingTickets: [MatchmakingTicket]
	error: GetMatchmakingTicketsError!
}

" Possible errors when getting a list of matchmaking tickets. "
enum GetMatchmakingTicketsError @doc(category: "Matchmaking") {
	NONE
	MATCH_NOT_FOUND
	USER_NOT_FOUND
}

" Input object for updating an existing matchmaking ticket. "
input UpdateMatchmakingTicketRequest @doc(category: "Matchmaking") {
	matchmakingTicket: MatchmakingTicketRequest!
	data: Struct!
}

" Response object for updating a matchmaking ticket. "
type UpdateMatchmakingTicketResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: UpdateMatchmakingTicketError!
}

" Possible errors when updating a matchmaking ticket. "
enum UpdateMatchmakingTicketError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	DATA_REQUIRED
	NOT_FOUND
}

" Response object for deleting a matchmaking ticket. "
type DeleteMatchmakingTicketResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: DeleteMatchmakingTicketError!
}

" Possible errors when deleting a matchmaking ticket. "
enum DeleteMatchmakingTicketError @doc(category: "Matchmaking") {
	NONE
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	NOT_FOUND
	TICKET_CURRENTLY_IN_MATCH
}

" Input object for requesting a match by ID, or matchmaking ticket. "
input MatchRequest @doc(category: "Matchmaking") {
	id: Uint64
	matchmakingTicket: MatchmakingTicketRequest
}

" Input object for starting a match. "
input StartMatchRequest @doc(category: "Matchmaking") {
	match: MatchRequest!
	startTime: Timestamp!
}

" Response object for starting a match. "
type StartMatchResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: StartMatchError!
}

" Possible errors when starting a match. "
enum StartMatchError @doc(category: "Matchmaking") {
	NONE
	MATCH_ID_OR_MATCHMAKING_TICKET_REQUIRED
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	START_TIME_REQUIRED
	INVALID_START_TIME
	START_TIME_TOO_SOON
	NOT_FOUND
	NOT_ENOUGH_PLAYERS_TO_START
	ALREADY_HAS_START_TIME
	PRIVATE_SERVER_NOT_SET
}

" Input object for ending a match. "
input EndMatchRequest @doc(category: "Matchmaking") {
	match: MatchRequest!
	endTime: Timestamp!
}

" Response object for ending a match. "
type EndMatchResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: EndMatchError!
}

" Possible errors when ending a match. "
enum EndMatchError @doc(category: "Matchmaking") {
	NONE
	MATCH_ID_OR_MATCHMAKING_TICKET_REQUIRED
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	END_TIME_REQUIRED
	NOT_FOUND
	ALREADY_ENDED
	END_TIME_BEFORE_START_TIME
	START_TIME_NOT_SET
}

" Input object for requesting a match by ID, or matchmaking ticket. And pagination options for tickets and users. "
input GetMatchRequest @doc(category: "Matchmaking") {
	match: MatchRequest!
	ticketPagination: Pagination
	userPagination: Pagination
	arenaPagination: Pagination
}

" Response object for getting a match. "
type GetMatchResponse @doc(category: "Matchmaking") {
	success: Boolean!
	match: Match
	error: GetMatchError!
}

" Possible errors when getting a match. "
enum GetMatchError @doc(category: "Matchmaking") {
	NONE
	MATCH_ID_OR_MATCHMAKING_TICKET_REQUIRED
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	NOT_FOUND
}

" Input object for requesting a list of matches based on arena, matchmaking user, status, and pagination options. "
input GetMatchesRequest @doc(category: "Matchmaking") {
	arena: ArenaRequest
	matchmakingUser: MatchmakingUserRequest
	statuses: [MatchStatus]
	pagination: Pagination
	ticketPagination: Pagination
	userPagination: Pagination
	arenaPagination: Pagination
}

" Response object for getting a list of matches. "
type GetMatchesResponse @doc(category: "Matchmaking") {
	success: Boolean!
	matches: [Match]
}

" Input object for updating an existing match. "
input UpdateMatchRequest @doc(category: "Matchmaking") {
	match: MatchRequest!
	data: Struct!
}

" Response object for updating a match. "
type UpdateMatchResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: UpdateMatchError!
}

" Possible errors when updating a match. "
enum UpdateMatchError @doc(category: "Matchmaking") {
	NONE
	MATCH_ID_OR_MATCHMAKING_TICKET_REQUIRED
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	DATA_REQUIRED
	NOT_FOUND
}

" Input object for setting the private server of the match. "
input SetMatchPrivateServerRequest @doc(category: "Matchmaking") {
	match: MatchRequest!
	privateServerId: String!
}

" Response object for setting the private server of the match. If we receive a 'NONE' error or a 'PRIVATE_SERVER_ALREADY_SET' error, then a private server ID will be returned. "
type SetMatchPrivateServerResponse @doc(category: "Matchmaking") {
	success: Boolean!
	privateServerId: String
	error: SetMatchPrivateServerError!
}

" Possible errors when setting the private server of the match. "
enum SetMatchPrivateServerError @doc(category: "Matchmaking") {
	NONE
	MATCH_ID_OR_MATCHMAKING_TICKET_REQUIRED
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	PRIVATE_SERVER_ID_REQUIRED
	PRIVATE_SERVER_ALREADY_SET
	NOT_FOUND
}

" Response object for deleting a match. "
type DeleteMatchResponse @doc(category: "Matchmaking") {
	success: Boolean!
	error: DeleteMatchError!
}

" Possible errors when deleting a match. "
enum DeleteMatchError @doc(category: "Matchmaking") {
	NONE
	MATCH_ID_OR_MATCHMAKING_TICKET_REQUIRED
	MATCHMAKING_TICKET_ID_OR_MATCHMAKING_USER_REQUIRED
	MATCHMAKING_USER_ID_OR_CLIENT_USER_ID_REQUIRED
	NOT_FOUND
}

" An arena. "
type Arena @doc(category: "Matchmaking") {
	id: Uint64!
	name: String!
	minPlayers: Uint32!
	maxPlayersPerTicket: Uint32!
	maxPlayers: Uint32!
	data: Struct!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" A matchmaking user. Users are not long lived, they are created at the same time as a matchmaking ticket usually, but can be deleted as long as they are not yet part of a ticket. After that the only way to delete a user is to delete the ticket they are in. "
type MatchmakingUser @doc(category: "Matchmaking") {
	id: Uint64!
	clientUserId: Uint64!
	data: Struct!
	elo: Int64!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" Possible statuses for a matchmaking ticket. Pending means it's waiting to be matched. Matched means it's matched with other tickets, the match may have started or may not have. Ended means the match has ended. "
enum MatchmakingTicketStatus @doc(category: "Matchmaking") {
	PENDING
	MATCHED
	ENDED
}

" A matchmaking ticket. This is where users are grouped together into parties, and then matched with other tickets. These tickets will exist until they are deleted prior to being matched with a match, or the match is deleted. "
type MatchmakingTicket @doc(category: "Matchmaking") {
	id: Uint64!
	matchmakingUsers: [MatchmakingUser]!
	arenas: [Arena]!
	matchId: Uint64
	status: MatchmakingTicketStatus!
	data: Struct!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" Possible statuses for a match. Pending means it's waiting to be started. Started means it's currently being played. Ended means the match has ended. "
enum MatchStatus @doc(category: "Matchmaking") {
	PENDING
	STARTED
	ENDED
}

" A match. This is where tickets are matched together and played. "
type Match @doc(category: "Matchmaking") {
	id: Uint64!
	arena: Arena!
	tickets: [MatchmakingTicket]!
	privateServerId: String
	status: MatchStatus!
	data: Struct!
	lockedAt: Timestamp
	startedAt: Timestamp
	endedAt: Timestamp
	createdAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/record.graphql", Input: `extend type Query {
	" Get a record by ID, or name and user ID. "
	GetRecord(input: RecordRequest): GetRecordResponse! @doc(category: "Record")
	" Get a list of records based on name, user ID, and pagination options. "
	GetRecords(input: GetRecordsRequest): GetRecordsResponse! @doc(category: "Record")
}

extend type Mutation {
	" Create a new record with the specified name, user ID, record, and data. "
	CreateRecord(input: CreateRecordRequest): CreateRecordResponse! @doc(category: "Record")
	" Update an existing record with the specified ID, name and user ID, record, and data. "
	UpdateRecord(input: UpdateRecordRequest): UpdateRecordResponse! @doc(category: "Record")
	" Delete a record by ID, or name and user ID. "
	DeleteRecord(input: RecordRequest): DeleteRecordResponse! @doc(category: "Record")
}

" Input object for creating a new record. "
input CreateRecordRequest @doc(category: "Record") {
	name: String!
	userId: Uint64!
	record: Uint64!
	data: Struct!
}

" Response object for creating a record. "
type CreateRecordResponse @doc(category: "Record") {
	success: Boolean!
	id: Uint64
	error: CreateRecordError!
}

" Possible errors when creating a record. "
enum CreateRecordError @doc(category: "Record") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	USER_ID_REQUIRED
	RECORD_REQUIRED
	DATA_REQUIRED
	RECORD_EXISTS
}

" Input object for requesting a record by name and user ID. "
input NameUserId @doc(category: "Record") {
	name: String!
	userId: Uint64!
}

" Input object for requesting a record by ID, or name and user ID. "
input RecordRequest @doc(category: "Record") {
	id: Uint64
	nameUserId: NameUserId
}

" Response object for getting a record. "
type GetRecordResponse @doc(category: "Record") {
	success: Boolean!
	record: Record
	error: GetRecordError!
}

" Possible errors when getting a record. "
enum GetRecordError @doc(category: "Record") {
	NONE
	ID_OR_NAME_USER_ID_REQUIRED
	NOT_FOUND
	NAME_TOO_SHORT
	NAME_TOO_LONG
	USER_ID_REQUIRED
}

" Input object for requesting a list of records based on name, user ID, and pagination options. "
input GetRecordsRequest @doc(category: "Record") {
	name: String
	userId: Uint64
	pagination: Pagination
}

" Response object for getting a list of records. "
type GetRecordsResponse @doc(category: "Record") {
	success: Boolean!
	records: [Record]!
	error: GetRecordsError!
}

" Possible errors when getting a list of records. "
enum GetRecordsError @doc(category: "Record") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
}

" Input object for updating an existing record. "
input UpdateRecordRequest @doc(category: "Record") {
	request: RecordRequest!
	record: Uint64
	data: Struct
}

" Response object for updating a record. "
type UpdateRecordResponse @doc(category: "Record") {
	success: Boolean!
	error: UpdateRecordError!
}

" Possible errors when updating a record. "
enum UpdateRecordError @doc(category: "Record") {
	NONE
	ID_OR_NAME_USER_ID_REQUIRED
	NOT_FOUND
	NAME_TOO_SHORT
	NAME_TOO_LONG
	USER_ID_REQUIRED
	NO_UPDATE_SPECIFIED
}

" Response object for deleting a record. "
type DeleteRecordResponse @doc(category: "Record") {
	success: Boolean!
	error: DeleteRecordError!
}

" Possible errors when deleting a record. "
enum DeleteRecordError @doc(category: "Record") {
	NONE
	ID_OR_NAME_USER_ID_REQUIRED
	NOT_FOUND
	NAME_TOO_SHORT
	NAME_TOO_LONG
	USER_ID_REQUIRED
}

" The record object, ranked by record lowest to highest for each record name. "
type Record @doc(category: "Record") {
	id: Uint64!
	name: String!
	userId: Uint64!
	record: Uint64!
	ranking: Uint64!
	data: Struct!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/task.graphql", Input: `extend type Query {
	" Get an task by ID and type. "
	GetTask(input: TaskRequest): GetTaskResponse! @doc(category: "Task")
	" Get a list of tasks based on type and pagination options. "
	GetTasks(input: GetTasksRequest): GetTasksResponse! @doc(category: "Task")
}

extend type Mutation {
	" Create a new task with the specified ID, type, data, and optional expiration date. "
	CreateTask(input: CreateTaskRequest): CreateTaskResponse! @doc(category: "Task")
	" Update an existing task with the specified ID, type, data, and optional expiration date. "
	UpdateTask(input: UpdateTaskRequest): UpdateTaskResponse! @doc(category: "Task")
	" Complete an task by ID and type. "
	CompleteTask(input: TaskRequest): CompleteTaskResponse! @doc(category: "Task")
	" Delete an task by ID and type. "
	DeleteTask(input: TaskRequest): TaskResponse! @doc(category: "Task")
}

" Input object for creating a new task. An expiration date can be specified, but it is optional. You are free to use any value as an ID, but an ID and Type combination must be unique in the system. "
input CreateTaskRequest @doc(category: "Task") {
	id: ID!
	type: String!
	data: Struct!
	expiresAt: Timestamp
}

" Response object for creating an task. "
type CreateTaskResponse @doc(category: "Task") {
	success: Boolean!
	error: CreateTaskError!
}

" Possible errors when creating an task. "
enum CreateTaskError @doc(category: "Task") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	DATA_REQUIRED
	ALREADY_EXISTS
}

" Input object for requesting an task by ID and type. "
input TaskRequest @doc(category: "Task") {
	id: ID!
	type: String!
}

" Response object for getting an task. "
type GetTaskResponse @doc(category: "Task") {
	success: Boolean!
	task: Task
	error: GetTaskError!
}

" Possible errors when getting an task. "
enum GetTaskError @doc(category: "Task") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
}

" Input object for requesting a list of tasks based on type and pagination options. Can also filter by completion status. "
input GetTasksRequest @doc(category: "Task") {
	type: String
	completed: Boolean
	pagination: Pagination
}

" Response object for getting a list of tasks. "
type GetTasksResponse @doc(category: "Task") {
	success: Boolean!
	tasks: [Task]!
}

" Response object for task-related operations. "
type TaskResponse @doc(category: "Task") {
	success: Boolean!
	error: TaskError!
}

" Possible errors related to tasks. "
enum TaskError @doc(category: "Task") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
}

" Input object for updating an task. "
input UpdateTaskRequest @doc(category: "Task") {
	task: TaskRequest!
	data: Struct!
}

" Response object for updating an task. "
type UpdateTaskResponse @doc(category: "Task") {
	success: Boolean!
	error: UpdateTaskError!
}

" Response object for completing a task. "
type CompleteTaskResponse @doc(category: "Task") {
	success: Boolean!
	error: CompleteTaskError!
}

" Possible errors when completing an task. "
enum CompleteTaskError @doc(category: "Task") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
	ALREADY_COMPLETED
}

" Possible errors when updating an task. "
enum UpdateTaskError @doc(category: "Task") {
	NONE
	ID_REQUIRED
	TYPE_REQUIRED
	NOT_FOUND
	DATA_REQUIRED
}

" Represents an task. "
type Task @doc(category: "Task") {
	id: ID!
	type: String!
	data: Struct!
	expiresAt: Timestamp
	completedAt: Timestamp
	createdAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/team.graphql", Input: `extend type Query {
	" Get a team by id, name, or member. "
	GetTeam(input: GetTeamRequest): GetTeamResponse! @doc(category: "Team")
	" Get a list of teams based on pagination options. "
	GetTeams(input: GetTeamsRequest): GetTeamsResponse! @doc(category: "Team")
	" Get a team member by id or user ID. "
	GetTeamMember(input: TeamMemberRequest): GetTeamMemberResponse! @doc(category: "Team")
	" Search for teams based on a query string. "
	SearchTeams(input: SearchTeamsRequest): SearchTeamsResponse! @doc(category: "Team")
}

extend type Mutation {
	" Create a new team with the specified name, firstMemberId, score, data, and first member data. "
	CreateTeam(input: CreateTeamRequest): CreateTeamResponse! @doc(category: "Team")
	" Update an existing team's data and/or score. "
	UpdateTeam(input: UpdateTeamRequest): UpdateTeamResponse! @doc(category: "Team")
	" Delete a team by id, name, or member. "
	DeleteTeam(input: TeamRequest): TeamResponse! @doc(category: "Team")
	" Join a team with the specified team, user id, and data. "
	JoinTeam(input: JoinTeamRequest): JoinTeamResponse! @doc(category: "Team")
	" Leave a team by id or user id. "
	LeaveTeam(input: TeamMemberRequest): LeaveTeamResponse! @doc(category: "Team")
	" Update a team member's data. "
	UpdateTeamMember(input: UpdateTeamMemberRequest): UpdateTeamMemberResponse! @doc(category: "Team")
}

" Input object for creating a new team. "
input CreateTeamRequest @doc(category: "Team") {
	name: String!
	score: Int64
	firstMemberUserId: Uint64!
	data: Struct!
	firstMemberData: Struct!
}

" Response object for creating a team. "
type CreateTeamResponse @doc(category: "Team") {
	success: Boolean!
	id: Uint64
	error: CreateTeamError!
}

" Possible errors when creating a team. "
enum CreateTeamError @doc(category: "Team") {
	NONE
	NAME_TOO_SHORT
	NAME_TOO_LONG
	FIRST_MEMBER_USER_ID_REQUIRED
	DATA_REQUIRED
	FIRST_MEMBER_DATA_REQUIRED
	NAME_TAKEN
	FIRST_MEMBER_ALREADY_IN_A_TEAM
}

" Input object for requesting a team by id, name or member. "
input TeamRequest @doc(category: "Team") {
	id: Uint64
	name: String
	member: TeamMemberRequest
}

" Input object for getting a team with pagination options for the team members. "
input GetTeamRequest @doc(category: "Team") {
	team: TeamRequest!
	pagination: Pagination
}

" Response object for team-related operations. "
type GetTeamResponse @doc(category: "Team") {
	success: Boolean!
	team: Team
	error: GetTeamError!
}

" Possible errors when getting a team. "
enum GetTeamError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	NAME_TOO_SHORT
	NAME_TOO_LONG
	NOT_FOUND
}

" Input object for getting a list of teams and their members. "
input GetTeamsRequest @doc(category: "Team") {
	pagination: Pagination
	memberPagination: Pagination
}

" Response object for getting a list of teams and their members. "
type GetTeamsResponse @doc(category: "Team") {
	success: Boolean!
	teams: [Team]!
}

" Input object for requesting a team member by id or user id. "
input TeamMemberRequest @doc(category: "Team") {
	id: Uint64
	userId: Uint64
}

" Response object for getting a team member. "
type GetTeamMemberResponse @doc(category: "Team") {
	success: Boolean!
	member: TeamMember
	error: GetTeamMemberError!
}

" Possible errors when getting a team member. "
enum GetTeamMemberError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	NOT_FOUND
}

" Input object for searching for teams based on a query string. "
input SearchTeamsRequest @doc(category: "Team") {
	query: String!
	pagination: Pagination
	memberPagination: Pagination
}

" Response object for searching for teams. "
type SearchTeamsResponse @doc(category: "Team") {
	success: Boolean!
	teams: [Team]!
	error: SearchTeamsError!
}

" Possible errors when searching for teams. "
enum SearchTeamsError @doc(category: "Team") {
	NONE
	QUERY_TOO_SHORT
	QUERY_TOO_LONG
}

" Input object for deleting a team. "
input UpdateTeamRequest @doc(category: "Team") {
	team: TeamRequest!
	data: Struct
	score: Int64
	incrementScore: Boolean
}

" Response object for updating a team. "
type UpdateTeamResponse @doc(category: "Team") {
	success: Boolean!
	error: UpdateTeamError!
}

" Possible errors when updating a team. "
enum UpdateTeamError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	NAME_TOO_SHORT
	NAME_TOO_LONG
	NO_UPDATE_SPECIFIED
	INCREMENT_SCORE_NOT_SPECIFIED
	NOT_FOUND
}

" Response object for a team-related operation. "
type TeamResponse @doc(category: "Team") {
	success: Boolean!
	error: TeamError!
}

" Possible errors when deleting a team. "
enum TeamError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	NAME_TOO_SHORT
	NAME_TOO_LONG
	NOT_FOUND
}

" Input object for deleting a team. "
input JoinTeamRequest @doc(category: "Team") {
	team: TeamRequest!
	userId: Uint64!
	data: Struct!
}

" Response object for joining a team. "
type JoinTeamResponse @doc(category: "Team") {
	success: Boolean!
	error: JoinTeamError!
}

" Possible errors when joining a team. "
enum JoinTeamError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	NAME_TOO_SHORT
	NAME_TOO_LONG
	USER_ID_REQUIRED
	DATA_REQUIRED
	NOT_FOUND
	TEAM_FULL
	ALREADY_IN_A_TEAM
}

" Response object for leaving a team. "
type LeaveTeamResponse @doc(category: "Team") {
	success: Boolean!
	error: LeaveTeamError!
}

" Possible errors when leaving a team. "
enum LeaveTeamError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	NOT_FOUND
}

" Input object for updating a team member. "
input UpdateTeamMemberRequest @doc(category: "Team") {
	member: TeamMemberRequest!
	data: Struct!
}

" Response object for updating a team member. "
type UpdateTeamMemberResponse @doc(category: "Team") {
	success: Boolean!
	error: UpdateTeamMemberError!
}

" Possible errors when updating a team member. "
enum UpdateTeamMemberError @doc(category: "Team") {
	NONE
	NO_FIELD_SPECIFIED
	DATA_REQUIRED
	NOT_FOUND
}

" A team in the system. The ranking is based on the score highest to lowest. "
type Team @doc(category: "Team") {
	id: Uint64!
	name: String!
	score: Int64!
	ranking: Uint64!
	members: [TeamMember]!
	data: Struct!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}

" A member of a team. "
type TeamMember @doc(category: "Team") {
	id: Uint64!
	userId: Uint64!
	teamId: Uint64!
	data: Struct!
	joinedAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/tournament.graphql", Input: `extend type Query {
	" Get a tournament user by ID, or tournament, interval, and user ID. "
	GetTournamentUser(input: TournamentUserRequest): GetTournamentUserResponse! @doc(category: "Tournament")
	" Get a list of tournament users based on tournament, interval, and user ID. "
	GetTournamentUsers(input: GetTournamentUsersRequest): GetTournamentUsersResponse! @doc(category: "Tournament")
}

extend type Mutation {
	" Create a new tournament user with the specified tournament, interval, user ID, score, and data. "
	CreateTournamentUser(input: CreateTournamentUserRequest): CreateTournamentUserResponse! @doc(category: "Tournament")
	" Update an existing tournament user with the specified tournament, interval, user ID, score, data, and increment score. "
	UpdateTournamentUser(input: UpdateTournamentUserRequest): UpdateTournamentUserResponse! @doc(category: "Tournament")
	" Delete a tournament user by ID, or tournament, interval, and user ID. "
	DeleteTournamentUser(input: TournamentUserRequest): TournamentUserResponse! @doc(category: "Tournament")
}

" Input object for creating a new tournament user. "
input CreateTournamentUserRequest @doc(category: "Tournament") {
	tournament: String!
	interval: TournamentInterval!
	userId: Uint64!
	score: Int64
	data: Struct!
}

" Response object for creating a tournament user. "
type CreateTournamentUserResponse @doc(category: "Tournament") {
	success: Boolean!
	id: Uint64
	error: CreateTournamentUserError!
}

" Possible errors when creating a tournament user. "
enum CreateTournamentUserError @doc(category: "Tournament") {
	NONE
	TOURNAMENT_NAME_TOO_SHORT
	TOURNAMENT_NAME_TOO_LONG
	USER_ID_REQUIRED
	DATA_REQUIRED
	ALREADY_EXISTS
}

" Different intervals for tournaments. The tournament interval is used to determine how often a tournament is reset."
enum TournamentInterval @doc(category: "Tournament") {
	DAILY
	WEEKLY
	MONTHLY
	UNLIMITED
}

" Input object for requesting a tournament user by tournament, interval, and user ID. "
input TournamentIntervalUserId @doc(category: "Tournament") {
	tournament: String!
	interval: TournamentInterval!
	userId: Uint64!
}

" Input object for requesting a tournament user by ID, or tournament, interval, and user ID. "
input TournamentUserRequest @doc(category: "Tournament") {
	id: Uint64
	tournamentIntervalUserId: TournamentIntervalUserId
}

" Response object for getting a tournament user. "
type GetTournamentUserResponse @doc(category: "Tournament") {
	success: Boolean!
	tournamentUser: TournamentUser
	error: GetTournamentUserError!
}

" Possible errors when getting a tournament user. "
enum GetTournamentUserError @doc(category: "Tournament") {
	NONE
	ID_OR_TOURNAMENT_INTERVAL_USER_ID_REQUIRED
	TOURNAMENT_NAME_TOO_SHORT
	TOURNAMENT_NAME_TOO_LONG
	USER_ID_REQUIRED
	NOT_FOUND
}

" Response object for requesting a tournament user without returning object. "
type TournamentUserResponse @doc(category: "Tournament") {
	success: Boolean!
	error: TournamentUserError!
}

" Possible errors when requesting a tournament user without returning object. "
enum TournamentUserError @doc(category: "Tournament") {
	NONE
	ID_OR_TOURNAMENT_INTERVAL_USER_ID_REQUIRED
	TOURNAMENT_NAME_TOO_SHORT
	TOURNAMENT_NAME_TOO_LONG
	USER_ID_REQUIRED
	NOT_FOUND
}

" Input object for requesting a list of tournament users based on tournament, interval, and user ID. "
input GetTournamentUsersRequest @doc(category: "Tournament") {
	tournament: String
	interval: TournamentInterval!
	userId: Uint64
	pagination: Pagination
}

" Response object for getting a list of tournament users. "
type GetTournamentUsersResponse @doc(category: "Tournament") {
	success: Boolean!
	tournamentUsers: [TournamentUser]!
	error: GetTournamentUsersError!
}

" Possible errors when getting a list of tournament users. "
enum GetTournamentUsersError @doc(category: "Tournament") {
	NONE
	TOURNAMENT_NAME_TOO_SHORT
	TOURNAMENT_NAME_TOO_LONG
}

" Input object for updating a tournament user. Increment score flag is used to determine if the score should be incremented by the specified score. "
input UpdateTournamentUserRequest @doc(category: "Tournament") {
	tournament: TournamentUserRequest!
	data: Struct
	score: Int64
	incrementScore: Boolean
}

" Response object for updating a tournament user. "
type UpdateTournamentUserResponse @doc(category: "Tournament") {
	success: Boolean!
	error: UpdateTournamentUserError!
}

" Possible errors when updating a tournament user. "
enum UpdateTournamentUserError @doc(category: "Tournament") {
	NONE
	ID_OR_TOURNAMENT_INTERVAL_USER_ID_REQUIRED
	TOURNAMENT_NAME_TOO_SHORT
	TOURNAMENT_NAME_TOO_LONG
	USER_ID_REQUIRED
	NOT_FOUND
	NO_UPDATE_SPECIFIED
	INCREMENT_SCORE_NOT_SPECIFIED
}

" Type representing a tournament user. Tournaments are created by creating a the first tournament user with a specific tournament, interval, and user ID. "
type TournamentUser @doc(category: "Tournament") {
	id: Uint64!
	tournament: String!
	userId: Uint64!
	interval: TournamentInterval!
	score: Int64!
	ranking: Uint64!
	data: Struct!
	tournamentStartedAt: Timestamp!
	createdAt: Timestamp!
	updatedAt: Timestamp!
}
`, BuiltIn: false},
	{Name: "../../api/types.graphql", Input: `" A directive to categorize sections of the API documentation. "
directive @doc(category: String) on FIELD_DEFINITION | OBJECT | INPUT_OBJECT | ENUM | SCALAR

" A directive to add examples to fields, arguments, input fields, and enum values. "
directive @example(value: String) on OBJECT | INPUT_OBJECT | INTERFACE | FIELD_DEFINITION | ARGUMENT_DEFINITION | SCALAR

" A struct type defines a JSON object. "
scalar Struct @doc(category: "Common")

" A 32-bit unsigned integer. "
scalar Uint32 @doc(category: "Common")

" A 64-bit unsigned integer. "
scalar Uint64 @doc(category: "Common")

" A 64-bit signed integer. "
scalar Int64 @doc(category: "Common")

" A string representing a timestamp in RFC3339 (nano) format. "
scalar Timestamp @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339") @doc(category: "Common") @example(value: "2023-10-01T12:00:00Z")

" The root query type. "
type Query

" The root mutation type."
type Mutation

" Input object for pagination. The max field is the maximum number of items to return, and the page field is the page number to return. "
input Pagination @doc(category: "Common") {
	max: Uint32
	page: Uint64
}
`, BuiltIn: false},
	{Name: "../../api/webhook.graphql", Input: `extend type Mutation {
	" Send a webhook using the api as a proxy. "
	Webhook(input: WebhookRequest): WebhookResponse! @doc(category: "Webhook")
}

" Input object for sending a webhook. "
input WebhookRequest @doc(category: "Webhook") {
	uri: String!
	method: String!
	headers: Struct!
	body: Struct!
}

" Response object for sending a webhook. "
type WebhookResponse @doc(category: "Webhook") {
	status: Uint32!
	headers: Struct!
	body: Struct!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_doc_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_doc_argsCategory(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["category"] = arg0
	return args, nil
}
func (ec *executionContext) dir_doc_argsCategory(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["category"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
	if tmp, ok := rawArgs["category"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) dir_example_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_example_argsValue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["value"] = arg0
	return args, nil
}
func (ec *executionContext) dir_example_argsValue(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["value"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
	if tmp, ok := rawArgs["value"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_AddEventResult_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_AddEventResult_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_AddEventResult_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.AddEventResultRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.AddEventResultRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOAddEventResultRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐAddEventResultRequest(ctx, tmp)
	}

	var zeroVal *api.AddEventResultRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CompleteTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CompleteTask_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CompleteTask_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TaskRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TaskRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTaskRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTaskRequest(ctx, tmp)
	}

	var zeroVal *api.TaskRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateArena_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateArena_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateArena_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateArenaRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateArenaRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateArenaRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateArenaRequest(ctx, tmp)
	}

	var zeroVal *api.CreateArenaRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateEventRound_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateEventRound_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateEventRound_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateEventRoundRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateEventRoundRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateEventRoundRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRoundRequest(ctx, tmp)
	}

	var zeroVal *api.CreateEventRoundRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateEvent_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateEvent_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateEventRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateEventRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRequest(ctx, tmp)
	}

	var zeroVal *api.CreateEventRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateItem_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateItem_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateItem_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateItemRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateItemRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateItemRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateItemRequest(ctx, tmp)
	}

	var zeroVal *api.CreateItemRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateMatchmakingTicket_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateMatchmakingTicket_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateMatchmakingTicket_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateMatchmakingTicketRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateMatchmakingTicketRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateMatchmakingTicketRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateMatchmakingTicketRequest(ctx, tmp)
	}

	var zeroVal *api.CreateMatchmakingTicketRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateMatchmakingUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateMatchmakingUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateMatchmakingUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateMatchmakingUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateMatchmakingUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateMatchmakingUserRequest(ctx, tmp)
	}

	var zeroVal *api.CreateMatchmakingUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateRecord_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateRecord_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateRecord_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateRecordRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateRecordRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateRecordRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateRecordRequest(ctx, tmp)
	}

	var zeroVal *api.CreateRecordRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateTask_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateTask_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateTaskRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateTaskRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateTaskRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTaskRequest(ctx, tmp)
	}

	var zeroVal *api.CreateTaskRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateTeamRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateTeamRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTeamRequest(ctx, tmp)
	}

	var zeroVal *api.CreateTeamRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_CreateTournamentUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_CreateTournamentUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_CreateTournamentUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.CreateTournamentUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.CreateTournamentUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOCreateTournamentUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTournamentUserRequest(ctx, tmp)
	}

	var zeroVal *api.CreateTournamentUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteEventUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteEventUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteEventUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.EventUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.EventUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOEventUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUserRequest(ctx, tmp)
	}

	var zeroVal *api.EventUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteEvent_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteEvent_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.EventRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.EventRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRequest(ctx, tmp)
	}

	var zeroVal *api.EventRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteItem_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteItem_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteItem_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.ItemRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.ItemRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOItemRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItemRequest(ctx, tmp)
	}

	var zeroVal *api.ItemRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteMatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteMatch_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteMatch_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.MatchRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.MatchRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchRequest(ctx, tmp)
	}

	var zeroVal *api.MatchRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteMatchmakingTicket_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteMatchmakingTicket_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteMatchmakingTicket_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.MatchmakingTicketRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.MatchmakingTicketRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOMatchmakingTicketRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicketRequest(ctx, tmp)
	}

	var zeroVal *api.MatchmakingTicketRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteMatchmakingUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteMatchmakingUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteMatchmakingUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.MatchmakingUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.MatchmakingUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUserRequest(ctx, tmp)
	}

	var zeroVal *api.MatchmakingUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteRecord_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteRecord_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteRecord_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.RecordRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.RecordRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalORecordRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRecordRequest(ctx, tmp)
	}

	var zeroVal *api.RecordRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteTask_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteTask_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TaskRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TaskRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTaskRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTaskRequest(ctx, tmp)
	}

	var zeroVal *api.TaskRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TeamRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TeamRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamRequest(ctx, tmp)
	}

	var zeroVal *api.TeamRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_DeleteTournamentUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_DeleteTournamentUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_DeleteTournamentUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TournamentUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TournamentUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTournamentUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUserRequest(ctx, tmp)
	}

	var zeroVal *api.TournamentUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_EndMatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_EndMatch_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_EndMatch_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.EndMatchRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.EndMatchRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOEndMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEndMatchRequest(ctx, tmp)
	}

	var zeroVal *api.EndMatchRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_JoinTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_JoinTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_JoinTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.JoinTeamRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.JoinTeamRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOJoinTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐJoinTeamRequest(ctx, tmp)
	}

	var zeroVal *api.JoinTeamRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_LeaveTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_LeaveTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_LeaveTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TeamMemberRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TeamMemberRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTeamMemberRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamMemberRequest(ctx, tmp)
	}

	var zeroVal *api.TeamMemberRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_RemoveEventResult_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_RemoveEventResult_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_RemoveEventResult_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.EventRoundUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.EventRoundUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOEventRoundUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRoundUserRequest(ctx, tmp)
	}

	var zeroVal *api.EventRoundUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_SetMatchPrivateServer_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_SetMatchPrivateServer_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_SetMatchPrivateServer_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.SetMatchPrivateServerRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.SetMatchPrivateServerRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOSetMatchPrivateServerRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐSetMatchPrivateServerRequest(ctx, tmp)
	}

	var zeroVal *api.SetMatchPrivateServerRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_StartMatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_StartMatch_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_StartMatch_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.StartMatchRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.StartMatchRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOStartMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐStartMatchRequest(ctx, tmp)
	}

	var zeroVal *api.StartMatchRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateArena_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateArena_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateArena_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateArenaRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateArenaRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateArenaRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateArenaRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateArenaRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateEventRound_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateEventRound_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateEventRound_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateEventRoundRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateEventRoundRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateEventRoundRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventRoundRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateEventRoundRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateEventUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateEventUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateEventUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateEventUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateEventUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateEventUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventUserRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateEventUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateEvent_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateEvent_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateEventRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateEventRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateEventRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateItem_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateItem_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateItem_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateItemRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateItemRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateItemRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateItemRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateItemRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateMatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateMatch_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateMatch_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateMatchRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateMatchRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateMatchRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateMatchmakingTicket_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateMatchmakingTicket_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateMatchmakingTicket_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateMatchmakingTicketRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateMatchmakingTicketRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateMatchmakingTicketRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchmakingTicketRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateMatchmakingTicketRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateMatchmakingUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateMatchmakingUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateMatchmakingUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateMatchmakingUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateMatchmakingUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchmakingUserRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateMatchmakingUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateRecord_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateRecord_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateRecord_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateRecordRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateRecordRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateRecordRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateRecordRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateRecordRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateTask_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateTask_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateTaskRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateTaskRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateTaskRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTaskRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateTaskRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateTeamMember_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateTeamMember_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateTeamMember_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateTeamMemberRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateTeamMemberRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateTeamMemberRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTeamMemberRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateTeamMemberRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateTeamRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateTeamRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTeamRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateTeamRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_UpdateTournamentUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_UpdateTournamentUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_UpdateTournamentUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.UpdateTournamentUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.UpdateTournamentUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOUpdateTournamentUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTournamentUserRequest(ctx, tmp)
	}

	var zeroVal *api.UpdateTournamentUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_Webhook_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_Webhook_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_Webhook_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.WebhookRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.WebhookRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOWebhookRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐWebhookRequest(ctx, tmp)
	}

	var zeroVal *api.WebhookRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetArena_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetArena_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetArena_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.ArenaRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.ArenaRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOArenaRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArenaRequest(ctx, tmp)
	}

	var zeroVal *api.ArenaRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetArenas_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetArenas_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetArenas_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.Pagination, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.Pagination
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, tmp)
	}

	var zeroVal *api.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetEventRound_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetEventRound_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetEventRound_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetEventRoundRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetEventRoundRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetEventRoundRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventRoundRequest(ctx, tmp)
	}

	var zeroVal *api.GetEventRoundRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetEventUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetEventUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetEventUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetEventUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetEventUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetEventUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventUserRequest(ctx, tmp)
	}

	var zeroVal *api.GetEventUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetEvent_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetEvent_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetEventRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetEventRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventRequest(ctx, tmp)
	}

	var zeroVal *api.GetEventRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetItem_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetItem_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetItem_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.ItemRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.ItemRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOItemRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItemRequest(ctx, tmp)
	}

	var zeroVal *api.ItemRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetItems_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetItems_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetItems_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetItemsRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetItemsRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetItemsRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetItemsRequest(ctx, tmp)
	}

	var zeroVal *api.GetItemsRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetMatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetMatch_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetMatch_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetMatchRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetMatchRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchRequest(ctx, tmp)
	}

	var zeroVal *api.GetMatchRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetMatches_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetMatches_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetMatches_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetMatchesRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetMatchesRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetMatchesRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchesRequest(ctx, tmp)
	}

	var zeroVal *api.GetMatchesRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetMatchmakingTicket_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetMatchmakingTicket_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetMatchmakingTicket_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetMatchmakingTicketRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetMatchmakingTicketRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetMatchmakingTicketRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingTicketRequest(ctx, tmp)
	}

	var zeroVal *api.GetMatchmakingTicketRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetMatchmakingTickets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetMatchmakingTickets_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetMatchmakingTickets_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetMatchmakingTicketsRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetMatchmakingTicketsRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetMatchmakingTicketsRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingTicketsRequest(ctx, tmp)
	}

	var zeroVal *api.GetMatchmakingTicketsRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetMatchmakingUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetMatchmakingUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetMatchmakingUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.MatchmakingUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.MatchmakingUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUserRequest(ctx, tmp)
	}

	var zeroVal *api.MatchmakingUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetMatchmakingUsers_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetMatchmakingUsers_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetMatchmakingUsers_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.Pagination, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.Pagination
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, tmp)
	}

	var zeroVal *api.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetRecord_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetRecord_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetRecord_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.RecordRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.RecordRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalORecordRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRecordRequest(ctx, tmp)
	}

	var zeroVal *api.RecordRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetRecords_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetRecords_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetRecords_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetRecordsRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetRecordsRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetRecordsRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetRecordsRequest(ctx, tmp)
	}

	var zeroVal *api.GetRecordsRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTask_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTask_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TaskRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TaskRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTaskRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTaskRequest(ctx, tmp)
	}

	var zeroVal *api.TaskRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTasks_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTasks_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetTasksRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetTasksRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetTasksRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTasksRequest(ctx, tmp)
	}

	var zeroVal *api.GetTasksRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTeamMember_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTeamMember_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTeamMember_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TeamMemberRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TeamMemberRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTeamMemberRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamMemberRequest(ctx, tmp)
	}

	var zeroVal *api.TeamMemberRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTeam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTeam_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTeam_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetTeamRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetTeamRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamRequest(ctx, tmp)
	}

	var zeroVal *api.GetTeamRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTeams_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTeams_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTeams_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetTeamsRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetTeamsRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetTeamsRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamsRequest(ctx, tmp)
	}

	var zeroVal *api.GetTeamsRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTournamentUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTournamentUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTournamentUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.TournamentUserRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.TournamentUserRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOTournamentUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUserRequest(ctx, tmp)
	}

	var zeroVal *api.TournamentUserRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_GetTournamentUsers_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_GetTournamentUsers_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_GetTournamentUsers_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.GetTournamentUsersRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.GetTournamentUsersRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGetTournamentUsersRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTournamentUsersRequest(ctx, tmp)
	}

	var zeroVal *api.GetTournamentUsersRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query_SearchTeams_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_SearchTeams_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_SearchTeams_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*api.SearchTeamsRequest, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal *api.SearchTeamsRequest
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOSearchTeamsRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐSearchTeamsRequest(ctx, tmp)
	}

	var zeroVal *api.SearchTeamsRequest
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AddEventResultResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.AddEventResultResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddEventResultResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddEventResultResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddEventResultResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AddEventResultResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.AddEventResultResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddEventResultResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.AddEventResultResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.AddEventResultError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.AddEventResultError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.AddEventResultError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.AddEventResultError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.AddEventResultError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.AddEventResultError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AddEventResultError)
	fc.Result = res
	return ec.marshalNAddEventResultError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐAddEventResultError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddEventResultResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddEventResultResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AddEventResultError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_id(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_name(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_minPlayers(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_minPlayers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MinPlayers, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint32); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_minPlayers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_maxPlayersPerTicket(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_maxPlayersPerTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MaxPlayersPerTicket, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint32); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_maxPlayersPerTicket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_maxPlayers(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_maxPlayers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MaxPlayers, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint32); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_maxPlayers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_data(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Arena_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Arena) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Arena_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Arena_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Arena",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompleteTaskResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CompleteTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompleteTaskResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompleteTaskResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompleteTaskResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompleteTaskResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CompleteTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompleteTaskResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CompleteTaskResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal model.CompleteTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CompleteTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal model.CompleteTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CompleteTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CompleteTaskError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CompleteTaskError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CompleteTaskError)
	fc.Result = res
	return ec.marshalNCompleteTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCompleteTaskError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompleteTaskResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompleteTaskResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CompleteTaskError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateArenaResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateArenaResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateArenaResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateArenaResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateArenaResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateArenaResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateArenaResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateArenaResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateArenaResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateArenaResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateArenaResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.CreateArenaError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateArenaError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.CreateArenaError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateArenaError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateArenaError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateArenaError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateArenaError)
	fc.Result = res
	return ec.marshalNCreateArenaError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateArenaError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateArenaResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateArenaResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateArenaError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateEventResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateEventResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateEventResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateEventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateEventResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateEventResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateEventResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateEventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateEventResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateEventResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateEventResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.CreateEventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateEventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.CreateEventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateEventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateEventError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateEventError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateEventError)
	fc.Result = res
	return ec.marshalNCreateEventError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateEventError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateEventResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateEventResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateEventError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateEventRoundResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateEventRoundResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateEventRoundResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateEventRoundResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateEventRoundResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateEventRoundResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateEventRoundResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateEventRoundResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateEventRoundResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateEventRoundResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateEventRoundResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.CreateEventRoundError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateEventRoundError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.CreateEventRoundError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateEventRoundError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateEventRoundError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateEventRoundError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateEventRoundError)
	fc.Result = res
	return ec.marshalNCreateEventRoundError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateEventRoundError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateEventRoundResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateEventRoundResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateEventRoundError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateItemResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateItemResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateItemResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateItemResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateItemResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateItemResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateItemResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal model.CreateItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal model.CreateItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateItemError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateItemError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateItemError)
	fc.Result = res
	return ec.marshalNCreateItemError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateItemError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateItemResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateItemResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateItemError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMatchmakingTicketResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMatchmakingTicketResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMatchmakingTicketResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMatchmakingTicketResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMatchmakingTicketResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMatchmakingTicketResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMatchmakingTicketResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMatchmakingTicketResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateMatchmakingTicketResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.CreateMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.CreateMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateMatchmakingTicketError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateMatchmakingTicketError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateMatchmakingTicketError)
	fc.Result = res
	return ec.marshalNCreateMatchmakingTicketError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateMatchmakingTicketError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMatchmakingTicketResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateMatchmakingTicketError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMatchmakingUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMatchmakingUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMatchmakingUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMatchmakingUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMatchmakingUserResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMatchmakingUserResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMatchmakingUserResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMatchmakingUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMatchmakingUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMatchmakingUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateMatchmakingUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.CreateMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.CreateMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateMatchmakingUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateMatchmakingUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateMatchmakingUserError)
	fc.Result = res
	return ec.marshalNCreateMatchmakingUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateMatchmakingUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMatchmakingUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMatchmakingUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateMatchmakingUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateRecordResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateRecordResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateRecordResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateRecordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateRecordResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateRecordResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateRecordResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateRecordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateRecordResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateRecordResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateRecordResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal model.CreateRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal model.CreateRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateRecordError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateRecordError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateRecordError)
	fc.Result = res
	return ec.marshalNCreateRecordError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateRecordError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateRecordResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateRecordResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateRecordError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTaskResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTaskResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTaskResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTaskResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTaskResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTaskResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateTaskResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal model.CreateTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal model.CreateTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateTaskError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateTaskError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateTaskError)
	fc.Result = res
	return ec.marshalNCreateTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateTaskError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTaskResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTaskResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateTaskError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTeamResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTeamResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTeamResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTeamResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTeamResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTeamResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTeamResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTeamResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateTeamResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.CreateTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.CreateTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateTeamError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateTeamError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateTeamError)
	fc.Result = res
	return ec.marshalNCreateTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateTeamError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTeamResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTeamResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateTeamError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTournamentUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.CreateTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTournamentUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTournamentUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTournamentUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTournamentUserResponse_id(ctx context.Context, field graphql.CollectedField, obj *api.CreateTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTournamentUserResponse_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTournamentUserResponse_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTournamentUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTournamentUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.CreateTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTournamentUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.CreateTournamentUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal model.CreateTournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateTournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal model.CreateTournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.CreateTournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateTournamentUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.CreateTournamentUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreateTournamentUserError)
	fc.Result = res
	return ec.marshalNCreateTournamentUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateTournamentUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTournamentUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTournamentUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateTournamentUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteMatchResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.DeleteMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteMatchResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteMatchResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteMatchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteMatchResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.DeleteMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteMatchResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.DeleteMatchResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.DeleteMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.DeleteMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DeleteMatchError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.DeleteMatchError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DeleteMatchError)
	fc.Result = res
	return ec.marshalNDeleteMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐDeleteMatchError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteMatchResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteMatchResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeleteMatchError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteMatchmakingTicketResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.DeleteMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteMatchmakingTicketResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteMatchmakingTicketResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteMatchmakingTicketResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.DeleteMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteMatchmakingTicketResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.DeleteMatchmakingTicketResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.DeleteMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.DeleteMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DeleteMatchmakingTicketError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.DeleteMatchmakingTicketError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DeleteMatchmakingTicketError)
	fc.Result = res
	return ec.marshalNDeleteMatchmakingTicketError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐDeleteMatchmakingTicketError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteMatchmakingTicketResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeleteMatchmakingTicketError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteMatchmakingUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.DeleteMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteMatchmakingUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteMatchmakingUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteMatchmakingUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteMatchmakingUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.DeleteMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteMatchmakingUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.DeleteMatchmakingUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.DeleteMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.DeleteMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DeleteMatchmakingUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.DeleteMatchmakingUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DeleteMatchmakingUserError)
	fc.Result = res
	return ec.marshalNDeleteMatchmakingUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐDeleteMatchmakingUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteMatchmakingUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteMatchmakingUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeleteMatchmakingUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteRecordResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.DeleteRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteRecordResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteRecordResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteRecordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteRecordResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.DeleteRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteRecordResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.DeleteRecordResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal model.DeleteRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal model.DeleteRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.DeleteRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DeleteRecordError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.DeleteRecordError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DeleteRecordError)
	fc.Result = res
	return ec.marshalNDeleteRecordError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐDeleteRecordError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteRecordResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteRecordResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeleteRecordError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EndMatchResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.EndMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EndMatchResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EndMatchResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EndMatchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EndMatchResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.EndMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EndMatchResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.EndMatchResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.EndMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.EndMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.EndMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.EndMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.EndMatchError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.EndMatchError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EndMatchError)
	fc.Result = res
	return ec.marshalNEndMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐEndMatchError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EndMatchResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EndMatchResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EndMatchError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_id(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_name(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_currentRoundId(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_currentRoundId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CurrentRoundId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_currentRoundId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_currentRoundName(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_currentRoundName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CurrentRoundName, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_currentRoundName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_data(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_rounds(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_rounds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Rounds, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventRound
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventRound
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventRound
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventRound
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.EventRound); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.EventRound`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.EventRound)
	fc.Result = res
	return ec.marshalNEventRound2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRound(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_rounds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventRound_id(ctx, field)
			case "eventId":
				return ec.fieldContext_EventRound_eventId(ctx, field)
			case "name":
				return ec.fieldContext_EventRound_name(ctx, field)
			case "scoring":
				return ec.fieldContext_EventRound_scoring(ctx, field)
			case "data":
				return ec.fieldContext_EventRound_data(ctx, field)
			case "endedAt":
				return ec.fieldContext_EventRound_endedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventRound_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventRound_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventRound", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_startedAt(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.StartedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_startedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.EventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.EventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.EventResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.EventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.EventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.EventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.EventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.EventError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.EventError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventError)
	fc.Result = res
	return ec.marshalNEventError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐEventError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_id(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_eventId(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_eventId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.EventId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_eventId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_name(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_scoring(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_scoring(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Scoring, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal []uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal []uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]uint64)
	fc.Result = res
	return ec.marshalNUint642ᚕuint64ᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_scoring(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_data(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_endedAt(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_endedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.EndedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_endedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRound_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.EventRound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRound_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRound_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_id(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_eventUserId(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_eventUserId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.EventUserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_eventUserId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_clientUserId(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_clientUserId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ClientUserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_clientUserId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_eventRoundId(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_eventRoundId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.EventRoundId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_eventRoundId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_result(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_result(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Result, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_result(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_ranking(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_ranking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Ranking, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_ranking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_data(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventRoundUser_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.EventRoundUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventRoundUser_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventRoundUser_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventRoundUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_id(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_eventId(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_eventId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.EventId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_eventId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_clientUserId(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_clientUserId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ClientUserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_clientUserId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_score(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_score(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Score, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_score(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_ranking(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_ranking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Ranking, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_ranking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_data(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUser_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.EventUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUser_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUser_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.EventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.EventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.EventUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.EventUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.EventUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.EventUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.EventUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.EventUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.EventUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventUserError)
	fc.Result = res
	return ec.marshalNEventUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐEventUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetArenaResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetArenaResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetArenaResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetArenaResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetArenaResponse_arena(ctx context.Context, field graphql.CollectedField, obj *api.GetArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetArenaResponse_arena(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Arena, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Arena); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Arena`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Arena)
	fc.Result = res
	return ec.marshalOArena2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArena(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetArenaResponse_arena(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetArenaResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Arena_id(ctx, field)
			case "name":
				return ec.fieldContext_Arena_name(ctx, field)
			case "minPlayers":
				return ec.fieldContext_Arena_minPlayers(ctx, field)
			case "maxPlayersPerTicket":
				return ec.fieldContext_Arena_maxPlayersPerTicket(ctx, field)
			case "maxPlayers":
				return ec.fieldContext_Arena_maxPlayers(ctx, field)
			case "data":
				return ec.fieldContext_Arena_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Arena_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Arena_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Arena", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetArenaResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetArenaResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetArenaResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetArenaError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetArenaError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetArenaError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetArenaError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetArenaError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetArenaError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetArenaError)
	fc.Result = res
	return ec.marshalNGetArenaError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetArenaError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetArenaResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetArenaResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetArenaError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetArenasResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetArenasResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetArenasResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetArenasResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetArenasResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetArenasResponse_arenas(ctx context.Context, field graphql.CollectedField, obj *api.GetArenasResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetArenasResponse_arenas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Arenas, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Arena); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Arena`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*api.Arena)
	fc.Result = res
	return ec.marshalOArena2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArena(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetArenasResponse_arenas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetArenasResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Arena_id(ctx, field)
			case "name":
				return ec.fieldContext_Arena_name(ctx, field)
			case "minPlayers":
				return ec.fieldContext_Arena_minPlayers(ctx, field)
			case "maxPlayersPerTicket":
				return ec.fieldContext_Arena_maxPlayersPerTicket(ctx, field)
			case "maxPlayers":
				return ec.fieldContext_Arena_maxPlayers(ctx, field)
			case "data":
				return ec.fieldContext_Arena_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Arena_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Arena_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Arena", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventResponse_event(ctx context.Context, field graphql.CollectedField, obj *api.GetEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventResponse_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Event, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.Event
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Event
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.Event
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Event
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Event); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Event`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Event)
	fc.Result = res
	return ec.marshalOEvent2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventResponse_event(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "currentRoundId":
				return ec.fieldContext_Event_currentRoundId(ctx, field)
			case "currentRoundName":
				return ec.fieldContext_Event_currentRoundName(ctx, field)
			case "data":
				return ec.fieldContext_Event_data(ctx, field)
			case "rounds":
				return ec.fieldContext_Event_rounds(ctx, field)
			case "startedAt":
				return ec.fieldContext_Event_startedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventResponse_leaderboard(ctx context.Context, field graphql.CollectedField, obj *api.GetEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventResponse_leaderboard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Leaderboard, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.EventUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.EventUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.EventUser)
	fc.Result = res
	return ec.marshalNEventUser2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventResponse_leaderboard(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventUser_id(ctx, field)
			case "eventId":
				return ec.fieldContext_EventUser_eventId(ctx, field)
			case "clientUserId":
				return ec.fieldContext_EventUser_clientUserId(ctx, field)
			case "score":
				return ec.fieldContext_EventUser_score(ctx, field)
			case "ranking":
				return ec.fieldContext_EventUser_ranking(ctx, field)
			case "data":
				return ec.fieldContext_EventUser_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetEventResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.GetEventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetEventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.GetEventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetEventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetEventError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetEventError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetEventError)
	fc.Result = res
	return ec.marshalNGetEventError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetEventError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetEventError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventRoundResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventRoundResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventRoundResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventRoundResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventRoundResponse_round(ctx context.Context, field graphql.CollectedField, obj *api.GetEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventRoundResponse_round(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Round, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventRound
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventRound
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventRound
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventRound
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.EventRound); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRound`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.EventRound)
	fc.Result = res
	return ec.marshalOEventRound2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRound(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventRoundResponse_round(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventRoundResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventRound_id(ctx, field)
			case "eventId":
				return ec.fieldContext_EventRound_eventId(ctx, field)
			case "name":
				return ec.fieldContext_EventRound_name(ctx, field)
			case "scoring":
				return ec.fieldContext_EventRound_scoring(ctx, field)
			case "data":
				return ec.fieldContext_EventRound_data(ctx, field)
			case "endedAt":
				return ec.fieldContext_EventRound_endedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventRound_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventRound_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventRound", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventRoundResponse_results(ctx context.Context, field graphql.CollectedField, obj *api.GetEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventRoundResponse_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Results, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.EventRoundUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.EventRoundUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.EventRoundUser)
	fc.Result = res
	return ec.marshalNEventRoundUser2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRoundUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventRoundResponse_results(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventRoundResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventRoundUser_id(ctx, field)
			case "eventUserId":
				return ec.fieldContext_EventRoundUser_eventUserId(ctx, field)
			case "clientUserId":
				return ec.fieldContext_EventRoundUser_clientUserId(ctx, field)
			case "eventRoundId":
				return ec.fieldContext_EventRoundUser_eventRoundId(ctx, field)
			case "result":
				return ec.fieldContext_EventRoundUser_result(ctx, field)
			case "ranking":
				return ec.fieldContext_EventRoundUser_ranking(ctx, field)
			case "data":
				return ec.fieldContext_EventRoundUser_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventRoundUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventRoundUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventRoundUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventRoundResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventRoundResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetEventRoundResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.GetEventRoundError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetEventRoundError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.GetEventRoundError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetEventRoundError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetEventRoundError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetEventRoundError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetEventRoundError)
	fc.Result = res
	return ec.marshalNGetEventRoundError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetEventRoundError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventRoundResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventRoundResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetEventRoundError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetEventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventUserResponse_user(ctx context.Context, field graphql.CollectedField, obj *api.GetEventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventUserResponse_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.User, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.EventUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.EventUser)
	fc.Result = res
	return ec.marshalOEventUser2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventUserResponse_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventUser_id(ctx, field)
			case "eventId":
				return ec.fieldContext_EventUser_eventId(ctx, field)
			case "clientUserId":
				return ec.fieldContext_EventUser_clientUserId(ctx, field)
			case "score":
				return ec.fieldContext_EventUser_score(ctx, field)
			case "ranking":
				return ec.fieldContext_EventUser_ranking(ctx, field)
			case "data":
				return ec.fieldContext_EventUser_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventUserResponse_results(ctx context.Context, field graphql.CollectedField, obj *api.GetEventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventUserResponse_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Results, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.EventRoundUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.EventRoundUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.EventRoundUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.EventRoundUser)
	fc.Result = res
	return ec.marshalNEventRoundUser2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRoundUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventUserResponse_results(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventRoundUser_id(ctx, field)
			case "eventUserId":
				return ec.fieldContext_EventRoundUser_eventUserId(ctx, field)
			case "clientUserId":
				return ec.fieldContext_EventRoundUser_clientUserId(ctx, field)
			case "eventRoundId":
				return ec.fieldContext_EventRoundUser_eventRoundId(ctx, field)
			case "result":
				return ec.fieldContext_EventRoundUser_result(ctx, field)
			case "ranking":
				return ec.fieldContext_EventRoundUser_ranking(ctx, field)
			case "data":
				return ec.fieldContext_EventRoundUser_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventRoundUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventRoundUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventRoundUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetEventUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetEventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetEventUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetEventUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.GetEventUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetEventUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.GetEventUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetEventUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetEventUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetEventUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetEventUserError)
	fc.Result = res
	return ec.marshalNGetEventUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetEventUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetEventUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetEventUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetEventUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetItemResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetItemResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetItemResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetItemResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetItemResponse_item(ctx context.Context, field graphql.CollectedField, obj *api.GetItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetItemResponse_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Item, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *api.Item
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Item
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *api.Item
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Item
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Item); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Item`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetItemResponse_item(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetItemResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "data":
				return ec.fieldContext_Item_data(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Item_expiresAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetItemResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetItemResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetItemResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal model.GetItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal model.GetItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetItemError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetItemError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetItemError)
	fc.Result = res
	return ec.marshalNGetItemError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetItemError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetItemResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetItemResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetItemError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetItemsResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetItemsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetItemsResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetItemsResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetItemsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetItemsResponse_items(ctx context.Context, field graphql.CollectedField, obj *api.GetItemsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetItemsResponse_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Items, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal []*api.Item
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Item
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal []*api.Item
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Item
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Item); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Item`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.Item)
	fc.Result = res
	return ec.marshalNItem2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetItemsResponse_items(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetItemsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "data":
				return ec.fieldContext_Item_data(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Item_expiresAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchResponse_match(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchResponse_match(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Match, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.Match
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Match
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.Match
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Match
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Match); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Match`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Match)
	fc.Result = res
	return ec.marshalOMatch2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchResponse_match(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Match_id(ctx, field)
			case "arena":
				return ec.fieldContext_Match_arena(ctx, field)
			case "tickets":
				return ec.fieldContext_Match_tickets(ctx, field)
			case "privateServerId":
				return ec.fieldContext_Match_privateServerId(ctx, field)
			case "status":
				return ec.fieldContext_Match_status(ctx, field)
			case "data":
				return ec.fieldContext_Match_data(ctx, field)
			case "lockedAt":
				return ec.fieldContext_Match_lockedAt(ctx, field)
			case "startedAt":
				return ec.fieldContext_Match_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Match_endedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Match_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Match_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Match", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetMatchResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetMatchError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetMatchError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetMatchError)
	fc.Result = res
	return ec.marshalNGetMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetMatchError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetMatchError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchesResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchesResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchesResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchesResponse_matches(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchesResponse_matches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Matches, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.Match
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Match
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.Match
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Match
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Match); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Match`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*api.Match)
	fc.Result = res
	return ec.marshalOMatch2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchesResponse_matches(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Match_id(ctx, field)
			case "arena":
				return ec.fieldContext_Match_arena(ctx, field)
			case "tickets":
				return ec.fieldContext_Match_tickets(ctx, field)
			case "privateServerId":
				return ec.fieldContext_Match_privateServerId(ctx, field)
			case "status":
				return ec.fieldContext_Match_status(ctx, field)
			case "data":
				return ec.fieldContext_Match_data(ctx, field)
			case "lockedAt":
				return ec.fieldContext_Match_lockedAt(ctx, field)
			case "startedAt":
				return ec.fieldContext_Match_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Match_endedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Match_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Match_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Match", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingTicketResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingTicketResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingTicketResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingTicketResponse_matchmakingTicket(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingTicketResponse_matchmakingTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchmakingTicket, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.MatchmakingTicket
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.MatchmakingTicket
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.MatchmakingTicket
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.MatchmakingTicket
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.MatchmakingTicket); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingTicket`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.MatchmakingTicket)
	fc.Result = res
	return ec.marshalOMatchmakingTicket2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingTicketResponse_matchmakingTicket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchmakingTicket_id(ctx, field)
			case "matchmakingUsers":
				return ec.fieldContext_MatchmakingTicket_matchmakingUsers(ctx, field)
			case "arenas":
				return ec.fieldContext_MatchmakingTicket_arenas(ctx, field)
			case "matchId":
				return ec.fieldContext_MatchmakingTicket_matchId(ctx, field)
			case "status":
				return ec.fieldContext_MatchmakingTicket_status(ctx, field)
			case "data":
				return ec.fieldContext_MatchmakingTicket_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchmakingTicket_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchmakingTicket_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchmakingTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingTicketResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingTicketResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetMatchmakingTicketResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetMatchmakingTicketError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetMatchmakingTicketError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetMatchmakingTicketError)
	fc.Result = res
	return ec.marshalNGetMatchmakingTicketError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetMatchmakingTicketError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingTicketResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetMatchmakingTicketError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingTicketsResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingTicketsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingTicketsResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingTicketsResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingTicketsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingTicketsResponse_matchmakingTickets(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingTicketsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingTicketsResponse_matchmakingTickets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchmakingTickets, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.MatchmakingTicket); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.MatchmakingTicket`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*api.MatchmakingTicket)
	fc.Result = res
	return ec.marshalOMatchmakingTicket2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingTicketsResponse_matchmakingTickets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingTicketsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchmakingTicket_id(ctx, field)
			case "matchmakingUsers":
				return ec.fieldContext_MatchmakingTicket_matchmakingUsers(ctx, field)
			case "arenas":
				return ec.fieldContext_MatchmakingTicket_arenas(ctx, field)
			case "matchId":
				return ec.fieldContext_MatchmakingTicket_matchId(ctx, field)
			case "status":
				return ec.fieldContext_MatchmakingTicket_status(ctx, field)
			case "data":
				return ec.fieldContext_MatchmakingTicket_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchmakingTicket_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchmakingTicket_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchmakingTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingTicketsResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingTicketsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingTicketsResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetMatchmakingTicketsResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchmakingTicketsError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchmakingTicketsError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchmakingTicketsError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchmakingTicketsError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetMatchmakingTicketsError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetMatchmakingTicketsError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetMatchmakingTicketsError)
	fc.Result = res
	return ec.marshalNGetMatchmakingTicketsError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetMatchmakingTicketsError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingTicketsResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingTicketsResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetMatchmakingTicketsError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingUserResponse_matchmakingUser(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingUserResponse_matchmakingUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchmakingUser, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.MatchmakingUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.MatchmakingUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.MatchmakingUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.MatchmakingUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.MatchmakingUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.MatchmakingUser)
	fc.Result = res
	return ec.marshalOMatchmakingUser2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingUserResponse_matchmakingUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchmakingUser_id(ctx, field)
			case "clientUserId":
				return ec.fieldContext_MatchmakingUser_clientUserId(ctx, field)
			case "data":
				return ec.fieldContext_MatchmakingUser_data(ctx, field)
			case "elo":
				return ec.fieldContext_MatchmakingUser_elo(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchmakingUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchmakingUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchmakingUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetMatchmakingUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.GetMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetMatchmakingUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetMatchmakingUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetMatchmakingUserError)
	fc.Result = res
	return ec.marshalNGetMatchmakingUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetMatchmakingUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetMatchmakingUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingUsersResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingUsersResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingUsersResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingUsersResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingUsersResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMatchmakingUsersResponse_matchmakingUsers(ctx context.Context, field graphql.CollectedField, obj *api.GetMatchmakingUsersResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMatchmakingUsersResponse_matchmakingUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchmakingUsers, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.MatchmakingUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.MatchmakingUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*api.MatchmakingUser)
	fc.Result = res
	return ec.marshalOMatchmakingUser2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMatchmakingUsersResponse_matchmakingUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMatchmakingUsersResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchmakingUser_id(ctx, field)
			case "clientUserId":
				return ec.fieldContext_MatchmakingUser_clientUserId(ctx, field)
			case "data":
				return ec.fieldContext_MatchmakingUser_data(ctx, field)
			case "elo":
				return ec.fieldContext_MatchmakingUser_elo(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchmakingUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchmakingUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchmakingUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetRecordResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetRecordResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetRecordResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetRecordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetRecordResponse_record(ctx context.Context, field graphql.CollectedField, obj *api.GetRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetRecordResponse_record(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Record, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *api.Record
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Record
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *api.Record
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Record
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Record); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Record`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Record)
	fc.Result = res
	return ec.marshalORecord2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetRecordResponse_record(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetRecordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Record_id(ctx, field)
			case "name":
				return ec.fieldContext_Record_name(ctx, field)
			case "userId":
				return ec.fieldContext_Record_userId(ctx, field)
			case "record":
				return ec.fieldContext_Record_record(ctx, field)
			case "ranking":
				return ec.fieldContext_Record_ranking(ctx, field)
			case "data":
				return ec.fieldContext_Record_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Record_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Record_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Record", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetRecordResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetRecordResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetRecordResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal model.GetRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal model.GetRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetRecordError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetRecordError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetRecordError)
	fc.Result = res
	return ec.marshalNGetRecordError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetRecordError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetRecordResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetRecordResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetRecordError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetRecordsResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetRecordsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetRecordsResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetRecordsResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetRecordsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetRecordsResponse_records(ctx context.Context, field graphql.CollectedField, obj *api.GetRecordsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetRecordsResponse_records(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Records, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal []*api.Record
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Record
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal []*api.Record
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Record
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Record); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Record`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.Record)
	fc.Result = res
	return ec.marshalNRecord2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetRecordsResponse_records(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetRecordsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Record_id(ctx, field)
			case "name":
				return ec.fieldContext_Record_name(ctx, field)
			case "userId":
				return ec.fieldContext_Record_userId(ctx, field)
			case "record":
				return ec.fieldContext_Record_record(ctx, field)
			case "ranking":
				return ec.fieldContext_Record_ranking(ctx, field)
			case "data":
				return ec.fieldContext_Record_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Record_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Record_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Record", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetRecordsResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetRecordsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetRecordsResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetRecordsResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal model.GetRecordsError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetRecordsError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal model.GetRecordsError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetRecordsError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetRecordsError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetRecordsError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetRecordsError)
	fc.Result = res
	return ec.marshalNGetRecordsError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetRecordsError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetRecordsResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetRecordsResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetRecordsError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTaskResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTaskResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTaskResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTaskResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTaskResponse_task(ctx context.Context, field graphql.CollectedField, obj *api.GetTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTaskResponse_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Task, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.Task
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Task
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.Task
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Task
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Task); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Task`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Task)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTaskResponse_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTaskResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "type":
				return ec.fieldContext_Task_type(ctx, field)
			case "data":
				return ec.fieldContext_Task_data(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Task_expiresAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Task_completedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Task_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Task_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTaskResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTaskResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetTaskResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal model.GetTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal model.GetTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetTaskError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetTaskError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetTaskError)
	fc.Result = res
	return ec.marshalNGetTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTaskError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTaskResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTaskResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetTaskError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTasksResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTasksResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTasksResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTasksResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTasksResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTasksResponse_tasks(ctx context.Context, field graphql.CollectedField, obj *api.GetTasksResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTasksResponse_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tasks, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal []*api.Task
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Task
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal []*api.Task
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Task
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Task); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Task`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.Task)
	fc.Result = res
	return ec.marshalNTask2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTasksResponse_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTasksResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "type":
				return ec.fieldContext_Task_type(ctx, field)
			case "data":
				return ec.fieldContext_Task_data(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Task_expiresAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Task_completedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Task_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Task_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamMemberResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamMemberResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamMemberResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamMemberResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamMemberResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamMemberResponse_member(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamMemberResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamMemberResponse_member(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Member, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.TeamMember
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TeamMember
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.TeamMember
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TeamMember
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.TeamMember); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamMember`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.TeamMember)
	fc.Result = res
	return ec.marshalOTeamMember2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamMemberResponse_member(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamMemberResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamMember_id(ctx, field)
			case "userId":
				return ec.fieldContext_TeamMember_userId(ctx, field)
			case "teamId":
				return ec.fieldContext_TeamMember_teamId(ctx, field)
			case "data":
				return ec.fieldContext_TeamMember_data(ctx, field)
			case "joinedAt":
				return ec.fieldContext_TeamMember_joinedAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TeamMember_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamMemberResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamMemberResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamMemberResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetTeamMemberResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.GetTeamMemberError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTeamMemberError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.GetTeamMemberError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTeamMemberError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetTeamMemberError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetTeamMemberError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetTeamMemberError)
	fc.Result = res
	return ec.marshalNGetTeamMemberError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTeamMemberError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamMemberResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamMemberResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetTeamMemberError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamResponse_team(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamResponse_team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Team, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.Team
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Team
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.Team
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Team
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Team); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Team`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.Team)
	fc.Result = res
	return ec.marshalOTeam2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamResponse_team(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "name":
				return ec.fieldContext_Team_name(ctx, field)
			case "score":
				return ec.fieldContext_Team_score(ctx, field)
			case "ranking":
				return ec.fieldContext_Team_ranking(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "data":
				return ec.fieldContext_Team_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Team_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Team_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetTeamResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.GetTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.GetTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetTeamError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetTeamError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetTeamError)
	fc.Result = res
	return ec.marshalNGetTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTeamError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetTeamError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamsResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamsResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamsResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTeamsResponse_teams(ctx context.Context, field graphql.CollectedField, obj *api.GetTeamsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTeamsResponse_teams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Teams, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal []*api.Team
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Team
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal []*api.Team
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Team
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Team); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Team`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTeamsResponse_teams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTeamsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "name":
				return ec.fieldContext_Team_name(ctx, field)
			case "score":
				return ec.fieldContext_Team_score(ctx, field)
			case "ranking":
				return ec.fieldContext_Team_ranking(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "data":
				return ec.fieldContext_Team_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Team_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Team_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTournamentUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTournamentUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTournamentUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTournamentUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTournamentUserResponse_tournamentUser(ctx context.Context, field graphql.CollectedField, obj *api.GetTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTournamentUserResponse_tournamentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TournamentUser, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.TournamentUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TournamentUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.TournamentUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TournamentUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.TournamentUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TournamentUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*api.TournamentUser)
	fc.Result = res
	return ec.marshalOTournamentUser2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTournamentUserResponse_tournamentUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTournamentUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TournamentUser_id(ctx, field)
			case "tournament":
				return ec.fieldContext_TournamentUser_tournament(ctx, field)
			case "userId":
				return ec.fieldContext_TournamentUser_userId(ctx, field)
			case "interval":
				return ec.fieldContext_TournamentUser_interval(ctx, field)
			case "score":
				return ec.fieldContext_TournamentUser_score(ctx, field)
			case "ranking":
				return ec.fieldContext_TournamentUser_ranking(ctx, field)
			case "data":
				return ec.fieldContext_TournamentUser_data(ctx, field)
			case "tournamentStartedAt":
				return ec.fieldContext_TournamentUser_tournamentStartedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_TournamentUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TournamentUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TournamentUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTournamentUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTournamentUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetTournamentUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal model.GetTournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal model.GetTournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetTournamentUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetTournamentUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetTournamentUserError)
	fc.Result = res
	return ec.marshalNGetTournamentUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTournamentUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTournamentUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTournamentUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetTournamentUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTournamentUsersResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.GetTournamentUsersResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTournamentUsersResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTournamentUsersResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTournamentUsersResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTournamentUsersResponse_tournamentUsers(ctx context.Context, field graphql.CollectedField, obj *api.GetTournamentUsersResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTournamentUsersResponse_tournamentUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TournamentUsers, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal []*api.TournamentUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.TournamentUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal []*api.TournamentUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.TournamentUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.TournamentUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.TournamentUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.TournamentUser)
	fc.Result = res
	return ec.marshalNTournamentUser2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTournamentUsersResponse_tournamentUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTournamentUsersResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TournamentUser_id(ctx, field)
			case "tournament":
				return ec.fieldContext_TournamentUser_tournament(ctx, field)
			case "userId":
				return ec.fieldContext_TournamentUser_userId(ctx, field)
			case "interval":
				return ec.fieldContext_TournamentUser_interval(ctx, field)
			case "score":
				return ec.fieldContext_TournamentUser_score(ctx, field)
			case "ranking":
				return ec.fieldContext_TournamentUser_ranking(ctx, field)
			case "data":
				return ec.fieldContext_TournamentUser_data(ctx, field)
			case "tournamentStartedAt":
				return ec.fieldContext_TournamentUser_tournamentStartedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_TournamentUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TournamentUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TournamentUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetTournamentUsersResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.GetTournamentUsersResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetTournamentUsersResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.GetTournamentUsersResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal model.GetTournamentUsersError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTournamentUsersError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal model.GetTournamentUsersError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.GetTournamentUsersError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.GetTournamentUsersError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.GetTournamentUsersError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GetTournamentUsersError)
	fc.Result = res
	return ec.marshalNGetTournamentUsersError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTournamentUsersError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetTournamentUsersResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetTournamentUsersResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetTournamentUsersError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_id(ctx context.Context, field graphql.CollectedField, obj *api.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_type(ctx context.Context, field graphql.CollectedField, obj *api.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Type, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_data(ctx context.Context, field graphql.CollectedField, obj *api.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_expiresAt(ctx context.Context, field graphql.CollectedField, obj *api.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ExpiresAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_expiresAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.ItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.ItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.ItemResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal model.ItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.ItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal model.ItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.ItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.ItemError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.ItemError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemError)
	fc.Result = res
	return ec.marshalNItemError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐItemError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JoinTeamResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.JoinTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JoinTeamResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JoinTeamResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JoinTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JoinTeamResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.JoinTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JoinTeamResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.JoinTeamResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.JoinTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.JoinTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.JoinTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.JoinTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.JoinTeamError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.JoinTeamError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.JoinTeamError)
	fc.Result = res
	return ec.marshalNJoinTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐJoinTeamError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JoinTeamResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JoinTeamResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JoinTeamError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LeaveTeamResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.LeaveTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LeaveTeamResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LeaveTeamResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LeaveTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LeaveTeamResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.LeaveTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LeaveTeamResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.LeaveTeamResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.LeaveTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.LeaveTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.LeaveTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.LeaveTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.LeaveTeamError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.LeaveTeamError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LeaveTeamError)
	fc.Result = res
	return ec.marshalNLeaveTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐLeaveTeamError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LeaveTeamResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LeaveTeamResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LeaveTeamError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_id(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_arena(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_arena(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Arena, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.Arena); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Arena`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.Arena)
	fc.Result = res
	return ec.marshalNArena2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArena(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_arena(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Arena_id(ctx, field)
			case "name":
				return ec.fieldContext_Arena_name(ctx, field)
			case "minPlayers":
				return ec.fieldContext_Arena_minPlayers(ctx, field)
			case "maxPlayersPerTicket":
				return ec.fieldContext_Arena_maxPlayersPerTicket(ctx, field)
			case "maxPlayers":
				return ec.fieldContext_Arena_maxPlayers(ctx, field)
			case "data":
				return ec.fieldContext_Arena_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Arena_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Arena_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Arena", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_tickets(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_tickets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tickets, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingTicket
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.MatchmakingTicket); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.MatchmakingTicket`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.MatchmakingTicket)
	fc.Result = res
	return ec.marshalNMatchmakingTicket2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_tickets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchmakingTicket_id(ctx, field)
			case "matchmakingUsers":
				return ec.fieldContext_MatchmakingTicket_matchmakingUsers(ctx, field)
			case "arenas":
				return ec.fieldContext_MatchmakingTicket_arenas(ctx, field)
			case "matchId":
				return ec.fieldContext_MatchmakingTicket_matchId(ctx, field)
			case "status":
				return ec.fieldContext_MatchmakingTicket_status(ctx, field)
			case "data":
				return ec.fieldContext_MatchmakingTicket_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchmakingTicket_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchmakingTicket_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchmakingTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_privateServerId(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_privateServerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PrivateServerId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_privateServerId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_status(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Match().Status(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.MatchStatus
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.MatchStatus
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.MatchStatus
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.MatchStatus
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.MatchStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.MatchStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MatchStatus)
	fc.Result = res
	return ec.marshalNMatchStatus2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_data(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_lockedAt(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_lockedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LockedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_lockedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_startedAt(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.StartedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_startedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_endedAt(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_endedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.EndedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_endedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Match_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Match) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Match_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Match_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Match",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_id(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_matchmakingUsers(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_matchmakingUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchmakingUsers, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.MatchmakingUser
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.MatchmakingUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.MatchmakingUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.MatchmakingUser)
	fc.Result = res
	return ec.marshalNMatchmakingUser2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_matchmakingUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchmakingUser_id(ctx, field)
			case "clientUserId":
				return ec.fieldContext_MatchmakingUser_clientUserId(ctx, field)
			case "data":
				return ec.fieldContext_MatchmakingUser_data(ctx, field)
			case "elo":
				return ec.fieldContext_MatchmakingUser_elo(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchmakingUser_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchmakingUser_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchmakingUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_arenas(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_arenas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Arenas, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal []*api.Arena
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Arena
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Arena); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Arena`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.Arena)
	fc.Result = res
	return ec.marshalNArena2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArena(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_arenas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Arena_id(ctx, field)
			case "name":
				return ec.fieldContext_Arena_name(ctx, field)
			case "minPlayers":
				return ec.fieldContext_Arena_minPlayers(ctx, field)
			case "maxPlayersPerTicket":
				return ec.fieldContext_Arena_maxPlayersPerTicket(ctx, field)
			case "maxPlayers":
				return ec.fieldContext_Arena_maxPlayers(ctx, field)
			case "data":
				return ec.fieldContext_Arena_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Arena_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Arena_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Arena", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_matchId(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_matchId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_matchId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_status(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.MatchmakingTicket().Status(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.MatchmakingTicketStatus
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.MatchmakingTicketStatus
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.MatchmakingTicketStatus
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.MatchmakingTicketStatus
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.MatchmakingTicketStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.MatchmakingTicketStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MatchmakingTicketStatus)
	fc.Result = res
	return ec.marshalNMatchmakingTicketStatus2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchmakingTicketStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchmakingTicketStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_data(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingTicket_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingTicket_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingTicket_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingUser_id(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingUser_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingUser_clientUserId(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingUser_clientUserId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ClientUserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingUser_clientUserId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingUser_data(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingUser_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingUser_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingUser_elo(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingUser_elo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Elo, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingUser_elo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingUser_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingUser_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingUser_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchmakingUser_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.MatchmakingUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchmakingUser_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchmakingUser_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchmakingUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateEvent(rctx, fc.Args["input"].(*api.CreateEventRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.CreateEventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateEventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.CreateEventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateEventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateEventResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateEventResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateEventResponse)
	fc.Result = res
	return ec.marshalNCreateEventResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateEventResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateEventResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateEventResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateEventResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEvent(rctx, fc.Args["input"].(*api.UpdateEventRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.UpdateEventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateEventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.UpdateEventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateEventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateEventResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateEventResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateEventResponse)
	fc.Result = res
	return ec.marshalNUpdateEventResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateEventResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateEventResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateEventResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteEvent(rctx, fc.Args["input"].(*api.EventRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.EventResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.EventResponse)
	fc.Result = res
	return ec.marshalNEventResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_EventResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_EventResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateEventRound(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateEventRound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateEventRound(rctx, fc.Args["input"].(*api.CreateEventRoundRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.CreateEventRoundResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateEventRoundResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.CreateEventRoundResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateEventRoundResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateEventRoundResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateEventRoundResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateEventRoundResponse)
	fc.Result = res
	return ec.marshalNCreateEventRoundResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRoundResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateEventRound(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateEventRoundResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateEventRoundResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateEventRoundResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateEventRoundResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateEventRound_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateEventRound(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateEventRound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEventRound(rctx, fc.Args["input"].(*api.UpdateEventRoundRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.UpdateEventRoundResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateEventRoundResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.UpdateEventRoundResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateEventRoundResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateEventRoundResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateEventRoundResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateEventRoundResponse)
	fc.Result = res
	return ec.marshalNUpdateEventRoundResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventRoundResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateEventRound(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateEventRoundResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateEventRoundResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateEventRoundResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateEventRound_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateEventUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateEventUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEventUser(rctx, fc.Args["input"].(*api.UpdateEventUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.UpdateEventUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateEventUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.UpdateEventUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateEventUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateEventUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateEventUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateEventUserResponse)
	fc.Result = res
	return ec.marshalNUpdateEventUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateEventUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateEventUserResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateEventUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateEventUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateEventUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteEventUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteEventUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteEventUser(rctx, fc.Args["input"].(*api.EventUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.EventUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EventUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.EventUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.EventUserResponse)
	fc.Result = res
	return ec.marshalNEventUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteEventUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_EventUserResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_EventUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteEventUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_AddEventResult(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_AddEventResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddEventResult(rctx, fc.Args["input"].(*api.AddEventResultRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.AddEventResultResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.AddEventResultResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.AddEventResultResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.AddEventResultResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.AddEventResultResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.AddEventResultResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.AddEventResultResponse)
	fc.Result = res
	return ec.marshalNAddEventResultResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐAddEventResultResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_AddEventResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_AddEventResultResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_AddEventResultResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AddEventResultResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_AddEventResult_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_RemoveEventResult(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_RemoveEventResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RemoveEventResult(rctx, fc.Args["input"].(*api.EventRoundUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.RemoveEventResultResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.RemoveEventResultResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.RemoveEventResultResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.RemoveEventResultResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.RemoveEventResultResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.RemoveEventResultResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.RemoveEventResultResponse)
	fc.Result = res
	return ec.marshalNRemoveEventResultResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRemoveEventResultResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_RemoveEventResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_RemoveEventResultResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_RemoveEventResultResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RemoveEventResultResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_RemoveEventResult_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateItem(rctx, fc.Args["input"].(*api.CreateItemRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *api.CreateItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *api.CreateItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateItemResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateItemResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateItemResponse)
	fc.Result = res
	return ec.marshalNCreateItemResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateItemResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateItemResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_CreateItemResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateItemResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateItem(rctx, fc.Args["input"].(*api.UpdateItemRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *api.UpdateItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *api.UpdateItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateItemResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateItemResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateItemResponse)
	fc.Result = res
	return ec.marshalNUpdateItemResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateItemResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateItemResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateItemResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateItemResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteItem(rctx, fc.Args["input"].(*api.ItemRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *api.ItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.ItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *api.ItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.ItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.ItemResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.ItemResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.ItemResponse)
	fc.Result = res
	return ec.marshalNItemResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItemResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_ItemResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_ItemResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateArena(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateArena(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateArena(rctx, fc.Args["input"].(*api.CreateArenaRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.CreateArenaResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateArenaResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.CreateArenaResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateArenaResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateArenaResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateArenaResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateArenaResponse)
	fc.Result = res
	return ec.marshalNCreateArenaResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateArenaResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateArena(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateArenaResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateArenaResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateArenaResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateArenaResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateArena_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateArena(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateArena(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateArena(rctx, fc.Args["input"].(*api.UpdateArenaRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateArenaResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateArenaResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateArenaResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateArenaResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateArenaResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateArenaResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateArenaResponse)
	fc.Result = res
	return ec.marshalNUpdateArenaResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateArenaResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateArena(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateArenaResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateArenaResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateArenaResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateArena_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateMatchmakingUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateMatchmakingUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateMatchmakingUser(rctx, fc.Args["input"].(*api.CreateMatchmakingUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.CreateMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.CreateMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateMatchmakingUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateMatchmakingUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateMatchmakingUserResponse)
	fc.Result = res
	return ec.marshalNCreateMatchmakingUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateMatchmakingUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateMatchmakingUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateMatchmakingUserResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateMatchmakingUserResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateMatchmakingUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateMatchmakingUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateMatchmakingUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateMatchmakingUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateMatchmakingUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMatchmakingUser(rctx, fc.Args["input"].(*api.UpdateMatchmakingUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateMatchmakingUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateMatchmakingUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateMatchmakingUserResponse)
	fc.Result = res
	return ec.marshalNUpdateMatchmakingUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchmakingUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateMatchmakingUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateMatchmakingUserResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateMatchmakingUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateMatchmakingUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateMatchmakingUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteMatchmakingUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteMatchmakingUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteMatchmakingUser(rctx, fc.Args["input"].(*api.MatchmakingUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.DeleteMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.DeleteMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.DeleteMatchmakingUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.DeleteMatchmakingUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.DeleteMatchmakingUserResponse)
	fc.Result = res
	return ec.marshalNDeleteMatchmakingUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐDeleteMatchmakingUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteMatchmakingUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteMatchmakingUserResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_DeleteMatchmakingUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteMatchmakingUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteMatchmakingUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateMatchmakingTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateMatchmakingTicket(rctx, fc.Args["input"].(*api.CreateMatchmakingTicketRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.CreateMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.CreateMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateMatchmakingTicketResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateMatchmakingTicketResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateMatchmakingTicketResponse)
	fc.Result = res
	return ec.marshalNCreateMatchmakingTicketResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateMatchmakingTicketResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateMatchmakingTicketResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateMatchmakingTicketResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateMatchmakingTicketResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateMatchmakingTicketResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateMatchmakingTicket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateMatchmakingTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMatchmakingTicket(rctx, fc.Args["input"].(*api.UpdateMatchmakingTicketRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateMatchmakingTicketResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateMatchmakingTicketResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateMatchmakingTicketResponse)
	fc.Result = res
	return ec.marshalNUpdateMatchmakingTicketResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchmakingTicketResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateMatchmakingTicketResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateMatchmakingTicketResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateMatchmakingTicketResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateMatchmakingTicket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteMatchmakingTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteMatchmakingTicket(rctx, fc.Args["input"].(*api.MatchmakingTicketRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.DeleteMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.DeleteMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.DeleteMatchmakingTicketResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.DeleteMatchmakingTicketResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.DeleteMatchmakingTicketResponse)
	fc.Result = res
	return ec.marshalNDeleteMatchmakingTicketResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐDeleteMatchmakingTicketResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteMatchmakingTicketResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_DeleteMatchmakingTicketResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteMatchmakingTicketResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteMatchmakingTicket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_StartMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_StartMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().StartMatch(rctx, fc.Args["input"].(*api.StartMatchRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.StartMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.StartMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.StartMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.StartMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.StartMatchResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.StartMatchResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.StartMatchResponse)
	fc.Result = res
	return ec.marshalNStartMatchResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐStartMatchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_StartMatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_StartMatchResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_StartMatchResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StartMatchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_StartMatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_EndMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_EndMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().EndMatch(rctx, fc.Args["input"].(*api.EndMatchRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.EndMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EndMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.EndMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.EndMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.EndMatchResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EndMatchResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.EndMatchResponse)
	fc.Result = res
	return ec.marshalNEndMatchResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEndMatchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_EndMatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_EndMatchResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_EndMatchResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EndMatchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_EndMatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMatch(rctx, fc.Args["input"].(*api.UpdateMatchRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.UpdateMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateMatchResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateMatchResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateMatchResponse)
	fc.Result = res
	return ec.marshalNUpdateMatchResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateMatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateMatchResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateMatchResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateMatchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateMatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_SetMatchPrivateServer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_SetMatchPrivateServer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetMatchPrivateServer(rctx, fc.Args["input"].(*api.SetMatchPrivateServerRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.SetMatchPrivateServerResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.SetMatchPrivateServerResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.SetMatchPrivateServerResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.SetMatchPrivateServerResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.SetMatchPrivateServerResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.SetMatchPrivateServerResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.SetMatchPrivateServerResponse)
	fc.Result = res
	return ec.marshalNSetMatchPrivateServerResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐSetMatchPrivateServerResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_SetMatchPrivateServer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_SetMatchPrivateServerResponse_success(ctx, field)
			case "privateServerId":
				return ec.fieldContext_SetMatchPrivateServerResponse_privateServerId(ctx, field)
			case "error":
				return ec.fieldContext_SetMatchPrivateServerResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SetMatchPrivateServerResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_SetMatchPrivateServer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteMatch(rctx, fc.Args["input"].(*api.MatchRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.DeleteMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.DeleteMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.DeleteMatchResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.DeleteMatchResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.DeleteMatchResponse)
	fc.Result = res
	return ec.marshalNDeleteMatchResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐDeleteMatchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteMatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteMatchResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_DeleteMatchResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteMatchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteMatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateRecord(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateRecord(rctx, fc.Args["input"].(*api.CreateRecordRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *api.CreateRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *api.CreateRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateRecordResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateRecordResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateRecordResponse)
	fc.Result = res
	return ec.marshalNCreateRecordResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateRecordResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateRecordResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateRecordResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateRecordResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateRecordResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateRecord_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateRecord(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateRecord(rctx, fc.Args["input"].(*api.UpdateRecordRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *api.UpdateRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *api.UpdateRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateRecordResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateRecordResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateRecordResponse)
	fc.Result = res
	return ec.marshalNUpdateRecordResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateRecordResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateRecordResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateRecordResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateRecordResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateRecord_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteRecord(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteRecord(rctx, fc.Args["input"].(*api.RecordRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *api.DeleteRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *api.DeleteRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.DeleteRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.DeleteRecordResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.DeleteRecordResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.DeleteRecordResponse)
	fc.Result = res
	return ec.marshalNDeleteRecordResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐDeleteRecordResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DeleteRecordResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_DeleteRecordResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteRecordResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteRecord_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTask(rctx, fc.Args["input"].(*api.CreateTaskRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.CreateTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.CreateTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateTaskResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateTaskResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateTaskResponse)
	fc.Result = res
	return ec.marshalNCreateTaskResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTaskResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateTaskResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_CreateTaskResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateTaskResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTask(rctx, fc.Args["input"].(*api.UpdateTaskRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.UpdateTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.UpdateTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateTaskResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateTaskResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateTaskResponse)
	fc.Result = res
	return ec.marshalNUpdateTaskResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTaskResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateTaskResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateTaskResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTaskResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CompleteTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CompleteTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CompleteTask(rctx, fc.Args["input"].(*api.TaskRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.CompleteTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CompleteTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.CompleteTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CompleteTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CompleteTaskResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CompleteTaskResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CompleteTaskResponse)
	fc.Result = res
	return ec.marshalNCompleteTaskResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCompleteTaskResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CompleteTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CompleteTaskResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_CompleteTaskResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompleteTaskResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CompleteTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTask(rctx, fc.Args["input"].(*api.TaskRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.TaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.TaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.TaskResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TaskResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.TaskResponse)
	fc.Result = res
	return ec.marshalNTaskResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTaskResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_TaskResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_TaskResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTeam(rctx, fc.Args["input"].(*api.CreateTeamRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.CreateTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.CreateTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateTeamResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateTeamResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateTeamResponse)
	fc.Result = res
	return ec.marshalNCreateTeamResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTeamResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateTeamResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateTeamResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateTeamResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateTeamResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTeam(rctx, fc.Args["input"].(*api.UpdateTeamRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.UpdateTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.UpdateTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateTeamResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateTeamResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateTeamResponse)
	fc.Result = res
	return ec.marshalNUpdateTeamResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTeamResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateTeamResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateTeamResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTeamResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTeam(rctx, fc.Args["input"].(*api.TeamRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.TeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.TeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.TeamResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.TeamResponse)
	fc.Result = res
	return ec.marshalNTeamResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_TeamResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_TeamResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_JoinTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_JoinTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().JoinTeam(rctx, fc.Args["input"].(*api.JoinTeamRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.JoinTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.JoinTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.JoinTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.JoinTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.JoinTeamResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.JoinTeamResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.JoinTeamResponse)
	fc.Result = res
	return ec.marshalNJoinTeamResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐJoinTeamResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_JoinTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_JoinTeamResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_JoinTeamResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JoinTeamResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_JoinTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_LeaveTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_LeaveTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().LeaveTeam(rctx, fc.Args["input"].(*api.TeamMemberRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.LeaveTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.LeaveTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.LeaveTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.LeaveTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.LeaveTeamResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.LeaveTeamResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.LeaveTeamResponse)
	fc.Result = res
	return ec.marshalNLeaveTeamResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐLeaveTeamResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_LeaveTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_LeaveTeamResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_LeaveTeamResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LeaveTeamResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_LeaveTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateTeamMember(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateTeamMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTeamMember(rctx, fc.Args["input"].(*api.UpdateTeamMemberRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.UpdateTeamMemberResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTeamMemberResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.UpdateTeamMemberResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTeamMemberResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateTeamMemberResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateTeamMemberResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateTeamMemberResponse)
	fc.Result = res
	return ec.marshalNUpdateTeamMemberResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTeamMemberResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateTeamMember(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateTeamMemberResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateTeamMemberResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTeamMemberResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateTeamMember_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateTournamentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateTournamentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTournamentUser(rctx, fc.Args["input"].(*api.CreateTournamentUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.CreateTournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateTournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.CreateTournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.CreateTournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.CreateTournamentUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateTournamentUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.CreateTournamentUserResponse)
	fc.Result = res
	return ec.marshalNCreateTournamentUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTournamentUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateTournamentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_CreateTournamentUserResponse_success(ctx, field)
			case "id":
				return ec.fieldContext_CreateTournamentUserResponse_id(ctx, field)
			case "error":
				return ec.fieldContext_CreateTournamentUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateTournamentUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateTournamentUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateTournamentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateTournamentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTournamentUser(rctx, fc.Args["input"].(*api.UpdateTournamentUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.UpdateTournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.UpdateTournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.UpdateTournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.UpdateTournamentUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.UpdateTournamentUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.UpdateTournamentUserResponse)
	fc.Result = res
	return ec.marshalNUpdateTournamentUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTournamentUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateTournamentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_UpdateTournamentUserResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_UpdateTournamentUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTournamentUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateTournamentUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteTournamentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteTournamentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTournamentUser(rctx, fc.Args["input"].(*api.TournamentUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.TournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.TournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.TournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.TournamentUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TournamentUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.TournamentUserResponse)
	fc.Result = res
	return ec.marshalNTournamentUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteTournamentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_TournamentUserResponse_success(ctx, field)
			case "error":
				return ec.fieldContext_TournamentUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TournamentUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteTournamentUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Webhook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Webhook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Webhook(rctx, fc.Args["input"].(*api.WebhookRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Webhook")
			if err != nil {
				var zeroVal *api.WebhookResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.WebhookResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Webhook")
			if err != nil {
				var zeroVal *api.WebhookResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.WebhookResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.WebhookResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.WebhookResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.WebhookResponse)
	fc.Result = res
	return ec.marshalNWebhookResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐWebhookResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Webhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_WebhookResponse_status(ctx, field)
			case "headers":
				return ec.fieldContext_WebhookResponse_headers(ctx, field)
			case "body":
				return ec.fieldContext_WebhookResponse_body(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WebhookResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_Webhook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetEvent(rctx, fc.Args["input"].(*api.GetEventRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.GetEventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetEventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.GetEventResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetEventResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetEventResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetEventResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetEventResponse)
	fc.Result = res
	return ec.marshalNGetEventResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetEventResponse_success(ctx, field)
			case "event":
				return ec.fieldContext_GetEventResponse_event(ctx, field)
			case "leaderboard":
				return ec.fieldContext_GetEventResponse_leaderboard(ctx, field)
			case "error":
				return ec.fieldContext_GetEventResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetEventResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetEventRound(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetEventRound(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetEventRound(rctx, fc.Args["input"].(*api.GetEventRoundRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.GetEventRoundResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetEventRoundResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.GetEventRoundResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetEventRoundResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetEventRoundResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetEventRoundResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetEventRoundResponse)
	fc.Result = res
	return ec.marshalNGetEventRoundResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventRoundResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetEventRound(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetEventRoundResponse_success(ctx, field)
			case "round":
				return ec.fieldContext_GetEventRoundResponse_round(ctx, field)
			case "results":
				return ec.fieldContext_GetEventRoundResponse_results(ctx, field)
			case "error":
				return ec.fieldContext_GetEventRoundResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetEventRoundResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetEventRound_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetEventUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetEventUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetEventUser(rctx, fc.Args["input"].(*api.GetEventUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.GetEventUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetEventUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal *api.GetEventUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetEventUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetEventUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetEventUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetEventUserResponse)
	fc.Result = res
	return ec.marshalNGetEventUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetEventUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetEventUserResponse_success(ctx, field)
			case "user":
				return ec.fieldContext_GetEventUserResponse_user(ctx, field)
			case "results":
				return ec.fieldContext_GetEventUserResponse_results(ctx, field)
			case "error":
				return ec.fieldContext_GetEventUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetEventUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetEventUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetItem(rctx, fc.Args["input"].(*api.ItemRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *api.GetItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *api.GetItemResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetItemResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetItemResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetItemResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetItemResponse)
	fc.Result = res
	return ec.marshalNGetItemResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetItemResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetItemResponse_success(ctx, field)
			case "item":
				return ec.fieldContext_GetItemResponse_item(ctx, field)
			case "error":
				return ec.fieldContext_GetItemResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetItemResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetItems(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetItems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetItems(rctx, fc.Args["input"].(*api.GetItemsRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *api.GetItemsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetItemsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal *api.GetItemsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetItemsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetItemsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetItemsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetItemsResponse)
	fc.Result = res
	return ec.marshalNGetItemsResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetItemsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetItems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetItemsResponse_success(ctx, field)
			case "items":
				return ec.fieldContext_GetItemsResponse_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetItemsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetItems_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetArena(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetArena(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetArena(rctx, fc.Args["input"].(*api.ArenaRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetArenaResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetArenaResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetArenaResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetArenaResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetArenaResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetArenaResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetArenaResponse)
	fc.Result = res
	return ec.marshalNGetArenaResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetArenaResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetArena(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetArenaResponse_success(ctx, field)
			case "arena":
				return ec.fieldContext_GetArenaResponse_arena(ctx, field)
			case "error":
				return ec.fieldContext_GetArenaResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetArenaResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetArena_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetArenas(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetArenas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetArenas(rctx, fc.Args["input"].(*api.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetArenasResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetArenasResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetArenasResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetArenasResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetArenasResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetArenasResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetArenasResponse)
	fc.Result = res
	return ec.marshalNGetArenasResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetArenasResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetArenas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetArenasResponse_success(ctx, field)
			case "arenas":
				return ec.fieldContext_GetArenasResponse_arenas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetArenasResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetArenas_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetMatchmakingUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetMatchmakingUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMatchmakingUser(rctx, fc.Args["input"].(*api.MatchmakingUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetMatchmakingUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetMatchmakingUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetMatchmakingUserResponse)
	fc.Result = res
	return ec.marshalNGetMatchmakingUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetMatchmakingUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetMatchmakingUserResponse_success(ctx, field)
			case "matchmakingUser":
				return ec.fieldContext_GetMatchmakingUserResponse_matchmakingUser(ctx, field)
			case "error":
				return ec.fieldContext_GetMatchmakingUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMatchmakingUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetMatchmakingUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetMatchmakingUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetMatchmakingUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMatchmakingUsers(rctx, fc.Args["input"].(*api.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingUsersResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingUsersResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingUsersResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingUsersResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetMatchmakingUsersResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetMatchmakingUsersResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetMatchmakingUsersResponse)
	fc.Result = res
	return ec.marshalNGetMatchmakingUsersResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingUsersResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetMatchmakingUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetMatchmakingUsersResponse_success(ctx, field)
			case "matchmakingUsers":
				return ec.fieldContext_GetMatchmakingUsersResponse_matchmakingUsers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMatchmakingUsersResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetMatchmakingUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetMatchmakingTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMatchmakingTicket(rctx, fc.Args["input"].(*api.GetMatchmakingTicketRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingTicketResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingTicketResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetMatchmakingTicketResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetMatchmakingTicketResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetMatchmakingTicketResponse)
	fc.Result = res
	return ec.marshalNGetMatchmakingTicketResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingTicketResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetMatchmakingTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetMatchmakingTicketResponse_success(ctx, field)
			case "matchmakingTicket":
				return ec.fieldContext_GetMatchmakingTicketResponse_matchmakingTicket(ctx, field)
			case "error":
				return ec.fieldContext_GetMatchmakingTicketResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMatchmakingTicketResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetMatchmakingTicket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetMatchmakingTickets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetMatchmakingTickets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMatchmakingTickets(rctx, fc.Args["input"].(*api.GetMatchmakingTicketsRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingTicketsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingTicketsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchmakingTicketsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchmakingTicketsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetMatchmakingTicketsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetMatchmakingTicketsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetMatchmakingTicketsResponse)
	fc.Result = res
	return ec.marshalNGetMatchmakingTicketsResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingTicketsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetMatchmakingTickets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetMatchmakingTicketsResponse_success(ctx, field)
			case "matchmakingTickets":
				return ec.fieldContext_GetMatchmakingTicketsResponse_matchmakingTickets(ctx, field)
			case "error":
				return ec.fieldContext_GetMatchmakingTicketsResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMatchmakingTicketsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetMatchmakingTickets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMatch(rctx, fc.Args["input"].(*api.GetMatchRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetMatchResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetMatchResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetMatchResponse)
	fc.Result = res
	return ec.marshalNGetMatchResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetMatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetMatchResponse_success(ctx, field)
			case "match":
				return ec.fieldContext_GetMatchResponse_match(ctx, field)
			case "error":
				return ec.fieldContext_GetMatchResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMatchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetMatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetMatches(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetMatches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMatches(rctx, fc.Args["input"].(*api.GetMatchesRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchesResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchesResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *api.GetMatchesResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetMatchesResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetMatchesResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetMatchesResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetMatchesResponse)
	fc.Result = res
	return ec.marshalNGetMatchesResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchesResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetMatches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetMatchesResponse_success(ctx, field)
			case "matches":
				return ec.fieldContext_GetMatchesResponse_matches(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMatchesResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetMatches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetRecord(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetRecord(rctx, fc.Args["input"].(*api.RecordRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *api.GetRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *api.GetRecordResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetRecordResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetRecordResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetRecordResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetRecordResponse)
	fc.Result = res
	return ec.marshalNGetRecordResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetRecordResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetRecordResponse_success(ctx, field)
			case "record":
				return ec.fieldContext_GetRecordResponse_record(ctx, field)
			case "error":
				return ec.fieldContext_GetRecordResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetRecordResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetRecord_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetRecords(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetRecords(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetRecords(rctx, fc.Args["input"].(*api.GetRecordsRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *api.GetRecordsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetRecordsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *api.GetRecordsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetRecordsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetRecordsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetRecordsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetRecordsResponse)
	fc.Result = res
	return ec.marshalNGetRecordsResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetRecordsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetRecords(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetRecordsResponse_success(ctx, field)
			case "records":
				return ec.fieldContext_GetRecordsResponse_records(ctx, field)
			case "error":
				return ec.fieldContext_GetRecordsResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetRecordsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetRecords_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTask(rctx, fc.Args["input"].(*api.TaskRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.GetTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.GetTaskResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTaskResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTaskResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTaskResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTaskResponse)
	fc.Result = res
	return ec.marshalNGetTaskResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTaskResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTaskResponse_success(ctx, field)
			case "task":
				return ec.fieldContext_GetTaskResponse_task(ctx, field)
			case "error":
				return ec.fieldContext_GetTaskResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTaskResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTasks(rctx, fc.Args["input"].(*api.GetTasksRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.GetTasksResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTasksResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *api.GetTasksResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTasksResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTasksResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTasksResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTasksResponse)
	fc.Result = res
	return ec.marshalNGetTasksResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTasksResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTasksResponse_success(ctx, field)
			case "tasks":
				return ec.fieldContext_GetTasksResponse_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTasksResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTeam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTeam(rctx, fc.Args["input"].(*api.GetTeamRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.GetTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.GetTeamResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTeamResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTeamResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTeamResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTeamResponse)
	fc.Result = res
	return ec.marshalNGetTeamResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTeamResponse_success(ctx, field)
			case "team":
				return ec.fieldContext_GetTeamResponse_team(ctx, field)
			case "error":
				return ec.fieldContext_GetTeamResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTeamResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTeam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTeams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTeams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTeams(rctx, fc.Args["input"].(*api.GetTeamsRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.GetTeamsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTeamsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.GetTeamsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTeamsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTeamsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTeamsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTeamsResponse)
	fc.Result = res
	return ec.marshalNGetTeamsResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTeams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTeamsResponse_success(ctx, field)
			case "teams":
				return ec.fieldContext_GetTeamsResponse_teams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTeamsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTeams_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTeamMember(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTeamMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTeamMember(rctx, fc.Args["input"].(*api.TeamMemberRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.GetTeamMemberResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTeamMemberResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.GetTeamMemberResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTeamMemberResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTeamMemberResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTeamMemberResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTeamMemberResponse)
	fc.Result = res
	return ec.marshalNGetTeamMemberResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamMemberResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTeamMember(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTeamMemberResponse_success(ctx, field)
			case "member":
				return ec.fieldContext_GetTeamMemberResponse_member(ctx, field)
			case "error":
				return ec.fieldContext_GetTeamMemberResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTeamMemberResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTeamMember_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_SearchTeams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_SearchTeams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SearchTeams(rctx, fc.Args["input"].(*api.SearchTeamsRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.SearchTeamsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.SearchTeamsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *api.SearchTeamsResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.SearchTeamsResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.SearchTeamsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.SearchTeamsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.SearchTeamsResponse)
	fc.Result = res
	return ec.marshalNSearchTeamsResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐSearchTeamsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_SearchTeams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_SearchTeamsResponse_success(ctx, field)
			case "teams":
				return ec.fieldContext_SearchTeamsResponse_teams(ctx, field)
			case "error":
				return ec.fieldContext_SearchTeamsResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchTeamsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_SearchTeams_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTournamentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTournamentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTournamentUser(rctx, fc.Args["input"].(*api.TournamentUserRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.GetTournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.GetTournamentUserResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTournamentUserResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTournamentUserResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTournamentUserResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTournamentUserResponse)
	fc.Result = res
	return ec.marshalNGetTournamentUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTournamentUserResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTournamentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTournamentUserResponse_success(ctx, field)
			case "tournamentUser":
				return ec.fieldContext_GetTournamentUserResponse_tournamentUser(ctx, field)
			case "error":
				return ec.fieldContext_GetTournamentUserResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTournamentUserResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTournamentUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_GetTournamentUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GetTournamentUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTournamentUsers(rctx, fc.Args["input"].(*api.GetTournamentUsersRequest))
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.GetTournamentUsersResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTournamentUsersResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *api.GetTournamentUsersResponse
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *api.GetTournamentUsersResponse
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, nil, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*api.GetTournamentUsersResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.GetTournamentUsersResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*api.GetTournamentUsersResponse)
	fc.Result = res
	return ec.marshalNGetTournamentUsersResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTournamentUsersResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GetTournamentUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_GetTournamentUsersResponse_success(ctx, field)
			case "tournamentUsers":
				return ec.fieldContext_GetTournamentUsersResponse_tournamentUsers(ctx, field)
			case "error":
				return ec.fieldContext_GetTournamentUsersResponse_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetTournamentUsersResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_GetTournamentUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_id(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_name(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_userId(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_record(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_record(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Record, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_record(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_ranking(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_ranking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Ranking, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_ranking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_data(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Record_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Record) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Record_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Record_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Record",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveEventResultResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.RemoveEventResultResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveEventResultResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveEventResultResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveEventResultResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveEventResultResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.RemoveEventResultResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveEventResultResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.RemoveEventResultResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.RemoveEventResultError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.RemoveEventResultError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.RemoveEventResultError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.RemoveEventResultError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.RemoveEventResultError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.RemoveEventResultError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RemoveEventResultError)
	fc.Result = res
	return ec.marshalNRemoveEventResultError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐRemoveEventResultError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveEventResultResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveEventResultResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RemoveEventResultError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchTeamsResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.SearchTeamsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchTeamsResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchTeamsResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchTeamsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchTeamsResponse_teams(ctx context.Context, field graphql.CollectedField, obj *api.SearchTeamsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchTeamsResponse_teams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Teams, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal []*api.Team
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Team
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal []*api.Team
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.Team
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.Team); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.Team`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchTeamsResponse_teams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchTeamsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "name":
				return ec.fieldContext_Team_name(ctx, field)
			case "score":
				return ec.fieldContext_Team_score(ctx, field)
			case "ranking":
				return ec.fieldContext_Team_ranking(ctx, field)
			case "members":
				return ec.fieldContext_Team_members(ctx, field)
			case "data":
				return ec.fieldContext_Team_data(ctx, field)
			case "createdAt":
				return ec.fieldContext_Team_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Team_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchTeamsResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.SearchTeamsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchTeamsResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.SearchTeamsResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.SearchTeamsError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.SearchTeamsError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.SearchTeamsError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.SearchTeamsError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.SearchTeamsError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.SearchTeamsError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SearchTeamsError)
	fc.Result = res
	return ec.marshalNSearchTeamsError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐSearchTeamsError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchTeamsResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchTeamsResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchTeamsError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetMatchPrivateServerResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.SetMatchPrivateServerResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetMatchPrivateServerResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetMatchPrivateServerResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetMatchPrivateServerResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetMatchPrivateServerResponse_privateServerId(ctx context.Context, field graphql.CollectedField, obj *api.SetMatchPrivateServerResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetMatchPrivateServerResponse_privateServerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PrivateServerId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal *string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetMatchPrivateServerResponse_privateServerId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetMatchPrivateServerResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetMatchPrivateServerResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.SetMatchPrivateServerResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetMatchPrivateServerResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.SetMatchPrivateServerResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.SetMatchPrivateServerError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.SetMatchPrivateServerError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.SetMatchPrivateServerError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.SetMatchPrivateServerError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.SetMatchPrivateServerError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.SetMatchPrivateServerError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SetMatchPrivateServerError)
	fc.Result = res
	return ec.marshalNSetMatchPrivateServerError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐSetMatchPrivateServerError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetMatchPrivateServerResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetMatchPrivateServerResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SetMatchPrivateServerError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StartMatchResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.StartMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StartMatchResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StartMatchResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StartMatchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StartMatchResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.StartMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StartMatchResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.StartMatchResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.StartMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.StartMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.StartMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.StartMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.StartMatchError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.StartMatchError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.StartMatchError)
	fc.Result = res
	return ec.marshalNStartMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐStartMatchError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StartMatchResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StartMatchResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StartMatchError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_id(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_type(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Type, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_data(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_expiresAt(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ExpiresAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_expiresAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_completedAt(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_completedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CompletedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_completedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.TaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.TaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.TaskResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal model.TaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.TaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal model.TaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.TaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.TaskError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.TaskError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TaskError)
	fc.Result = res
	return ec.marshalNTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐTaskError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TaskError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_id(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_name(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_score(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_score(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Score, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_score(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_ranking(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_ranking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Ranking, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_ranking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_members(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_members(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Members, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal []*api.TeamMember
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.TeamMember
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal []*api.TeamMember
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal []*api.TeamMember
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*api.TeamMember); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.TeamMember`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*api.TeamMember)
	fc.Result = res
	return ec.marshalNTeamMember2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamMember(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_members(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TeamMember_id(ctx, field)
			case "userId":
				return ec.fieldContext_TeamMember_userId(ctx, field)
			case "teamId":
				return ec.fieldContext_TeamMember_teamId(ctx, field)
			case "data":
				return ec.fieldContext_TeamMember_data(ctx, field)
			case "joinedAt":
				return ec.fieldContext_TeamMember_joinedAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_TeamMember_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TeamMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_data(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_id(ctx context.Context, field graphql.CollectedField, obj *api.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_userId(ctx context.Context, field graphql.CollectedField, obj *api.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_teamId(ctx context.Context, field graphql.CollectedField, obj *api.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_teamId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TeamId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_teamId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_data(ctx context.Context, field graphql.CollectedField, obj *api.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_joinedAt(ctx context.Context, field graphql.CollectedField, obj *api.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_joinedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.JoinedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_joinedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamMember_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.TeamMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamMember_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamMember_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.TeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TeamResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.TeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TeamResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.TeamResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.TeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.TeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.TeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.TeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.TeamError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.TeamError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TeamError)
	fc.Result = res
	return ec.marshalNTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐTeamError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TeamResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TeamResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TeamError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_id(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Id, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_tournament(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_tournament(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Tournament, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal string
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal string
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_tournament(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_userId(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UserId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_interval(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_interval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.TournamentUser().Interval(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal graphqlEnums.TournamentInterval
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal graphqlEnums.TournamentInterval
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal graphqlEnums.TournamentInterval
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal graphqlEnums.TournamentInterval
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(graphqlEnums.TournamentInterval); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/pkg/graphqlEnums.TournamentInterval`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(graphqlEnums.TournamentInterval)
	fc.Result = res
	return ec.marshalNTournamentInterval2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋpkgᚋgraphqlEnumsᚐTournamentInterval(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_interval(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TournamentInterval does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_score(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_score(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Score, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_score(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_ranking(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_ranking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Ranking, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal uint64
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint64
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_ranking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_data(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_tournamentStartedAt(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_tournamentStartedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TournamentStartedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_tournamentStartedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_createdAt(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUser_updatedAt(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUser_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Example == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, obj, directive1, value)
		}
		directive3 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *timestamppb.Timestamp
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive2, category)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*timestamppb.Timestamp); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*timestamppb.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUser_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TournamentUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.TournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TournamentUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.TournamentUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal model.TournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.TournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal model.TournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.TournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.TournamentUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.TournamentUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TournamentUserError)
	fc.Result = res
	return ec.marshalNTournamentUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐTournamentUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TournamentUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TournamentUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TournamentUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateArenaResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateArenaResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateArenaResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateArenaResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateArenaResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateArenaResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateArenaResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateArenaResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateArenaError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateArenaError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateArenaError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateArenaError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateArenaError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateArenaError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateArenaError)
	fc.Result = res
	return ec.marshalNUpdateArenaError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateArenaError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateArenaResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateArenaResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateArenaError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEventResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEventResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEventResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEventResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEventResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateEventResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEventResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateEventResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.UpdateEventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateEventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.UpdateEventError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateEventError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateEventError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateEventError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateEventError)
	fc.Result = res
	return ec.marshalNUpdateEventError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateEventError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEventResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEventResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateEventError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEventRoundResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEventRoundResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEventRoundResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEventRoundResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEventRoundResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateEventRoundResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEventRoundResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateEventRoundResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.UpdateEventRoundError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateEventRoundError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.UpdateEventRoundError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateEventRoundError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateEventRoundError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateEventRoundError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateEventRoundError)
	fc.Result = res
	return ec.marshalNUpdateEventRoundError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateEventRoundError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEventRoundResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEventRoundResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateEventRoundError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEventUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateEventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEventUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEventUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEventUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEventUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateEventUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEventUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateEventUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.UpdateEventUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateEventUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
			if err != nil {
				var zeroVal model.UpdateEventUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateEventUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateEventUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateEventUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateEventUserError)
	fc.Result = res
	return ec.marshalNUpdateEventUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateEventUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEventUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEventUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateEventUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateItemResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateItemResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateItemResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateItemResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateItemResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateItemResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateItemResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateItemResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal model.UpdateItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
			if err != nil {
				var zeroVal model.UpdateItemError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateItemError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateItemError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateItemError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateItemError)
	fc.Result = res
	return ec.marshalNUpdateItemError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateItemError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateItemResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateItemResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateItemError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateMatchResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateMatchResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateMatchResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateMatchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateMatchResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateMatchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateMatchResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateMatchResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateMatchError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateMatchError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateMatchError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateMatchError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateMatchError)
	fc.Result = res
	return ec.marshalNUpdateMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateMatchError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateMatchResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateMatchResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateMatchError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateMatchmakingTicketResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateMatchmakingTicketResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateMatchmakingTicketResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateMatchmakingTicketResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateMatchmakingTicketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateMatchmakingTicketResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateMatchmakingTicketResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateMatchmakingTicketError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateMatchmakingTicketError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateMatchmakingTicketError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateMatchmakingTicketError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateMatchmakingTicketError)
	fc.Result = res
	return ec.marshalNUpdateMatchmakingTicketError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateMatchmakingTicketError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateMatchmakingTicketResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateMatchmakingTicketResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateMatchmakingTicketError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateMatchmakingUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateMatchmakingUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateMatchmakingUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateMatchmakingUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateMatchmakingUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateMatchmakingUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateMatchmakingUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateMatchmakingUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
			if err != nil {
				var zeroVal model.UpdateMatchmakingUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateMatchmakingUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateMatchmakingUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateMatchmakingUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateMatchmakingUserError)
	fc.Result = res
	return ec.marshalNUpdateMatchmakingUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateMatchmakingUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateMatchmakingUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateMatchmakingUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateMatchmakingUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateRecordResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateRecordResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateRecordResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateRecordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateRecordResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateRecordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateRecordResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateRecordResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal model.UpdateRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
			if err != nil {
				var zeroVal model.UpdateRecordError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateRecordError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateRecordError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateRecordError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateRecordError)
	fc.Result = res
	return ec.marshalNUpdateRecordError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateRecordError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateRecordResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateRecordResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateRecordError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTaskResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTaskResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTaskResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTaskResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTaskResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTaskResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTaskResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateTaskResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal model.UpdateTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
			if err != nil {
				var zeroVal model.UpdateTaskError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTaskError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateTaskError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateTaskError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateTaskError)
	fc.Result = res
	return ec.marshalNUpdateTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateTaskError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTaskResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTaskResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateTaskError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamMemberResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTeamMemberResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamMemberResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamMemberResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamMemberResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamMemberResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTeamMemberResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamMemberResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateTeamMemberResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.UpdateTeamMemberError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTeamMemberError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.UpdateTeamMemberError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTeamMemberError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateTeamMemberError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateTeamMemberError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateTeamMemberError)
	fc.Result = res
	return ec.marshalNUpdateTeamMemberError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateTeamMemberError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamMemberResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamMemberResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateTeamMemberError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTeamResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTeamResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTeamResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateTeamResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.UpdateTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
			if err != nil {
				var zeroVal model.UpdateTeamError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTeamError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateTeamError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateTeamError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateTeamError)
	fc.Result = res
	return ec.marshalNUpdateTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateTeamError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTeamResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTeamResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateTeamError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTournamentUserResponse_success(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTournamentUserResponse_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTournamentUserResponse_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTournamentUserResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTournamentUserResponse_error(ctx context.Context, field graphql.CollectedField, obj *api.UpdateTournamentUserResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTournamentUserResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.UpdateTournamentUserResponse().Error(rctx, obj)
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal model.UpdateTournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
			if err != nil {
				var zeroVal model.UpdateTournamentUserError
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal model.UpdateTournamentUserError
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateTournamentUserError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/internal/bff/model.UpdateTournamentUserError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UpdateTournamentUserError)
	fc.Result = res
	return ec.marshalNUpdateTournamentUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateTournamentUserError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTournamentUserResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTournamentUserResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateTournamentUserError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookResponse_status(ctx context.Context, field graphql.CollectedField, obj *api.WebhookResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Status, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Webhook")
			if err != nil {
				var zeroVal uint32
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal uint32
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(uint32); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookResponse_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookResponse_headers(ctx context.Context, field graphql.CollectedField, obj *api.WebhookResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookResponse_headers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Headers, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Webhook")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookResponse_headers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookResponse_body(ctx context.Context, field graphql.CollectedField, obj *api.WebhookResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookResponse_body(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Body, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive0, category)
		}
		directive2 := func(ctx context.Context) (any, error) {
			category, err := ec.unmarshalOString2ᚖstring(ctx, "Webhook")
			if err != nil {
				var zeroVal *structpb.Struct
				return zeroVal, err
			}
			if ec.directives.Doc == nil {
				var zeroVal *structpb.Struct
				return zeroVal, errors.New("directive doc is not implemented")
			}
			return ec.directives.Doc(ctx, obj, directive1, category)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*structpb.Struct); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*structpb.Struct)
	fc.Result = res
	return ec.marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookResponse_body(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Struct does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddEventResultRequest(ctx context.Context, obj any) (api.AddEventResultRequest, error) {
	var it api.AddEventResultRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"event", "clientUserId", "result", "userData", "roundUserData"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRequest); ok {
				it.Event = data
			} else if tmp == nil {
				it.Event = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUserId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.ClientUserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "result":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("result"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.Result = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userData":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userData"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.UserData = data
			} else if tmp == nil {
				it.UserData = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "roundUserData":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roundUserData"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.RoundUserData = data
			} else if tmp == nil {
				it.RoundUserData = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArenaRequest(ctx context.Context, obj any) (api.ArenaRequest, error) {
	var it api.ArenaRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateArenaRequest(ctx context.Context, obj any) (api.CreateArenaRequest, error) {
	var it api.CreateArenaRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "minPlayers", "maxPlayersPerTicket", "maxPlayers", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "minPlayers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minPlayers"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint322uint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint32); ok {
				it.MinPlayers = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "maxPlayersPerTicket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPlayersPerTicket"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint322uint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint32); ok {
				it.MaxPlayersPerTicket = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "maxPlayers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPlayers"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint322uint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint32); ok {
				it.MaxPlayers = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEventRequest(ctx context.Context, obj any) (api.CreateEventRequest, error) {
	var it api.CreateEventRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "data", "startedAt", "rounds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "startedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startedAt"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Example == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive example is not implemented")
				}
				return ec.directives.Example(ctx, obj, directive1, value)
			}
			directive3 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive2, category)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*timestamppb.Timestamp); ok {
				it.StartedAt = data
			} else if tmp == nil {
				it.StartedAt = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "rounds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rounds"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNCreateEventRound2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRound(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal []*api.CreateEventRound
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*api.CreateEventRound
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal []*api.CreateEventRound
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*api.CreateEventRound
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*api.CreateEventRound); ok {
				it.Rounds = data
			} else if tmp == nil {
				it.Rounds = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.CreateEventRound`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEventRound(ctx context.Context, obj any) (api.CreateEventRound, error) {
	var it api.CreateEventRound
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "data", "endedAt", "scoring"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "endedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endedAt"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Example == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive example is not implemented")
				}
				return ec.directives.Example(ctx, obj, directive1, value)
			}
			directive3 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive2, category)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*timestamppb.Timestamp); ok {
				it.EndedAt = data
			} else if tmp == nil {
				it.EndedAt = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "scoring":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoring"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642ᚕuint64ᚄ(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal []uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal []uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]uint64); ok {
				it.Scoring = data
			} else if tmp == nil {
				it.Scoring = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEventRoundRequest(ctx context.Context, obj any) (api.CreateEventRoundRequest, error) {
	var it api.CreateEventRoundRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"event", "round"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRequest); ok {
				it.Event = data
			} else if tmp == nil {
				it.Event = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "round":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("round"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNCreateEventRound2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRound(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.CreateEventRound
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.CreateEventRound
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.CreateEventRound
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.CreateEventRound
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.CreateEventRound); ok {
				it.Round = data
			} else if tmp == nil {
				it.Round = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.CreateEventRound`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateItemRequest(ctx context.Context, obj any) (api.CreateItemRequest, error) {
	var it api.CreateItemRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "type", "data", "expiresAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNID2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Id = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Type = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Example == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive example is not implemented")
				}
				return ec.directives.Example(ctx, obj, directive1, value)
			}
			directive3 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive2, category)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*timestamppb.Timestamp); ok {
				it.ExpiresAt = data
			} else if tmp == nil {
				it.ExpiresAt = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMatchmakingTicketRequest(ctx context.Context, obj any) (api.CreateMatchmakingTicketRequest, error) {
	var it api.CreateMatchmakingTicketRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchmakingUsers", "arenas", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchmakingUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingUsers"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchmakingUserRequest2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*api.MatchmakingUserRequest); ok {
				it.MatchmakingUsers = data
			} else if tmp == nil {
				it.MatchmakingUsers = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.MatchmakingUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "arenas":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arenas"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNArenaRequest2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArenaRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*api.ArenaRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*api.ArenaRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*api.ArenaRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*api.ArenaRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*api.ArenaRequest); ok {
				it.Arenas = data
			} else if tmp == nil {
				it.Arenas = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/api.ArenaRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMatchmakingUserRequest(ctx context.Context, obj any) (api.CreateMatchmakingUserRequest, error) {
	var it api.CreateMatchmakingUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientUserId", "elo", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUserId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.ClientUserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "elo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("elo"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNInt642int64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int64); ok {
				it.Elo = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRecordRequest(ctx context.Context, obj any) (api.CreateRecordRequest, error) {
	var it api.CreateRecordRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "userId", "record", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.UserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "record":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("record"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.Record = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTaskRequest(ctx context.Context, obj any) (api.CreateTaskRequest, error) {
	var it api.CreateTaskRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "type", "data", "expiresAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNID2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Id = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Type = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Example == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive example is not implemented")
				}
				return ec.directives.Example(ctx, obj, directive1, value)
			}
			directive3 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive2, category)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*timestamppb.Timestamp); ok {
				it.ExpiresAt = data
			} else if tmp == nil {
				it.ExpiresAt = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTeamRequest(ctx context.Context, obj any) (api.CreateTeamRequest, error) {
	var it api.CreateTeamRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "score", "firstMemberUserId", "data", "firstMemberData"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "score":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOInt642ᚖint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int64); ok {
				it.Score = data
			} else if tmp == nil {
				it.Score = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "firstMemberUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstMemberUserId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.FirstMemberUserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "firstMemberData":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstMemberData"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.FirstMemberData = data
			} else if tmp == nil {
				it.FirstMemberData = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTournamentUserRequest(ctx context.Context, obj any) (api.CreateTournamentUserRequest, error) {
	var it api.CreateTournamentUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tournament", "interval", "userId", "score", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tournament":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tournament"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Tournament = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "interval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interval"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTournamentInterval2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋpkgᚋgraphqlEnumsᚐTournamentInterval(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(graphqlEnums.TournamentInterval); ok {
				if err = ec.resolvers.CreateTournamentUserRequest().Interval(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/pkg/graphqlEnums.TournamentInterval`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.UserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "score":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOInt642ᚖint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int64); ok {
				it.Score = data
			} else if tmp == nil {
				it.Score = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEndMatchRequest(ctx context.Context, obj any) (api.EndMatchRequest, error) {
	var it api.EndMatchRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"match", "endTime"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "match":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("match"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchRequest); ok {
				it.Match = data
			} else if tmp == nil {
				it.Match = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "endTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endTime"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Example == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive example is not implemented")
				}
				return ec.directives.Example(ctx, obj, directive1, value)
			}
			directive3 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive2, category)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*timestamppb.Timestamp); ok {
				it.EndTime = data
			} else if tmp == nil {
				it.EndTime = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventRequest(ctx context.Context, obj any) (api.EventRequest, error) {
	var it api.EventRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventRoundRequest(ctx context.Context, obj any) (api.EventRoundRequest, error) {
	var it api.EventRoundRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "event", "roundName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRequest); ok {
				it.Event = data
			} else if tmp == nil {
				it.Event = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "roundName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roundName"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.RoundName = data
			} else if tmp == nil {
				it.RoundName = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventRoundUserRequest(ctx context.Context, obj any) (api.EventRoundUserRequest, error) {
	var it api.EventRoundUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.Id = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventUserRequest(ctx context.Context, obj any) (api.EventUserRequest, error) {
	var it api.EventUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "event", "clientUserId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRequest); ok {
				it.Event = data
			} else if tmp == nil {
				it.Event = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUserId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.ClientUserId = data
			} else if tmp == nil {
				it.ClientUserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetEventRequest(ctx context.Context, obj any) (api.GetEventRequest, error) {
	var it api.GetEventRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"event", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRequest); ok {
				it.Event = data
			} else if tmp == nil {
				it.Event = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetEventRoundRequest(ctx context.Context, obj any) (api.GetEventRoundRequest, error) {
	var it api.GetEventRoundRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"round", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "round":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("round"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventRoundRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRoundRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRoundRequest); ok {
				it.Round = data
			} else if tmp == nil {
				it.Round = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRoundRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetEventUserRequest(ctx context.Context, obj any) (api.GetEventUserRequest, error) {
	var it api.GetEventUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"user", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "user":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventUserRequest); ok {
				it.User = data
			} else if tmp == nil {
				it.User = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetItemsRequest(ctx context.Context, obj any) (api.GetItemsRequest, error) {
	var it api.GetItemsRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Type = data
			} else if tmp == nil {
				it.Type = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetMatchRequest(ctx context.Context, obj any) (api.GetMatchRequest, error) {
	var it api.GetMatchRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"match", "ticketPagination", "userPagination", "arenaPagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "match":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("match"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchRequest); ok {
				it.Match = data
			} else if tmp == nil {
				it.Match = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "ticketPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.TicketPagination = data
			} else if tmp == nil {
				it.TicketPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.UserPagination = data
			} else if tmp == nil {
				it.UserPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "arenaPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arenaPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.ArenaPagination = data
			} else if tmp == nil {
				it.ArenaPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetMatchesRequest(ctx context.Context, obj any) (api.GetMatchesRequest, error) {
	var it api.GetMatchesRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"arena", "matchmakingUser", "statuses", "pagination", "ticketPagination", "userPagination", "arenaPagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "arena":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arena"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOArenaRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArenaRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.ArenaRequest); ok {
				it.Arena = data
			} else if tmp == nil {
				it.Arena = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.ArenaRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "matchmakingUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingUser"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingUserRequest); ok {
				it.MatchmakingUser = data
			} else if tmp == nil {
				it.MatchmakingUser = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMatchStatus2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchStatus(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*model.MatchStatus
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*model.MatchStatus
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*model.MatchStatus
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*model.MatchStatus
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.MatchStatus); ok {
				if err = ec.resolvers.GetMatchesRequest().Statuses(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/internal/bff/model.MatchStatus`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "ticketPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.TicketPagination = data
			} else if tmp == nil {
				it.TicketPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.UserPagination = data
			} else if tmp == nil {
				it.UserPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "arenaPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arenaPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.ArenaPagination = data
			} else if tmp == nil {
				it.ArenaPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetMatchmakingTicketRequest(ctx context.Context, obj any) (api.GetMatchmakingTicketRequest, error) {
	var it api.GetMatchmakingTicketRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchmakingTicket", "userPagination", "arenaPagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchmakingTicket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingTicket"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchmakingTicketRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicketRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingTicketRequest); ok {
				it.MatchmakingTicket = data
			} else if tmp == nil {
				it.MatchmakingTicket = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingTicketRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.UserPagination = data
			} else if tmp == nil {
				it.UserPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "arenaPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arenaPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.ArenaPagination = data
			} else if tmp == nil {
				it.ArenaPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetMatchmakingTicketsRequest(ctx context.Context, obj any) (api.GetMatchmakingTicketsRequest, error) {
	var it api.GetMatchmakingTicketsRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchId", "matchmakingUser", "statuses", "pagination", "userPagination", "arenaPagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.MatchId = data
			} else if tmp == nil {
				it.MatchId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "matchmakingUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingUser"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingUserRequest); ok {
				it.MatchmakingUser = data
			} else if tmp == nil {
				it.MatchmakingUser = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMatchmakingTicketStatus2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchmakingTicketStatus(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*model.MatchmakingTicketStatus
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*model.MatchmakingTicketStatus
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal []*model.MatchmakingTicketStatus
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []*model.MatchmakingTicketStatus
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*model.MatchmakingTicketStatus); ok {
				if err = ec.resolvers.GetMatchmakingTicketsRequest().Statuses(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/MorhafAlshibly/coanda/internal/bff/model.MatchmakingTicketStatus`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.UserPagination = data
			} else if tmp == nil {
				it.UserPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "arenaPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arenaPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.ArenaPagination = data
			} else if tmp == nil {
				it.ArenaPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetRecordsRequest(ctx context.Context, obj any) (api.GetRecordsRequest, error) {
	var it api.GetRecordsRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "userId", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.UserId = data
			} else if tmp == nil {
				it.UserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetTasksRequest(ctx context.Context, obj any) (api.GetTasksRequest, error) {
	var it api.GetTasksRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "completed", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Type = data
			} else if tmp == nil {
				it.Type = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "completed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("completed"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOBoolean2ᚖbool(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
				if err != nil {
					var zeroVal *bool
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *bool
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*bool); ok {
				it.Completed = data
			} else if tmp == nil {
				it.Completed = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetTeamRequest(ctx context.Context, obj any) (api.GetTeamRequest, error) {
	var it api.GetTeamRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"team", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TeamRequest); ok {
				it.Team = data
			} else if tmp == nil {
				it.Team = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetTeamsRequest(ctx context.Context, obj any) (api.GetTeamsRequest, error) {
	var it api.GetTeamsRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"pagination", "memberPagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "memberPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memberPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.MemberPagination = data
			} else if tmp == nil {
				it.MemberPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetTournamentUsersRequest(ctx context.Context, obj any) (api.GetTournamentUsersRequest, error) {
	var it api.GetTournamentUsersRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tournament", "interval", "userId", "pagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tournament":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tournament"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Tournament = data
			} else if tmp == nil {
				it.Tournament = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "interval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interval"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTournamentInterval2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋpkgᚋgraphqlEnumsᚐTournamentInterval(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(graphqlEnums.TournamentInterval); ok {
				if err = ec.resolvers.GetTournamentUsersRequest().Interval(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/pkg/graphqlEnums.TournamentInterval`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.UserId = data
			} else if tmp == nil {
				it.UserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputItemRequest(ctx context.Context, obj any) (api.ItemRequest, error) {
	var it api.ItemRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNID2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Id = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Type = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJoinTeamRequest(ctx context.Context, obj any) (api.JoinTeamRequest, error) {
	var it api.JoinTeamRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"team", "userId", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TeamRequest); ok {
				it.Team = data
			} else if tmp == nil {
				it.Team = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.UserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchRequest(ctx context.Context, obj any) (api.MatchRequest, error) {
	var it api.MatchRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "matchmakingTicket"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "matchmakingTicket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingTicket"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMatchmakingTicketRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicketRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingTicketRequest); ok {
				it.MatchmakingTicket = data
			} else if tmp == nil {
				it.MatchmakingTicket = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingTicketRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchmakingTicketRequest(ctx context.Context, obj any) (api.MatchmakingTicketRequest, error) {
	var it api.MatchmakingTicketRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "matchmakingUser"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "matchmakingUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingUser"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingUserRequest); ok {
				it.MatchmakingUser = data
			} else if tmp == nil {
				it.MatchmakingUser = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchmakingUserRequest(ctx context.Context, obj any) (api.MatchmakingUserRequest, error) {
	var it api.MatchmakingUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "clientUserId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUserId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.ClientUserId = data
			} else if tmp == nil {
				it.ClientUserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNameUserId(ctx context.Context, obj any) (api.NameUserId, error) {
	var it api.NameUserId
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.UserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPagination(ctx context.Context, obj any) (api.Pagination, error) {
	var it api.Pagination
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"max", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "max":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint322ᚖuint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint32); ok {
				it.Max = data
			} else if tmp == nil {
				it.Max = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Page = data
			} else if tmp == nil {
				it.Page = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRecordRequest(ctx context.Context, obj any) (api.RecordRequest, error) {
	var it api.RecordRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "nameUserId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "nameUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameUserId"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalONameUserId2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐNameUserId(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal *api.NameUserId
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.NameUserId
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal *api.NameUserId
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.NameUserId
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.NameUserId); ok {
				it.NameUserId = data
			} else if tmp == nil {
				it.NameUserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.NameUserId`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchTeamsRequest(ctx context.Context, obj any) (api.SearchTeamsRequest, error) {
	var it api.SearchTeamsRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"query", "pagination", "memberPagination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "query":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Query = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "pagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.Pagination = data
			} else if tmp == nil {
				it.Pagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "memberPagination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memberPagination"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.Pagination
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.Pagination
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.Pagination); ok {
				it.MemberPagination = data
			} else if tmp == nil {
				it.MemberPagination = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.Pagination`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSetMatchPrivateServerRequest(ctx context.Context, obj any) (api.SetMatchPrivateServerRequest, error) {
	var it api.SetMatchPrivateServerRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"match", "privateServerId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "match":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("match"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchRequest); ok {
				it.Match = data
			} else if tmp == nil {
				it.Match = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "privateServerId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("privateServerId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.PrivateServerId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStartMatchRequest(ctx context.Context, obj any) (api.StartMatchRequest, error) {
	var it api.StartMatchRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"match", "startTime"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "match":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("match"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchRequest); ok {
				it.Match = data
			} else if tmp == nil {
				it.Match = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "startTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startTime"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				value, err := ec.unmarshalOString2ᚖstring(ctx, "2023-10-01T12:00:00Z")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Example == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive example is not implemented")
				}
				return ec.directives.Example(ctx, obj, directive1, value)
			}
			directive3 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *timestamppb.Timestamp
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive2, category)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*timestamppb.Timestamp); ok {
				it.StartTime = data
			} else if tmp == nil {
				it.StartTime = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/timestamppb.Timestamp`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskRequest(ctx context.Context, obj any) (api.TaskRequest, error) {
	var it api.TaskRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNID2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Id = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Type = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamMemberRequest(ctx context.Context, obj any) (api.TeamMemberRequest, error) {
	var it api.TeamMemberRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.UserId = data
			} else if tmp == nil {
				it.UserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTeamRequest(ctx context.Context, obj any) (api.TeamRequest, error) {
	var it api.TeamRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "member"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "member":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("member"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOTeamMemberRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamMemberRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TeamMemberRequest); ok {
				it.Member = data
			} else if tmp == nil {
				it.Member = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamMemberRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTournamentIntervalUserId(ctx context.Context, obj any) (api.TournamentIntervalUserId, error) {
	var it api.TournamentIntervalUserId
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tournament", "interval", "userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tournament":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tournament"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Tournament = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "interval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("interval"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTournamentInterval2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋpkgᚋgraphqlEnumsᚐTournamentInterval(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal graphqlEnums.TournamentInterval
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(graphqlEnums.TournamentInterval); ok {
				if err = ec.resolvers.TournamentIntervalUserId().Interval(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/MorhafAlshibly/coanda/pkg/graphqlEnums.TournamentInterval`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNUint642uint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(uint64); ok {
				it.UserId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTournamentUserRequest(ctx context.Context, obj any) (api.TournamentUserRequest, error) {
	var it api.TournamentUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "tournamentIntervalUserId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "tournamentIntervalUserId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tournamentIntervalUserId"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOTournamentIntervalUserId2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentIntervalUserId(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *api.TournamentIntervalUserId
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TournamentIntervalUserId
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *api.TournamentIntervalUserId
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TournamentIntervalUserId
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TournamentIntervalUserId); ok {
				it.TournamentIntervalUserId = data
			} else if tmp == nil {
				it.TournamentIntervalUserId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TournamentIntervalUserId`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateArenaRequest(ctx context.Context, obj any) (api.UpdateArenaRequest, error) {
	var it api.UpdateArenaRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"arena", "minPlayers", "maxPlayersPerTicket", "maxPlayers", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "arena":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arena"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNArenaRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArenaRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.ArenaRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.ArenaRequest); ok {
				it.Arena = data
			} else if tmp == nil {
				it.Arena = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.ArenaRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "minPlayers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minPlayers"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint322ᚖuint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint32); ok {
				it.MinPlayers = data
			} else if tmp == nil {
				it.MinPlayers = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "maxPlayersPerTicket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPlayersPerTicket"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint322ᚖuint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint32); ok {
				it.MaxPlayersPerTicket = data
			} else if tmp == nil {
				it.MaxPlayersPerTicket = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "maxPlayers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPlayers"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint322ᚖuint32(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *uint32
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint32
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint32); ok {
				it.MaxPlayers = data
			} else if tmp == nil {
				it.MaxPlayers = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint32`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventRequest(ctx context.Context, obj any) (api.UpdateEventRequest, error) {
	var it api.UpdateEventRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"event", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRequest); ok {
				it.Event = data
			} else if tmp == nil {
				it.Event = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventRoundRequest(ctx context.Context, obj any) (api.UpdateEventRoundRequest, error) {
	var it api.UpdateEventRoundRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"round", "data", "scoring"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "round":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("round"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventRoundRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRoundRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventRoundRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventRoundRequest); ok {
				it.Round = data
			} else if tmp == nil {
				it.Round = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventRoundRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "scoring":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoring"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚕuint64ᚄ(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal []uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal []uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal []uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]uint64); ok {
				it.Scoring = data
			} else if tmp == nil {
				it.Scoring = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventUserRequest(ctx context.Context, obj any) (api.UpdateEventUserRequest, error) {
	var it api.UpdateEventUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"user", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "user":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEventUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.EventUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.EventUserRequest); ok {
				it.User = data
			} else if tmp == nil {
				it.User = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.EventUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Event")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateItemRequest(ctx context.Context, obj any) (api.UpdateItemRequest, error) {
	var it api.UpdateItemRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"item", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "item":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("item"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNItemRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItemRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
				if err != nil {
					var zeroVal *api.ItemRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.ItemRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
				if err != nil {
					var zeroVal *api.ItemRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.ItemRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.ItemRequest); ok {
				it.Item = data
			} else if tmp == nil {
				it.Item = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.ItemRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Item")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchRequest(ctx context.Context, obj any) (api.UpdateMatchRequest, error) {
	var it api.UpdateMatchRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"match", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "match":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("match"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchRequest); ok {
				it.Match = data
			} else if tmp == nil {
				it.Match = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchmakingTicketRequest(ctx context.Context, obj any) (api.UpdateMatchmakingTicketRequest, error) {
	var it api.UpdateMatchmakingTicketRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchmakingTicket", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchmakingTicket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingTicket"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchmakingTicketRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicketRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingTicketRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingTicketRequest); ok {
				it.MatchmakingTicket = data
			} else if tmp == nil {
				it.MatchmakingTicket = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingTicketRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchmakingUserRequest(ctx context.Context, obj any) (api.UpdateMatchmakingUserRequest, error) {
	var it api.UpdateMatchmakingUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchmakingUser", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchmakingUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchmakingUser"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.MatchmakingUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.MatchmakingUserRequest); ok {
				it.MatchmakingUser = data
			} else if tmp == nil {
				it.MatchmakingUser = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.MatchmakingUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Matchmaking")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateRecordRequest(ctx context.Context, obj any) (api.UpdateRecordRequest, error) {
	var it api.UpdateRecordRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"request", "record", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "request":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("request"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNRecordRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRecordRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal *api.RecordRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.RecordRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal *api.RecordRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.RecordRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.RecordRequest); ok {
				it.Request = data
			} else if tmp == nil {
				it.Request = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.RecordRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "record":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("record"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOUint642ᚖuint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal *uint64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *uint64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*uint64); ok {
				it.Record = data
			} else if tmp == nil {
				it.Record = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *uint64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Record")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTaskRequest(ctx context.Context, obj any) (api.UpdateTaskRequest, error) {
	var it api.UpdateTaskRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"task", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "task":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("task"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTaskRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTaskRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
				if err != nil {
					var zeroVal *api.TaskRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TaskRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
				if err != nil {
					var zeroVal *api.TaskRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TaskRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TaskRequest); ok {
				it.Task = data
			} else if tmp == nil {
				it.Task = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TaskRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Task")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTeamMemberRequest(ctx context.Context, obj any) (api.UpdateTeamMemberRequest, error) {
	var it api.UpdateTeamMemberRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"member", "data"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "member":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("member"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTeamMemberRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamMemberRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamMemberRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TeamMemberRequest); ok {
				it.Member = data
			} else if tmp == nil {
				it.Member = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamMemberRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTeamRequest(ctx context.Context, obj any) (api.UpdateTeamRequest, error) {
	var it api.UpdateTeamRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"team", "data", "score", "incrementScore"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "team":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("team"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *api.TeamRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TeamRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TeamRequest); ok {
				it.Team = data
			} else if tmp == nil {
				it.Team = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TeamRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "score":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOInt642ᚖint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int64); ok {
				it.Score = data
			} else if tmp == nil {
				it.Score = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "incrementScore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("incrementScore"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOBoolean2ᚖbool(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Team")
				if err != nil {
					var zeroVal *bool
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *bool
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*bool); ok {
				it.IncrementScore = data
			} else if tmp == nil {
				it.IncrementScore = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTournamentUserRequest(ctx context.Context, obj any) (api.UpdateTournamentUserRequest, error) {
	var it api.UpdateTournamentUserRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tournament", "data", "score", "incrementScore"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tournament":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tournament"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNTournamentUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUserRequest(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *api.TournamentUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TournamentUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *api.TournamentUserRequest
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *api.TournamentUserRequest
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*api.TournamentUserRequest); ok {
				it.Tournament = data
			} else if tmp == nil {
				it.Tournament = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/MorhafAlshibly/coanda/api.TournamentUserRequest`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Data = data
			} else if tmp == nil {
				it.Data = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "score":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOInt642ᚖint64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *int64
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *int64
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int64); ok {
				it.Score = data
			} else if tmp == nil {
				it.Score = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "incrementScore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("incrementScore"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOBoolean2ᚖbool(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Tournament")
				if err != nil {
					var zeroVal *bool
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *bool
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*bool); ok {
				it.IncrementScore = data
			} else if tmp == nil {
				it.IncrementScore = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookRequest(ctx context.Context, obj any) (api.WebhookRequest, error) {
	var it api.WebhookRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"uri", "method", "headers", "body"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "uri":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uri"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Webhook")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Uri = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "method":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("method"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Webhook")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal string
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Method = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "headers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("headers"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Webhook")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Headers = data
			} else if tmp == nil {
				it.Headers = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "body":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("body"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Common")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive0, category)
			}
			directive2 := func(ctx context.Context) (any, error) {
				category, err := ec.unmarshalOString2ᚖstring(ctx, "Webhook")
				if err != nil {
					var zeroVal *structpb.Struct
					return zeroVal, err
				}
				if ec.directives.Doc == nil {
					var zeroVal *structpb.Struct
					return zeroVal, errors.New("directive doc is not implemented")
				}
				return ec.directives.Doc(ctx, obj, directive1, category)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*structpb.Struct); ok {
				it.Body = data
			} else if tmp == nil {
				it.Body = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *google.golang.org/protobuf/types/known/structpb.Struct`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var addEventResultResponseImplementors = []string{"AddEventResultResponse"}

func (ec *executionContext) _AddEventResultResponse(ctx context.Context, sel ast.SelectionSet, obj *api.AddEventResultResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addEventResultResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddEventResultResponse")
		case "success":
			out.Values[i] = ec._AddEventResultResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AddEventResultResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var arenaImplementors = []string{"Arena"}

func (ec *executionContext) _Arena(ctx context.Context, sel ast.SelectionSet, obj *api.Arena) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, arenaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Arena")
		case "id":
			out.Values[i] = ec._Arena_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Arena_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minPlayers":
			out.Values[i] = ec._Arena_minPlayers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxPlayersPerTicket":
			out.Values[i] = ec._Arena_maxPlayersPerTicket(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxPlayers":
			out.Values[i] = ec._Arena_maxPlayers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._Arena_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Arena_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Arena_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var completeTaskResponseImplementors = []string{"CompleteTaskResponse"}

func (ec *executionContext) _CompleteTaskResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CompleteTaskResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, completeTaskResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompleteTaskResponse")
		case "success":
			out.Values[i] = ec._CompleteTaskResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CompleteTaskResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createArenaResponseImplementors = []string{"CreateArenaResponse"}

func (ec *executionContext) _CreateArenaResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateArenaResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createArenaResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateArenaResponse")
		case "success":
			out.Values[i] = ec._CreateArenaResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateArenaResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateArenaResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createEventResponseImplementors = []string{"CreateEventResponse"}

func (ec *executionContext) _CreateEventResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateEventResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createEventResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateEventResponse")
		case "success":
			out.Values[i] = ec._CreateEventResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateEventResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateEventResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createEventRoundResponseImplementors = []string{"CreateEventRoundResponse"}

func (ec *executionContext) _CreateEventRoundResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateEventRoundResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createEventRoundResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateEventRoundResponse")
		case "success":
			out.Values[i] = ec._CreateEventRoundResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateEventRoundResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateEventRoundResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createItemResponseImplementors = []string{"CreateItemResponse"}

func (ec *executionContext) _CreateItemResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateItemResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createItemResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateItemResponse")
		case "success":
			out.Values[i] = ec._CreateItemResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateItemResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createMatchmakingTicketResponseImplementors = []string{"CreateMatchmakingTicketResponse"}

func (ec *executionContext) _CreateMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateMatchmakingTicketResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createMatchmakingTicketResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateMatchmakingTicketResponse")
		case "success":
			out.Values[i] = ec._CreateMatchmakingTicketResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateMatchmakingTicketResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateMatchmakingTicketResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createMatchmakingUserResponseImplementors = []string{"CreateMatchmakingUserResponse"}

func (ec *executionContext) _CreateMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateMatchmakingUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createMatchmakingUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateMatchmakingUserResponse")
		case "success":
			out.Values[i] = ec._CreateMatchmakingUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateMatchmakingUserResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateMatchmakingUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createRecordResponseImplementors = []string{"CreateRecordResponse"}

func (ec *executionContext) _CreateRecordResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateRecordResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createRecordResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateRecordResponse")
		case "success":
			out.Values[i] = ec._CreateRecordResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateRecordResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateRecordResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createTaskResponseImplementors = []string{"CreateTaskResponse"}

func (ec *executionContext) _CreateTaskResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateTaskResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createTaskResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateTaskResponse")
		case "success":
			out.Values[i] = ec._CreateTaskResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateTaskResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createTeamResponseImplementors = []string{"CreateTeamResponse"}

func (ec *executionContext) _CreateTeamResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateTeamResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createTeamResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateTeamResponse")
		case "success":
			out.Values[i] = ec._CreateTeamResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateTeamResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateTeamResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createTournamentUserResponseImplementors = []string{"CreateTournamentUserResponse"}

func (ec *executionContext) _CreateTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.CreateTournamentUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createTournamentUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateTournamentUserResponse")
		case "success":
			out.Values[i] = ec._CreateTournamentUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "id":
			out.Values[i] = ec._CreateTournamentUserResponse_id(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CreateTournamentUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteMatchResponseImplementors = []string{"DeleteMatchResponse"}

func (ec *executionContext) _DeleteMatchResponse(ctx context.Context, sel ast.SelectionSet, obj *api.DeleteMatchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteMatchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteMatchResponse")
		case "success":
			out.Values[i] = ec._DeleteMatchResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteMatchResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteMatchmakingTicketResponseImplementors = []string{"DeleteMatchmakingTicketResponse"}

func (ec *executionContext) _DeleteMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, obj *api.DeleteMatchmakingTicketResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteMatchmakingTicketResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteMatchmakingTicketResponse")
		case "success":
			out.Values[i] = ec._DeleteMatchmakingTicketResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteMatchmakingTicketResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteMatchmakingUserResponseImplementors = []string{"DeleteMatchmakingUserResponse"}

func (ec *executionContext) _DeleteMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.DeleteMatchmakingUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteMatchmakingUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteMatchmakingUserResponse")
		case "success":
			out.Values[i] = ec._DeleteMatchmakingUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteMatchmakingUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteRecordResponseImplementors = []string{"DeleteRecordResponse"}

func (ec *executionContext) _DeleteRecordResponse(ctx context.Context, sel ast.SelectionSet, obj *api.DeleteRecordResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteRecordResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteRecordResponse")
		case "success":
			out.Values[i] = ec._DeleteRecordResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DeleteRecordResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var endMatchResponseImplementors = []string{"EndMatchResponse"}

func (ec *executionContext) _EndMatchResponse(ctx context.Context, sel ast.SelectionSet, obj *api.EndMatchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, endMatchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EndMatchResponse")
		case "success":
			out.Values[i] = ec._EndMatchResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EndMatchResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventImplementors = []string{"Event"}

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj *api.Event) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Event")
		case "id":
			out.Values[i] = ec._Event_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Event_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentRoundId":
			out.Values[i] = ec._Event_currentRoundId(ctx, field, obj)
		case "currentRoundName":
			out.Values[i] = ec._Event_currentRoundName(ctx, field, obj)
		case "data":
			out.Values[i] = ec._Event_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rounds":
			out.Values[i] = ec._Event_rounds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startedAt":
			out.Values[i] = ec._Event_startedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Event_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Event_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventResponseImplementors = []string{"EventResponse"}

func (ec *executionContext) _EventResponse(ctx context.Context, sel ast.SelectionSet, obj *api.EventResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventResponse")
		case "success":
			out.Values[i] = ec._EventResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EventResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventRoundImplementors = []string{"EventRound"}

func (ec *executionContext) _EventRound(ctx context.Context, sel ast.SelectionSet, obj *api.EventRound) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventRoundImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventRound")
		case "id":
			out.Values[i] = ec._EventRound_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventId":
			out.Values[i] = ec._EventRound_eventId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._EventRound_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scoring":
			out.Values[i] = ec._EventRound_scoring(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._EventRound_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endedAt":
			out.Values[i] = ec._EventRound_endedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._EventRound_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._EventRound_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventRoundUserImplementors = []string{"EventRoundUser"}

func (ec *executionContext) _EventRoundUser(ctx context.Context, sel ast.SelectionSet, obj *api.EventRoundUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventRoundUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventRoundUser")
		case "id":
			out.Values[i] = ec._EventRoundUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventUserId":
			out.Values[i] = ec._EventRoundUser_eventUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clientUserId":
			out.Values[i] = ec._EventRoundUser_clientUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventRoundId":
			out.Values[i] = ec._EventRoundUser_eventRoundId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "result":
			out.Values[i] = ec._EventRoundUser_result(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ranking":
			out.Values[i] = ec._EventRoundUser_ranking(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._EventRoundUser_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._EventRoundUser_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._EventRoundUser_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventUserImplementors = []string{"EventUser"}

func (ec *executionContext) _EventUser(ctx context.Context, sel ast.SelectionSet, obj *api.EventUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventUser")
		case "id":
			out.Values[i] = ec._EventUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventId":
			out.Values[i] = ec._EventUser_eventId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clientUserId":
			out.Values[i] = ec._EventUser_clientUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "score":
			out.Values[i] = ec._EventUser_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ranking":
			out.Values[i] = ec._EventUser_ranking(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._EventUser_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._EventUser_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._EventUser_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventUserResponseImplementors = []string{"EventUserResponse"}

func (ec *executionContext) _EventUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.EventUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventUserResponse")
		case "success":
			out.Values[i] = ec._EventUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EventUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getArenaResponseImplementors = []string{"GetArenaResponse"}

func (ec *executionContext) _GetArenaResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetArenaResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getArenaResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetArenaResponse")
		case "success":
			out.Values[i] = ec._GetArenaResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "arena":
			out.Values[i] = ec._GetArenaResponse_arena(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetArenaResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getArenasResponseImplementors = []string{"GetArenasResponse"}

func (ec *executionContext) _GetArenasResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetArenasResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getArenasResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetArenasResponse")
		case "success":
			out.Values[i] = ec._GetArenasResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "arenas":
			out.Values[i] = ec._GetArenasResponse_arenas(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getEventResponseImplementors = []string{"GetEventResponse"}

func (ec *executionContext) _GetEventResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetEventResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getEventResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetEventResponse")
		case "success":
			out.Values[i] = ec._GetEventResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "event":
			out.Values[i] = ec._GetEventResponse_event(ctx, field, obj)
		case "leaderboard":
			out.Values[i] = ec._GetEventResponse_leaderboard(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetEventResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getEventRoundResponseImplementors = []string{"GetEventRoundResponse"}

func (ec *executionContext) _GetEventRoundResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetEventRoundResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getEventRoundResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetEventRoundResponse")
		case "success":
			out.Values[i] = ec._GetEventRoundResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "round":
			out.Values[i] = ec._GetEventRoundResponse_round(ctx, field, obj)
		case "results":
			out.Values[i] = ec._GetEventRoundResponse_results(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetEventRoundResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getEventUserResponseImplementors = []string{"GetEventUserResponse"}

func (ec *executionContext) _GetEventUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetEventUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getEventUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetEventUserResponse")
		case "success":
			out.Values[i] = ec._GetEventUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			out.Values[i] = ec._GetEventUserResponse_user(ctx, field, obj)
		case "results":
			out.Values[i] = ec._GetEventUserResponse_results(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetEventUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getItemResponseImplementors = []string{"GetItemResponse"}

func (ec *executionContext) _GetItemResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetItemResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getItemResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetItemResponse")
		case "success":
			out.Values[i] = ec._GetItemResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "item":
			out.Values[i] = ec._GetItemResponse_item(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetItemResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getItemsResponseImplementors = []string{"GetItemsResponse"}

func (ec *executionContext) _GetItemsResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetItemsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getItemsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetItemsResponse")
		case "success":
			out.Values[i] = ec._GetItemsResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._GetItemsResponse_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMatchResponseImplementors = []string{"GetMatchResponse"}

func (ec *executionContext) _GetMatchResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetMatchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMatchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMatchResponse")
		case "success":
			out.Values[i] = ec._GetMatchResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "match":
			out.Values[i] = ec._GetMatchResponse_match(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMatchResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMatchesResponseImplementors = []string{"GetMatchesResponse"}

func (ec *executionContext) _GetMatchesResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetMatchesResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMatchesResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMatchesResponse")
		case "success":
			out.Values[i] = ec._GetMatchesResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matches":
			out.Values[i] = ec._GetMatchesResponse_matches(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMatchmakingTicketResponseImplementors = []string{"GetMatchmakingTicketResponse"}

func (ec *executionContext) _GetMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetMatchmakingTicketResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMatchmakingTicketResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMatchmakingTicketResponse")
		case "success":
			out.Values[i] = ec._GetMatchmakingTicketResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchmakingTicket":
			out.Values[i] = ec._GetMatchmakingTicketResponse_matchmakingTicket(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMatchmakingTicketResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMatchmakingTicketsResponseImplementors = []string{"GetMatchmakingTicketsResponse"}

func (ec *executionContext) _GetMatchmakingTicketsResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetMatchmakingTicketsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMatchmakingTicketsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMatchmakingTicketsResponse")
		case "success":
			out.Values[i] = ec._GetMatchmakingTicketsResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchmakingTickets":
			out.Values[i] = ec._GetMatchmakingTicketsResponse_matchmakingTickets(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMatchmakingTicketsResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMatchmakingUserResponseImplementors = []string{"GetMatchmakingUserResponse"}

func (ec *executionContext) _GetMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetMatchmakingUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMatchmakingUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMatchmakingUserResponse")
		case "success":
			out.Values[i] = ec._GetMatchmakingUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchmakingUser":
			out.Values[i] = ec._GetMatchmakingUserResponse_matchmakingUser(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMatchmakingUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMatchmakingUsersResponseImplementors = []string{"GetMatchmakingUsersResponse"}

func (ec *executionContext) _GetMatchmakingUsersResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetMatchmakingUsersResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMatchmakingUsersResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMatchmakingUsersResponse")
		case "success":
			out.Values[i] = ec._GetMatchmakingUsersResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchmakingUsers":
			out.Values[i] = ec._GetMatchmakingUsersResponse_matchmakingUsers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getRecordResponseImplementors = []string{"GetRecordResponse"}

func (ec *executionContext) _GetRecordResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetRecordResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getRecordResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetRecordResponse")
		case "success":
			out.Values[i] = ec._GetRecordResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "record":
			out.Values[i] = ec._GetRecordResponse_record(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetRecordResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getRecordsResponseImplementors = []string{"GetRecordsResponse"}

func (ec *executionContext) _GetRecordsResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetRecordsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getRecordsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetRecordsResponse")
		case "success":
			out.Values[i] = ec._GetRecordsResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "records":
			out.Values[i] = ec._GetRecordsResponse_records(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetRecordsResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTaskResponseImplementors = []string{"GetTaskResponse"}

func (ec *executionContext) _GetTaskResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTaskResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTaskResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTaskResponse")
		case "success":
			out.Values[i] = ec._GetTaskResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "task":
			out.Values[i] = ec._GetTaskResponse_task(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetTaskResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTasksResponseImplementors = []string{"GetTasksResponse"}

func (ec *executionContext) _GetTasksResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTasksResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTasksResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTasksResponse")
		case "success":
			out.Values[i] = ec._GetTasksResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._GetTasksResponse_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTeamMemberResponseImplementors = []string{"GetTeamMemberResponse"}

func (ec *executionContext) _GetTeamMemberResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTeamMemberResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTeamMemberResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTeamMemberResponse")
		case "success":
			out.Values[i] = ec._GetTeamMemberResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "member":
			out.Values[i] = ec._GetTeamMemberResponse_member(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetTeamMemberResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTeamResponseImplementors = []string{"GetTeamResponse"}

func (ec *executionContext) _GetTeamResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTeamResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTeamResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTeamResponse")
		case "success":
			out.Values[i] = ec._GetTeamResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "team":
			out.Values[i] = ec._GetTeamResponse_team(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetTeamResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTeamsResponseImplementors = []string{"GetTeamsResponse"}

func (ec *executionContext) _GetTeamsResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTeamsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTeamsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTeamsResponse")
		case "success":
			out.Values[i] = ec._GetTeamsResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teams":
			out.Values[i] = ec._GetTeamsResponse_teams(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTournamentUserResponseImplementors = []string{"GetTournamentUserResponse"}

func (ec *executionContext) _GetTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTournamentUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTournamentUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTournamentUserResponse")
		case "success":
			out.Values[i] = ec._GetTournamentUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tournamentUser":
			out.Values[i] = ec._GetTournamentUserResponse_tournamentUser(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetTournamentUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getTournamentUsersResponseImplementors = []string{"GetTournamentUsersResponse"}

func (ec *executionContext) _GetTournamentUsersResponse(ctx context.Context, sel ast.SelectionSet, obj *api.GetTournamentUsersResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getTournamentUsersResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetTournamentUsersResponse")
		case "success":
			out.Values[i] = ec._GetTournamentUsersResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tournamentUsers":
			out.Values[i] = ec._GetTournamentUsersResponse_tournamentUsers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetTournamentUsersResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemImplementors = []string{"Item"}

func (ec *executionContext) _Item(ctx context.Context, sel ast.SelectionSet, obj *api.Item) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Item")
		case "id":
			out.Values[i] = ec._Item_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Item_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._Item_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expiresAt":
			out.Values[i] = ec._Item_expiresAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Item_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Item_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemResponseImplementors = []string{"ItemResponse"}

func (ec *executionContext) _ItemResponse(ctx context.Context, sel ast.SelectionSet, obj *api.ItemResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ItemResponse")
		case "success":
			out.Values[i] = ec._ItemResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ItemResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var joinTeamResponseImplementors = []string{"JoinTeamResponse"}

func (ec *executionContext) _JoinTeamResponse(ctx context.Context, sel ast.SelectionSet, obj *api.JoinTeamResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, joinTeamResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JoinTeamResponse")
		case "success":
			out.Values[i] = ec._JoinTeamResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JoinTeamResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var leaveTeamResponseImplementors = []string{"LeaveTeamResponse"}

func (ec *executionContext) _LeaveTeamResponse(ctx context.Context, sel ast.SelectionSet, obj *api.LeaveTeamResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, leaveTeamResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LeaveTeamResponse")
		case "success":
			out.Values[i] = ec._LeaveTeamResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LeaveTeamResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchImplementors = []string{"Match"}

func (ec *executionContext) _Match(ctx context.Context, sel ast.SelectionSet, obj *api.Match) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Match")
		case "id":
			out.Values[i] = ec._Match_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "arena":
			out.Values[i] = ec._Match_arena(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tickets":
			out.Values[i] = ec._Match_tickets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "privateServerId":
			out.Values[i] = ec._Match_privateServerId(ctx, field, obj)
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "data":
			out.Values[i] = ec._Match_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lockedAt":
			out.Values[i] = ec._Match_lockedAt(ctx, field, obj)
		case "startedAt":
			out.Values[i] = ec._Match_startedAt(ctx, field, obj)
		case "endedAt":
			out.Values[i] = ec._Match_endedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Match_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Match_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchmakingTicketImplementors = []string{"MatchmakingTicket"}

func (ec *executionContext) _MatchmakingTicket(ctx context.Context, sel ast.SelectionSet, obj *api.MatchmakingTicket) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchmakingTicketImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchmakingTicket")
		case "id":
			out.Values[i] = ec._MatchmakingTicket_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchmakingUsers":
			out.Values[i] = ec._MatchmakingTicket_matchmakingUsers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "arenas":
			out.Values[i] = ec._MatchmakingTicket_arenas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchId":
			out.Values[i] = ec._MatchmakingTicket_matchId(ctx, field, obj)
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchmakingTicket_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "data":
			out.Values[i] = ec._MatchmakingTicket_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._MatchmakingTicket_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._MatchmakingTicket_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchmakingUserImplementors = []string{"MatchmakingUser"}

func (ec *executionContext) _MatchmakingUser(ctx context.Context, sel ast.SelectionSet, obj *api.MatchmakingUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchmakingUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchmakingUser")
		case "id":
			out.Values[i] = ec._MatchmakingUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clientUserId":
			out.Values[i] = ec._MatchmakingUser_clientUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._MatchmakingUser_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "elo":
			out.Values[i] = ec._MatchmakingUser_elo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._MatchmakingUser_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._MatchmakingUser_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "CreateEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateEventRound":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateEventRound(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateEventRound":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateEventRound(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateEventUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateEventUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteEventUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteEventUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "AddEventResult":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_AddEventResult(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "RemoveEventResult":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_RemoveEventResult(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateArena":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateArena(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateArena":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateArena(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateMatchmakingUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateMatchmakingUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateMatchmakingUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateMatchmakingUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteMatchmakingUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteMatchmakingUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateMatchmakingTicket":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateMatchmakingTicket(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateMatchmakingTicket":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateMatchmakingTicket(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteMatchmakingTicket":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteMatchmakingTicket(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "StartMatch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_StartMatch(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "EndMatch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_EndMatch(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateMatch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateMatch(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "SetMatchPrivateServer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_SetMatchPrivateServer(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteMatch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteMatch(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateRecord":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateRecord(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateRecord":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateRecord(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteRecord":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteRecord(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CompleteTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CompleteTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "JoinTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_JoinTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "LeaveTeam":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_LeaveTeam(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateTeamMember":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateTeamMember(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreateTournamentUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateTournamentUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UpdateTournamentUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateTournamentUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "DeleteTournamentUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteTournamentUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Webhook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Webhook(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "GetEvent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetEvent(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetEventRound":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetEventRound(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetEventUser":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetEventUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetItem":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetItem(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetItems":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetItems(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetArena":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetArena(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetArenas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetArenas(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetMatchmakingUser":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetMatchmakingUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetMatchmakingUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetMatchmakingUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetMatchmakingTicket":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetMatchmakingTicket(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetMatchmakingTickets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetMatchmakingTickets(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetMatch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetMatch(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetMatches":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetMatches(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetRecord":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetRecord(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetRecords":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetRecords(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTask":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTask(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTasks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTasks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTeam":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTeam(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTeams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTeams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTeamMember":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTeamMember(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "SearchTeams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_SearchTeams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTournamentUser":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTournamentUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GetTournamentUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GetTournamentUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var recordImplementors = []string{"Record"}

func (ec *executionContext) _Record(ctx context.Context, sel ast.SelectionSet, obj *api.Record) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, recordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Record")
		case "id":
			out.Values[i] = ec._Record_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Record_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._Record_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "record":
			out.Values[i] = ec._Record_record(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ranking":
			out.Values[i] = ec._Record_ranking(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._Record_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Record_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Record_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var removeEventResultResponseImplementors = []string{"RemoveEventResultResponse"}

func (ec *executionContext) _RemoveEventResultResponse(ctx context.Context, sel ast.SelectionSet, obj *api.RemoveEventResultResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, removeEventResultResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RemoveEventResultResponse")
		case "success":
			out.Values[i] = ec._RemoveEventResultResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RemoveEventResultResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchTeamsResponseImplementors = []string{"SearchTeamsResponse"}

func (ec *executionContext) _SearchTeamsResponse(ctx context.Context, sel ast.SelectionSet, obj *api.SearchTeamsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchTeamsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchTeamsResponse")
		case "success":
			out.Values[i] = ec._SearchTeamsResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "teams":
			out.Values[i] = ec._SearchTeamsResponse_teams(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SearchTeamsResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var setMatchPrivateServerResponseImplementors = []string{"SetMatchPrivateServerResponse"}

func (ec *executionContext) _SetMatchPrivateServerResponse(ctx context.Context, sel ast.SelectionSet, obj *api.SetMatchPrivateServerResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setMatchPrivateServerResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetMatchPrivateServerResponse")
		case "success":
			out.Values[i] = ec._SetMatchPrivateServerResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "privateServerId":
			out.Values[i] = ec._SetMatchPrivateServerResponse_privateServerId(ctx, field, obj)
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SetMatchPrivateServerResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var startMatchResponseImplementors = []string{"StartMatchResponse"}

func (ec *executionContext) _StartMatchResponse(ctx context.Context, sel ast.SelectionSet, obj *api.StartMatchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, startMatchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StartMatchResponse")
		case "success":
			out.Values[i] = ec._StartMatchResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StartMatchResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskImplementors = []string{"Task"}

func (ec *executionContext) _Task(ctx context.Context, sel ast.SelectionSet, obj *api.Task) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Task")
		case "id":
			out.Values[i] = ec._Task_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Task_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._Task_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expiresAt":
			out.Values[i] = ec._Task_expiresAt(ctx, field, obj)
		case "completedAt":
			out.Values[i] = ec._Task_completedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Task_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Task_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskResponseImplementors = []string{"TaskResponse"}

func (ec *executionContext) _TaskResponse(ctx context.Context, sel ast.SelectionSet, obj *api.TaskResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskResponse")
		case "success":
			out.Values[i] = ec._TaskResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamImplementors = []string{"Team"}

func (ec *executionContext) _Team(ctx context.Context, sel ast.SelectionSet, obj *api.Team) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Team")
		case "id":
			out.Values[i] = ec._Team_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Team_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "score":
			out.Values[i] = ec._Team_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ranking":
			out.Values[i] = ec._Team_ranking(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "members":
			out.Values[i] = ec._Team_members(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._Team_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Team_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Team_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamMemberImplementors = []string{"TeamMember"}

func (ec *executionContext) _TeamMember(ctx context.Context, sel ast.SelectionSet, obj *api.TeamMember) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamMemberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamMember")
		case "id":
			out.Values[i] = ec._TeamMember_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._TeamMember_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamId":
			out.Values[i] = ec._TeamMember_teamId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._TeamMember_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "joinedAt":
			out.Values[i] = ec._TeamMember_joinedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._TeamMember_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teamResponseImplementors = []string{"TeamResponse"}

func (ec *executionContext) _TeamResponse(ctx context.Context, sel ast.SelectionSet, obj *api.TeamResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamResponse")
		case "success":
			out.Values[i] = ec._TeamResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tournamentUserImplementors = []string{"TournamentUser"}

func (ec *executionContext) _TournamentUser(ctx context.Context, sel ast.SelectionSet, obj *api.TournamentUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tournamentUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TournamentUser")
		case "id":
			out.Values[i] = ec._TournamentUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tournament":
			out.Values[i] = ec._TournamentUser_tournament(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._TournamentUser_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "interval":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TournamentUser_interval(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "score":
			out.Values[i] = ec._TournamentUser_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ranking":
			out.Values[i] = ec._TournamentUser_ranking(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "data":
			out.Values[i] = ec._TournamentUser_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tournamentStartedAt":
			out.Values[i] = ec._TournamentUser_tournamentStartedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._TournamentUser_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._TournamentUser_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tournamentUserResponseImplementors = []string{"TournamentUserResponse"}

func (ec *executionContext) _TournamentUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.TournamentUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tournamentUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TournamentUserResponse")
		case "success":
			out.Values[i] = ec._TournamentUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TournamentUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateArenaResponseImplementors = []string{"UpdateArenaResponse"}

func (ec *executionContext) _UpdateArenaResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateArenaResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateArenaResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateArenaResponse")
		case "success":
			out.Values[i] = ec._UpdateArenaResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateArenaResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateEventResponseImplementors = []string{"UpdateEventResponse"}

func (ec *executionContext) _UpdateEventResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateEventResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateEventResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateEventResponse")
		case "success":
			out.Values[i] = ec._UpdateEventResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateEventResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateEventRoundResponseImplementors = []string{"UpdateEventRoundResponse"}

func (ec *executionContext) _UpdateEventRoundResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateEventRoundResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateEventRoundResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateEventRoundResponse")
		case "success":
			out.Values[i] = ec._UpdateEventRoundResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateEventRoundResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateEventUserResponseImplementors = []string{"UpdateEventUserResponse"}

func (ec *executionContext) _UpdateEventUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateEventUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateEventUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateEventUserResponse")
		case "success":
			out.Values[i] = ec._UpdateEventUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateEventUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateItemResponseImplementors = []string{"UpdateItemResponse"}

func (ec *executionContext) _UpdateItemResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateItemResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateItemResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateItemResponse")
		case "success":
			out.Values[i] = ec._UpdateItemResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateItemResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateMatchResponseImplementors = []string{"UpdateMatchResponse"}

func (ec *executionContext) _UpdateMatchResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateMatchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateMatchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateMatchResponse")
		case "success":
			out.Values[i] = ec._UpdateMatchResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateMatchResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateMatchmakingTicketResponseImplementors = []string{"UpdateMatchmakingTicketResponse"}

func (ec *executionContext) _UpdateMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateMatchmakingTicketResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateMatchmakingTicketResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateMatchmakingTicketResponse")
		case "success":
			out.Values[i] = ec._UpdateMatchmakingTicketResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateMatchmakingTicketResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateMatchmakingUserResponseImplementors = []string{"UpdateMatchmakingUserResponse"}

func (ec *executionContext) _UpdateMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateMatchmakingUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateMatchmakingUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateMatchmakingUserResponse")
		case "success":
			out.Values[i] = ec._UpdateMatchmakingUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateMatchmakingUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateRecordResponseImplementors = []string{"UpdateRecordResponse"}

func (ec *executionContext) _UpdateRecordResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateRecordResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateRecordResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateRecordResponse")
		case "success":
			out.Values[i] = ec._UpdateRecordResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateRecordResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTaskResponseImplementors = []string{"UpdateTaskResponse"}

func (ec *executionContext) _UpdateTaskResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateTaskResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTaskResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTaskResponse")
		case "success":
			out.Values[i] = ec._UpdateTaskResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateTaskResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTeamMemberResponseImplementors = []string{"UpdateTeamMemberResponse"}

func (ec *executionContext) _UpdateTeamMemberResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateTeamMemberResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTeamMemberResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTeamMemberResponse")
		case "success":
			out.Values[i] = ec._UpdateTeamMemberResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateTeamMemberResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTeamResponseImplementors = []string{"UpdateTeamResponse"}

func (ec *executionContext) _UpdateTeamResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateTeamResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTeamResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTeamResponse")
		case "success":
			out.Values[i] = ec._UpdateTeamResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateTeamResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTournamentUserResponseImplementors = []string{"UpdateTournamentUserResponse"}

func (ec *executionContext) _UpdateTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, obj *api.UpdateTournamentUserResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTournamentUserResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTournamentUserResponse")
		case "success":
			out.Values[i] = ec._UpdateTournamentUserResponse_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UpdateTournamentUserResponse_error(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookResponseImplementors = []string{"WebhookResponse"}

func (ec *executionContext) _WebhookResponse(ctx context.Context, sel ast.SelectionSet, obj *api.WebhookResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WebhookResponse")
		case "status":
			out.Values[i] = ec._WebhookResponse_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "headers":
			out.Values[i] = ec._WebhookResponse_headers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "body":
			out.Values[i] = ec._WebhookResponse_body(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddEventResultError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐAddEventResultError(ctx context.Context, v any) (model.AddEventResultError, error) {
	var res model.AddEventResultError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddEventResultError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐAddEventResultError(ctx context.Context, sel ast.SelectionSet, v model.AddEventResultError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAddEventResultResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐAddEventResultResponse(ctx context.Context, sel ast.SelectionSet, v api.AddEventResultResponse) graphql.Marshaler {
	return ec._AddEventResultResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNAddEventResultResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐAddEventResultResponse(ctx context.Context, sel ast.SelectionSet, v *api.AddEventResultResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AddEventResultResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNArena2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArena(ctx context.Context, sel ast.SelectionSet, v []*api.Arena) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOArena2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArena(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNArena2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArena(ctx context.Context, sel ast.SelectionSet, v *api.Arena) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Arena(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArenaRequest2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArenaRequest(ctx context.Context, v any) ([]*api.ArenaRequest, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*api.ArenaRequest, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOArenaRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArenaRequest(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNArenaRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArenaRequest(ctx context.Context, v any) (*api.ArenaRequest, error) {
	res, err := ec.unmarshalInputArenaRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCompleteTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCompleteTaskError(ctx context.Context, v any) (model.CompleteTaskError, error) {
	var res model.CompleteTaskError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCompleteTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCompleteTaskError(ctx context.Context, sel ast.SelectionSet, v model.CompleteTaskError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCompleteTaskResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCompleteTaskResponse(ctx context.Context, sel ast.SelectionSet, v api.CompleteTaskResponse) graphql.Marshaler {
	return ec._CompleteTaskResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompleteTaskResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCompleteTaskResponse(ctx context.Context, sel ast.SelectionSet, v *api.CompleteTaskResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CompleteTaskResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateArenaError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateArenaError(ctx context.Context, v any) (model.CreateArenaError, error) {
	var res model.CreateArenaError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateArenaError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateArenaError(ctx context.Context, sel ast.SelectionSet, v model.CreateArenaError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateArenaResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateArenaResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateArenaResponse) graphql.Marshaler {
	return ec._CreateArenaResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateArenaResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateArenaResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateArenaResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateArenaResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateEventError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateEventError(ctx context.Context, v any) (model.CreateEventError, error) {
	var res model.CreateEventError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateEventError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateEventError(ctx context.Context, sel ast.SelectionSet, v model.CreateEventError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateEventResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateEventResponse) graphql.Marshaler {
	return ec._CreateEventResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateEventResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateEventResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateEventResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateEventRound2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRound(ctx context.Context, v any) ([]*api.CreateEventRound, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*api.CreateEventRound, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOCreateEventRound2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRound(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateEventRound2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRound(ctx context.Context, v any) (*api.CreateEventRound, error) {
	res, err := ec.unmarshalInputCreateEventRound(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateEventRoundError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateEventRoundError(ctx context.Context, v any) (model.CreateEventRoundError, error) {
	var res model.CreateEventRoundError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateEventRoundError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateEventRoundError(ctx context.Context, sel ast.SelectionSet, v model.CreateEventRoundError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateEventRoundResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRoundResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateEventRoundResponse) graphql.Marshaler {
	return ec._CreateEventRoundResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateEventRoundResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRoundResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateEventRoundResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateEventRoundResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateItemError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateItemError(ctx context.Context, v any) (model.CreateItemError, error) {
	var res model.CreateItemError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateItemError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateItemError(ctx context.Context, sel ast.SelectionSet, v model.CreateItemError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateItemResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateItemResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateItemResponse) graphql.Marshaler {
	return ec._CreateItemResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateItemResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateItemResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateItemResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateItemResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateMatchmakingTicketError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateMatchmakingTicketError(ctx context.Context, v any) (model.CreateMatchmakingTicketError, error) {
	var res model.CreateMatchmakingTicketError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateMatchmakingTicketError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateMatchmakingTicketError(ctx context.Context, sel ast.SelectionSet, v model.CreateMatchmakingTicketError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateMatchmakingTicketResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateMatchmakingTicketResponse) graphql.Marshaler {
	return ec._CreateMatchmakingTicketResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateMatchmakingTicketResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateMatchmakingTicketResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateMatchmakingTicketResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateMatchmakingUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateMatchmakingUserError(ctx context.Context, v any) (model.CreateMatchmakingUserError, error) {
	var res model.CreateMatchmakingUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateMatchmakingUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateMatchmakingUserError(ctx context.Context, sel ast.SelectionSet, v model.CreateMatchmakingUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateMatchmakingUserResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateMatchmakingUserResponse) graphql.Marshaler {
	return ec._CreateMatchmakingUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateMatchmakingUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateMatchmakingUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateMatchmakingUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateRecordError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateRecordError(ctx context.Context, v any) (model.CreateRecordError, error) {
	var res model.CreateRecordError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateRecordError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateRecordError(ctx context.Context, sel ast.SelectionSet, v model.CreateRecordError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateRecordResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateRecordResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateRecordResponse) graphql.Marshaler {
	return ec._CreateRecordResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateRecordResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateRecordResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateRecordResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateRecordResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateTaskError(ctx context.Context, v any) (model.CreateTaskError, error) {
	var res model.CreateTaskError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateTaskError(ctx context.Context, sel ast.SelectionSet, v model.CreateTaskError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateTaskResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTaskResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateTaskResponse) graphql.Marshaler {
	return ec._CreateTaskResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateTaskResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTaskResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateTaskResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateTaskResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateTeamError(ctx context.Context, v any) (model.CreateTeamError, error) {
	var res model.CreateTeamError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateTeamError(ctx context.Context, sel ast.SelectionSet, v model.CreateTeamError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateTeamResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTeamResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateTeamResponse) graphql.Marshaler {
	return ec._CreateTeamResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateTeamResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTeamResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateTeamResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateTeamResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateTournamentUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateTournamentUserError(ctx context.Context, v any) (model.CreateTournamentUserError, error) {
	var res model.CreateTournamentUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateTournamentUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐCreateTournamentUserError(ctx context.Context, sel ast.SelectionSet, v model.CreateTournamentUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreateTournamentUserResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v api.CreateTournamentUserResponse) graphql.Marshaler {
	return ec._CreateTournamentUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateTournamentUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.CreateTournamentUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateTournamentUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐDeleteMatchError(ctx context.Context, v any) (model.DeleteMatchError, error) {
	var res model.DeleteMatchError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐDeleteMatchError(ctx context.Context, sel ast.SelectionSet, v model.DeleteMatchError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDeleteMatchResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐDeleteMatchResponse(ctx context.Context, sel ast.SelectionSet, v api.DeleteMatchResponse) graphql.Marshaler {
	return ec._DeleteMatchResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteMatchResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐDeleteMatchResponse(ctx context.Context, sel ast.SelectionSet, v *api.DeleteMatchResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteMatchResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteMatchmakingTicketError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐDeleteMatchmakingTicketError(ctx context.Context, v any) (model.DeleteMatchmakingTicketError, error) {
	var res model.DeleteMatchmakingTicketError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteMatchmakingTicketError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐDeleteMatchmakingTicketError(ctx context.Context, sel ast.SelectionSet, v model.DeleteMatchmakingTicketError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDeleteMatchmakingTicketResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐDeleteMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v api.DeleteMatchmakingTicketResponse) graphql.Marshaler {
	return ec._DeleteMatchmakingTicketResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteMatchmakingTicketResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐDeleteMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v *api.DeleteMatchmakingTicketResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteMatchmakingTicketResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteMatchmakingUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐDeleteMatchmakingUserError(ctx context.Context, v any) (model.DeleteMatchmakingUserError, error) {
	var res model.DeleteMatchmakingUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteMatchmakingUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐDeleteMatchmakingUserError(ctx context.Context, sel ast.SelectionSet, v model.DeleteMatchmakingUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDeleteMatchmakingUserResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐDeleteMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v api.DeleteMatchmakingUserResponse) graphql.Marshaler {
	return ec._DeleteMatchmakingUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteMatchmakingUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐDeleteMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.DeleteMatchmakingUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteMatchmakingUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteRecordError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐDeleteRecordError(ctx context.Context, v any) (model.DeleteRecordError, error) {
	var res model.DeleteRecordError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteRecordError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐDeleteRecordError(ctx context.Context, sel ast.SelectionSet, v model.DeleteRecordError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDeleteRecordResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐDeleteRecordResponse(ctx context.Context, sel ast.SelectionSet, v api.DeleteRecordResponse) graphql.Marshaler {
	return ec._DeleteRecordResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteRecordResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐDeleteRecordResponse(ctx context.Context, sel ast.SelectionSet, v *api.DeleteRecordResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteRecordResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEndMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐEndMatchError(ctx context.Context, v any) (model.EndMatchError, error) {
	var res model.EndMatchError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEndMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐEndMatchError(ctx context.Context, sel ast.SelectionSet, v model.EndMatchError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEndMatchResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEndMatchResponse(ctx context.Context, sel ast.SelectionSet, v api.EndMatchResponse) graphql.Marshaler {
	return ec._EndMatchResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNEndMatchResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEndMatchResponse(ctx context.Context, sel ast.SelectionSet, v *api.EndMatchResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EndMatchResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐEventError(ctx context.Context, v any) (model.EventError, error) {
	var res model.EventError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐEventError(ctx context.Context, sel ast.SelectionSet, v model.EventError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRequest(ctx context.Context, v any) (*api.EventRequest, error) {
	res, err := ec.unmarshalInputEventRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventResponse(ctx context.Context, sel ast.SelectionSet, v api.EventResponse) graphql.Marshaler {
	return ec._EventResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventResponse(ctx context.Context, sel ast.SelectionSet, v *api.EventResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNEventRound2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRound(ctx context.Context, sel ast.SelectionSet, v []*api.EventRound) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEventRound2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRound(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNEventRoundRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRoundRequest(ctx context.Context, v any) (*api.EventRoundRequest, error) {
	res, err := ec.unmarshalInputEventRoundRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventRoundUser2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRoundUser(ctx context.Context, sel ast.SelectionSet, v []*api.EventRoundUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEventRoundUser2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRoundUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNEventUser2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUser(ctx context.Context, sel ast.SelectionSet, v []*api.EventUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEventUser2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNEventUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐEventUserError(ctx context.Context, v any) (model.EventUserError, error) {
	var res model.EventUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐEventUserError(ctx context.Context, sel ast.SelectionSet, v model.EventUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUserRequest(ctx context.Context, v any) (*api.EventUserRequest, error) {
	res, err := ec.unmarshalInputEventUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventUserResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUserResponse(ctx context.Context, sel ast.SelectionSet, v api.EventUserResponse) graphql.Marshaler {
	return ec._EventUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.EventUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetArenaError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetArenaError(ctx context.Context, v any) (model.GetArenaError, error) {
	var res model.GetArenaError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetArenaError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetArenaError(ctx context.Context, sel ast.SelectionSet, v model.GetArenaError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetArenaResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetArenaResponse(ctx context.Context, sel ast.SelectionSet, v api.GetArenaResponse) graphql.Marshaler {
	return ec._GetArenaResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetArenaResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetArenaResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetArenaResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetArenaResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetArenasResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetArenasResponse(ctx context.Context, sel ast.SelectionSet, v api.GetArenasResponse) graphql.Marshaler {
	return ec._GetArenasResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetArenasResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetArenasResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetArenasResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetArenasResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetEventError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetEventError(ctx context.Context, v any) (model.GetEventError, error) {
	var res model.GetEventError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetEventError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetEventError(ctx context.Context, sel ast.SelectionSet, v model.GetEventError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetEventResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventResponse(ctx context.Context, sel ast.SelectionSet, v api.GetEventResponse) graphql.Marshaler {
	return ec._GetEventResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetEventResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetEventResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetEventResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetEventRoundError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetEventRoundError(ctx context.Context, v any) (model.GetEventRoundError, error) {
	var res model.GetEventRoundError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetEventRoundError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetEventRoundError(ctx context.Context, sel ast.SelectionSet, v model.GetEventRoundError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetEventRoundResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventRoundResponse(ctx context.Context, sel ast.SelectionSet, v api.GetEventRoundResponse) graphql.Marshaler {
	return ec._GetEventRoundResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetEventRoundResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventRoundResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetEventRoundResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetEventRoundResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetEventUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetEventUserError(ctx context.Context, v any) (model.GetEventUserError, error) {
	var res model.GetEventUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetEventUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetEventUserError(ctx context.Context, sel ast.SelectionSet, v model.GetEventUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetEventUserResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventUserResponse(ctx context.Context, sel ast.SelectionSet, v api.GetEventUserResponse) graphql.Marshaler {
	return ec._GetEventUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetEventUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetEventUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetEventUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetItemError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetItemError(ctx context.Context, v any) (model.GetItemError, error) {
	var res model.GetItemError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetItemError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetItemError(ctx context.Context, sel ast.SelectionSet, v model.GetItemError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetItemResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetItemResponse(ctx context.Context, sel ast.SelectionSet, v api.GetItemResponse) graphql.Marshaler {
	return ec._GetItemResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetItemResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetItemResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetItemResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetItemResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetItemsResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetItemsResponse(ctx context.Context, sel ast.SelectionSet, v api.GetItemsResponse) graphql.Marshaler {
	return ec._GetItemsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetItemsResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetItemsResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetItemsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetItemsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetMatchError(ctx context.Context, v any) (model.GetMatchError, error) {
	var res model.GetMatchError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetMatchError(ctx context.Context, sel ast.SelectionSet, v model.GetMatchError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetMatchResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchResponse(ctx context.Context, sel ast.SelectionSet, v api.GetMatchResponse) graphql.Marshaler {
	return ec._GetMatchResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMatchResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetMatchResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMatchResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetMatchesResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchesResponse(ctx context.Context, sel ast.SelectionSet, v api.GetMatchesResponse) graphql.Marshaler {
	return ec._GetMatchesResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMatchesResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchesResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetMatchesResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMatchesResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetMatchmakingTicketError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetMatchmakingTicketError(ctx context.Context, v any) (model.GetMatchmakingTicketError, error) {
	var res model.GetMatchmakingTicketError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetMatchmakingTicketError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetMatchmakingTicketError(ctx context.Context, sel ast.SelectionSet, v model.GetMatchmakingTicketError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetMatchmakingTicketResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v api.GetMatchmakingTicketResponse) graphql.Marshaler {
	return ec._GetMatchmakingTicketResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMatchmakingTicketResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetMatchmakingTicketResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMatchmakingTicketResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetMatchmakingTicketsError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetMatchmakingTicketsError(ctx context.Context, v any) (model.GetMatchmakingTicketsError, error) {
	var res model.GetMatchmakingTicketsError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetMatchmakingTicketsError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetMatchmakingTicketsError(ctx context.Context, sel ast.SelectionSet, v model.GetMatchmakingTicketsError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetMatchmakingTicketsResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingTicketsResponse(ctx context.Context, sel ast.SelectionSet, v api.GetMatchmakingTicketsResponse) graphql.Marshaler {
	return ec._GetMatchmakingTicketsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMatchmakingTicketsResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingTicketsResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetMatchmakingTicketsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMatchmakingTicketsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetMatchmakingUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetMatchmakingUserError(ctx context.Context, v any) (model.GetMatchmakingUserError, error) {
	var res model.GetMatchmakingUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetMatchmakingUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetMatchmakingUserError(ctx context.Context, sel ast.SelectionSet, v model.GetMatchmakingUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetMatchmakingUserResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v api.GetMatchmakingUserResponse) graphql.Marshaler {
	return ec._GetMatchmakingUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMatchmakingUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetMatchmakingUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMatchmakingUserResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetMatchmakingUsersResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingUsersResponse(ctx context.Context, sel ast.SelectionSet, v api.GetMatchmakingUsersResponse) graphql.Marshaler {
	return ec._GetMatchmakingUsersResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMatchmakingUsersResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingUsersResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetMatchmakingUsersResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMatchmakingUsersResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetRecordError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetRecordError(ctx context.Context, v any) (model.GetRecordError, error) {
	var res model.GetRecordError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetRecordError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetRecordError(ctx context.Context, sel ast.SelectionSet, v model.GetRecordError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetRecordResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetRecordResponse(ctx context.Context, sel ast.SelectionSet, v api.GetRecordResponse) graphql.Marshaler {
	return ec._GetRecordResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetRecordResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetRecordResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetRecordResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetRecordResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetRecordsError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetRecordsError(ctx context.Context, v any) (model.GetRecordsError, error) {
	var res model.GetRecordsError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetRecordsError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetRecordsError(ctx context.Context, sel ast.SelectionSet, v model.GetRecordsError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetRecordsResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetRecordsResponse(ctx context.Context, sel ast.SelectionSet, v api.GetRecordsResponse) graphql.Marshaler {
	return ec._GetRecordsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetRecordsResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetRecordsResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetRecordsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetRecordsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTaskError(ctx context.Context, v any) (model.GetTaskError, error) {
	var res model.GetTaskError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTaskError(ctx context.Context, sel ast.SelectionSet, v model.GetTaskError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetTaskResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTaskResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTaskResponse) graphql.Marshaler {
	return ec._GetTaskResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTaskResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTaskResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTaskResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTaskResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetTasksResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTasksResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTasksResponse) graphql.Marshaler {
	return ec._GetTasksResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTasksResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTasksResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTasksResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTasksResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTeamError(ctx context.Context, v any) (model.GetTeamError, error) {
	var res model.GetTeamError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTeamError(ctx context.Context, sel ast.SelectionSet, v model.GetTeamError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGetTeamMemberError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTeamMemberError(ctx context.Context, v any) (model.GetTeamMemberError, error) {
	var res model.GetTeamMemberError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetTeamMemberError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTeamMemberError(ctx context.Context, sel ast.SelectionSet, v model.GetTeamMemberError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetTeamMemberResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamMemberResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTeamMemberResponse) graphql.Marshaler {
	return ec._GetTeamMemberResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTeamMemberResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamMemberResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTeamMemberResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTeamMemberResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetTeamResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTeamResponse) graphql.Marshaler {
	return ec._GetTeamResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTeamResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTeamResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTeamResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNGetTeamsResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamsResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTeamsResponse) graphql.Marshaler {
	return ec._GetTeamsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTeamsResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamsResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTeamsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTeamsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetTournamentUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTournamentUserError(ctx context.Context, v any) (model.GetTournamentUserError, error) {
	var res model.GetTournamentUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetTournamentUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTournamentUserError(ctx context.Context, sel ast.SelectionSet, v model.GetTournamentUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetTournamentUserResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTournamentUserResponse) graphql.Marshaler {
	return ec._GetTournamentUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTournamentUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTournamentUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTournamentUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGetTournamentUsersError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTournamentUsersError(ctx context.Context, v any) (model.GetTournamentUsersError, error) {
	var res model.GetTournamentUsersError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetTournamentUsersError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐGetTournamentUsersError(ctx context.Context, sel ast.SelectionSet, v model.GetTournamentUsersError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGetTournamentUsersResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTournamentUsersResponse(ctx context.Context, sel ast.SelectionSet, v api.GetTournamentUsersResponse) graphql.Marshaler {
	return ec._GetTournamentUsersResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetTournamentUsersResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTournamentUsersResponse(ctx context.Context, sel ast.SelectionSet, v *api.GetTournamentUsersResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetTournamentUsersResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt642int64(ctx context.Context, v any) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt642int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNItem2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItem(ctx context.Context, sel ast.SelectionSet, v []*api.Item) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOItem2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNItemError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐItemError(ctx context.Context, v any) (model.ItemError, error) {
	var res model.ItemError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐItemError(ctx context.Context, sel ast.SelectionSet, v model.ItemError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNItemRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItemRequest(ctx context.Context, v any) (*api.ItemRequest, error) {
	res, err := ec.unmarshalInputItemRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItemResponse(ctx context.Context, sel ast.SelectionSet, v api.ItemResponse) graphql.Marshaler {
	return ec._ItemResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNItemResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItemResponse(ctx context.Context, sel ast.SelectionSet, v *api.ItemResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ItemResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNJoinTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐJoinTeamError(ctx context.Context, v any) (model.JoinTeamError, error) {
	var res model.JoinTeamError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJoinTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐJoinTeamError(ctx context.Context, sel ast.SelectionSet, v model.JoinTeamError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNJoinTeamResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐJoinTeamResponse(ctx context.Context, sel ast.SelectionSet, v api.JoinTeamResponse) graphql.Marshaler {
	return ec._JoinTeamResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNJoinTeamResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐJoinTeamResponse(ctx context.Context, sel ast.SelectionSet, v *api.JoinTeamResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JoinTeamResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLeaveTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐLeaveTeamError(ctx context.Context, v any) (model.LeaveTeamError, error) {
	var res model.LeaveTeamError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLeaveTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐLeaveTeamError(ctx context.Context, sel ast.SelectionSet, v model.LeaveTeamError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLeaveTeamResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐLeaveTeamResponse(ctx context.Context, sel ast.SelectionSet, v api.LeaveTeamResponse) graphql.Marshaler {
	return ec._LeaveTeamResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNLeaveTeamResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐLeaveTeamResponse(ctx context.Context, sel ast.SelectionSet, v *api.LeaveTeamResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LeaveTeamResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchRequest(ctx context.Context, v any) (*api.MatchRequest, error) {
	res, err := ec.unmarshalInputMatchRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMatchStatus2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchStatus(ctx context.Context, v any) (model.MatchStatus, error) {
	var res model.MatchStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMatchStatus2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchStatus(ctx context.Context, sel ast.SelectionSet, v model.MatchStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMatchmakingTicket2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicket(ctx context.Context, sel ast.SelectionSet, v []*api.MatchmakingTicket) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatchmakingTicket2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNMatchmakingTicketRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicketRequest(ctx context.Context, v any) (*api.MatchmakingTicketRequest, error) {
	res, err := ec.unmarshalInputMatchmakingTicketRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMatchmakingTicketStatus2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchmakingTicketStatus(ctx context.Context, v any) (model.MatchmakingTicketStatus, error) {
	var res model.MatchmakingTicketStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMatchmakingTicketStatus2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchmakingTicketStatus(ctx context.Context, sel ast.SelectionSet, v model.MatchmakingTicketStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMatchmakingUser2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUser(ctx context.Context, sel ast.SelectionSet, v []*api.MatchmakingUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatchmakingUser2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNMatchmakingUserRequest2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUserRequest(ctx context.Context, v any) ([]*api.MatchmakingUserRequest, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*api.MatchmakingUserRequest, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUserRequest(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUserRequest(ctx context.Context, v any) (*api.MatchmakingUserRequest, error) {
	res, err := ec.unmarshalInputMatchmakingUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRecord2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRecord(ctx context.Context, sel ast.SelectionSet, v []*api.Record) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORecord2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRecord(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNRecordRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRecordRequest(ctx context.Context, v any) (*api.RecordRequest, error) {
	res, err := ec.unmarshalInputRecordRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRemoveEventResultError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐRemoveEventResultError(ctx context.Context, v any) (model.RemoveEventResultError, error) {
	var res model.RemoveEventResultError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRemoveEventResultError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐRemoveEventResultError(ctx context.Context, sel ast.SelectionSet, v model.RemoveEventResultError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRemoveEventResultResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRemoveEventResultResponse(ctx context.Context, sel ast.SelectionSet, v api.RemoveEventResultResponse) graphql.Marshaler {
	return ec._RemoveEventResultResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRemoveEventResultResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRemoveEventResultResponse(ctx context.Context, sel ast.SelectionSet, v *api.RemoveEventResultResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RemoveEventResultResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSearchTeamsError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐSearchTeamsError(ctx context.Context, v any) (model.SearchTeamsError, error) {
	var res model.SearchTeamsError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSearchTeamsError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐSearchTeamsError(ctx context.Context, sel ast.SelectionSet, v model.SearchTeamsError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSearchTeamsResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐSearchTeamsResponse(ctx context.Context, sel ast.SelectionSet, v api.SearchTeamsResponse) graphql.Marshaler {
	return ec._SearchTeamsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchTeamsResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐSearchTeamsResponse(ctx context.Context, sel ast.SelectionSet, v *api.SearchTeamsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SearchTeamsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSetMatchPrivateServerError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐSetMatchPrivateServerError(ctx context.Context, v any) (model.SetMatchPrivateServerError, error) {
	var res model.SetMatchPrivateServerError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSetMatchPrivateServerError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐSetMatchPrivateServerError(ctx context.Context, sel ast.SelectionSet, v model.SetMatchPrivateServerError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSetMatchPrivateServerResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐSetMatchPrivateServerResponse(ctx context.Context, sel ast.SelectionSet, v api.SetMatchPrivateServerResponse) graphql.Marshaler {
	return ec._SetMatchPrivateServerResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNSetMatchPrivateServerResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐSetMatchPrivateServerResponse(ctx context.Context, sel ast.SelectionSet, v *api.SetMatchPrivateServerResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SetMatchPrivateServerResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStartMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐStartMatchError(ctx context.Context, v any) (model.StartMatchError, error) {
	var res model.StartMatchError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStartMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐStartMatchError(ctx context.Context, sel ast.SelectionSet, v model.StartMatchError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNStartMatchResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐStartMatchResponse(ctx context.Context, sel ast.SelectionSet, v api.StartMatchResponse) graphql.Marshaler {
	return ec._StartMatchResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNStartMatchResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐStartMatchResponse(ctx context.Context, sel ast.SelectionSet, v *api.StartMatchResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StartMatchResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx context.Context, v any) (*structpb.Struct, error) {
	res, err := scalar.UnmarshalProtobufStruct(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx context.Context, sel ast.SelectionSet, v *structpb.Struct) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := scalar.MarshalProtobufStruct(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTask2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTask(ctx context.Context, sel ast.SelectionSet, v []*api.Task) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTask2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐTaskError(ctx context.Context, v any) (model.TaskError, error) {
	var res model.TaskError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐTaskError(ctx context.Context, sel ast.SelectionSet, v model.TaskError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTaskRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTaskRequest(ctx context.Context, v any) (*api.TaskRequest, error) {
	res, err := ec.unmarshalInputTaskRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTaskResponse(ctx context.Context, sel ast.SelectionSet, v api.TaskResponse) graphql.Marshaler {
	return ec._TaskResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTaskResponse(ctx context.Context, sel ast.SelectionSet, v *api.TaskResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNTeam2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeam(ctx context.Context, sel ast.SelectionSet, v []*api.Team) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTeam2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐTeamError(ctx context.Context, v any) (model.TeamError, error) {
	var res model.TeamError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐTeamError(ctx context.Context, sel ast.SelectionSet, v model.TeamError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTeamMember2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamMember(ctx context.Context, sel ast.SelectionSet, v []*api.TeamMember) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTeamMember2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamMember(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNTeamMemberRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamMemberRequest(ctx context.Context, v any) (*api.TeamMemberRequest, error) {
	res, err := ec.unmarshalInputTeamMemberRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamRequest(ctx context.Context, v any) (*api.TeamRequest, error) {
	res, err := ec.unmarshalInputTeamRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTeamResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamResponse(ctx context.Context, sel ast.SelectionSet, v api.TeamResponse) graphql.Marshaler {
	return ec._TeamResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamResponse(ctx context.Context, sel ast.SelectionSet, v *api.TeamResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TeamResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx context.Context, v any) (*timestamppb.Timestamp, error) {
	res, err := scalar.UnmarshalProtobufTimestamp(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx context.Context, sel ast.SelectionSet, v *timestamppb.Timestamp) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := scalar.MarshalProtobufTimestamp(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTournamentInterval2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋpkgᚋgraphqlEnumsᚐTournamentInterval(ctx context.Context, v any) (graphqlEnums.TournamentInterval, error) {
	var res graphqlEnums.TournamentInterval
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTournamentInterval2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋpkgᚋgraphqlEnumsᚐTournamentInterval(ctx context.Context, sel ast.SelectionSet, v graphqlEnums.TournamentInterval) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTournamentUser2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUser(ctx context.Context, sel ast.SelectionSet, v []*api.TournamentUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTournamentUser2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNTournamentUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐTournamentUserError(ctx context.Context, v any) (model.TournamentUserError, error) {
	var res model.TournamentUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTournamentUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐTournamentUserError(ctx context.Context, sel ast.SelectionSet, v model.TournamentUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTournamentUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUserRequest(ctx context.Context, v any) (*api.TournamentUserRequest, error) {
	res, err := ec.unmarshalInputTournamentUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTournamentUserResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v api.TournamentUserResponse) graphql.Marshaler {
	return ec._TournamentUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNTournamentUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.TournamentUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TournamentUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUint322uint32(ctx context.Context, v any) (uint32, error) {
	res, err := graphql.UnmarshalUint32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint322uint32(ctx context.Context, sel ast.SelectionSet, v uint32) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalUint32(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUint642uint64(ctx context.Context, v any) (uint64, error) {
	res, err := graphql.UnmarshalUint64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint642uint64(ctx context.Context, sel ast.SelectionSet, v uint64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalUint64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUint642ᚕuint64ᚄ(ctx context.Context, v any) ([]uint64, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]uint64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUint642uint64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNUint642ᚕuint64ᚄ(ctx context.Context, sel ast.SelectionSet, v []uint64) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNUint642uint64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNUpdateArenaError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateArenaError(ctx context.Context, v any) (model.UpdateArenaError, error) {
	var res model.UpdateArenaError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateArenaError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateArenaError(ctx context.Context, sel ast.SelectionSet, v model.UpdateArenaError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateArenaResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateArenaResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateArenaResponse) graphql.Marshaler {
	return ec._UpdateArenaResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateArenaResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateArenaResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateArenaResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateArenaResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateEventError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateEventError(ctx context.Context, v any) (model.UpdateEventError, error) {
	var res model.UpdateEventError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateEventError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateEventError(ctx context.Context, sel ast.SelectionSet, v model.UpdateEventError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateEventResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateEventResponse) graphql.Marshaler {
	return ec._UpdateEventResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateEventResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateEventResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateEventResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateEventRoundError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateEventRoundError(ctx context.Context, v any) (model.UpdateEventRoundError, error) {
	var res model.UpdateEventRoundError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateEventRoundError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateEventRoundError(ctx context.Context, sel ast.SelectionSet, v model.UpdateEventRoundError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateEventRoundResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventRoundResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateEventRoundResponse) graphql.Marshaler {
	return ec._UpdateEventRoundResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateEventRoundResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventRoundResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateEventRoundResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateEventRoundResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateEventUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateEventUserError(ctx context.Context, v any) (model.UpdateEventUserError, error) {
	var res model.UpdateEventUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateEventUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateEventUserError(ctx context.Context, sel ast.SelectionSet, v model.UpdateEventUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateEventUserResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventUserResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateEventUserResponse) graphql.Marshaler {
	return ec._UpdateEventUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateEventUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateEventUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateEventUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateItemError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateItemError(ctx context.Context, v any) (model.UpdateItemError, error) {
	var res model.UpdateItemError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateItemError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateItemError(ctx context.Context, sel ast.SelectionSet, v model.UpdateItemError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateItemResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateItemResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateItemResponse) graphql.Marshaler {
	return ec._UpdateItemResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateItemResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateItemResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateItemResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateItemResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateMatchError(ctx context.Context, v any) (model.UpdateMatchError, error) {
	var res model.UpdateMatchError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateMatchError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateMatchError(ctx context.Context, sel ast.SelectionSet, v model.UpdateMatchError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateMatchResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateMatchResponse) graphql.Marshaler {
	return ec._UpdateMatchResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateMatchResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateMatchResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateMatchResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateMatchmakingTicketError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateMatchmakingTicketError(ctx context.Context, v any) (model.UpdateMatchmakingTicketError, error) {
	var res model.UpdateMatchmakingTicketError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateMatchmakingTicketError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateMatchmakingTicketError(ctx context.Context, sel ast.SelectionSet, v model.UpdateMatchmakingTicketError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateMatchmakingTicketResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateMatchmakingTicketResponse) graphql.Marshaler {
	return ec._UpdateMatchmakingTicketResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateMatchmakingTicketResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchmakingTicketResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateMatchmakingTicketResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateMatchmakingTicketResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateMatchmakingUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateMatchmakingUserError(ctx context.Context, v any) (model.UpdateMatchmakingUserError, error) {
	var res model.UpdateMatchmakingUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateMatchmakingUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateMatchmakingUserError(ctx context.Context, sel ast.SelectionSet, v model.UpdateMatchmakingUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateMatchmakingUserResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateMatchmakingUserResponse) graphql.Marshaler {
	return ec._UpdateMatchmakingUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateMatchmakingUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchmakingUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateMatchmakingUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateMatchmakingUserResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateRecordError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateRecordError(ctx context.Context, v any) (model.UpdateRecordError, error) {
	var res model.UpdateRecordError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateRecordError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateRecordError(ctx context.Context, sel ast.SelectionSet, v model.UpdateRecordError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateRecordResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateRecordResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateRecordResponse) graphql.Marshaler {
	return ec._UpdateRecordResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateRecordResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateRecordResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateRecordResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateRecordResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateTaskError(ctx context.Context, v any) (model.UpdateTaskError, error) {
	var res model.UpdateTaskError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTaskError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateTaskError(ctx context.Context, sel ast.SelectionSet, v model.UpdateTaskError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateTaskResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTaskResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateTaskResponse) graphql.Marshaler {
	return ec._UpdateTaskResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTaskResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTaskResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateTaskResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTaskResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateTeamError(ctx context.Context, v any) (model.UpdateTeamError, error) {
	var res model.UpdateTeamError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTeamError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateTeamError(ctx context.Context, sel ast.SelectionSet, v model.UpdateTeamError) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUpdateTeamMemberError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateTeamMemberError(ctx context.Context, v any) (model.UpdateTeamMemberError, error) {
	var res model.UpdateTeamMemberError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTeamMemberError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateTeamMemberError(ctx context.Context, sel ast.SelectionSet, v model.UpdateTeamMemberError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateTeamMemberResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTeamMemberResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateTeamMemberResponse) graphql.Marshaler {
	return ec._UpdateTeamMemberResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTeamMemberResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTeamMemberResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateTeamMemberResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTeamMemberResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNUpdateTeamResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTeamResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateTeamResponse) graphql.Marshaler {
	return ec._UpdateTeamResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTeamResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTeamResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateTeamResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTeamResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateTournamentUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateTournamentUserError(ctx context.Context, v any) (model.UpdateTournamentUserError, error) {
	var res model.UpdateTournamentUserError
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTournamentUserError2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐUpdateTournamentUserError(ctx context.Context, sel ast.SelectionSet, v model.UpdateTournamentUserError) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUpdateTournamentUserResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v api.UpdateTournamentUserResponse) graphql.Marshaler {
	return ec._UpdateTournamentUserResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTournamentUserResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTournamentUserResponse(ctx context.Context, sel ast.SelectionSet, v *api.UpdateTournamentUserResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTournamentUserResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNWebhookResponse2githubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐWebhookResponse(ctx context.Context, sel ast.SelectionSet, v api.WebhookResponse) graphql.Marshaler {
	return ec._WebhookResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNWebhookResponse2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐWebhookResponse(ctx context.Context, sel ast.SelectionSet, v *api.WebhookResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WebhookResponse(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAddEventResultRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐAddEventResultRequest(ctx context.Context, v any) (*api.AddEventResultRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAddEventResultRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOArena2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArena(ctx context.Context, sel ast.SelectionSet, v []*api.Arena) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOArena2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArena(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOArena2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArena(ctx context.Context, sel ast.SelectionSet, v *api.Arena) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Arena(ctx, sel, v)
}

func (ec *executionContext) unmarshalOArenaRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐArenaRequest(ctx context.Context, v any) (*api.ArenaRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputArenaRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCreateArenaRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateArenaRequest(ctx context.Context, v any) (*api.CreateArenaRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateArenaRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRequest(ctx context.Context, v any) (*api.CreateEventRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateEventRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateEventRound2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRound(ctx context.Context, v any) (*api.CreateEventRound, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateEventRound(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateEventRoundRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateEventRoundRequest(ctx context.Context, v any) (*api.CreateEventRoundRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateEventRoundRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateItemRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateItemRequest(ctx context.Context, v any) (*api.CreateItemRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateItemRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateMatchmakingTicketRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateMatchmakingTicketRequest(ctx context.Context, v any) (*api.CreateMatchmakingTicketRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateMatchmakingTicketRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateMatchmakingUserRequest(ctx context.Context, v any) (*api.CreateMatchmakingUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateMatchmakingUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateRecordRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateRecordRequest(ctx context.Context, v any) (*api.CreateRecordRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateRecordRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateTaskRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTaskRequest(ctx context.Context, v any) (*api.CreateTaskRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateTaskRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTeamRequest(ctx context.Context, v any) (*api.CreateTeamRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateTeamRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateTournamentUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐCreateTournamentUserRequest(ctx context.Context, v any) (*api.CreateTournamentUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateTournamentUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEndMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEndMatchRequest(ctx context.Context, v any) (*api.EndMatchRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEndMatchRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEvent2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEvent(ctx context.Context, sel ast.SelectionSet, v *api.Event) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRequest(ctx context.Context, v any) (*api.EventRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventRound2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRound(ctx context.Context, sel ast.SelectionSet, v *api.EventRound) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventRound(ctx, sel, v)
}

func (ec *executionContext) marshalOEventRoundUser2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRoundUser(ctx context.Context, sel ast.SelectionSet, v *api.EventRoundUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventRoundUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventRoundUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventRoundUserRequest(ctx context.Context, v any) (*api.EventRoundUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventRoundUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventUser2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUser(ctx context.Context, sel ast.SelectionSet, v *api.EventUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐEventUserRequest(ctx context.Context, v any) (*api.EventUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventRequest(ctx context.Context, v any) (*api.GetEventRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetEventRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetEventRoundRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventRoundRequest(ctx context.Context, v any) (*api.GetEventRoundRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetEventRoundRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetEventUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetEventUserRequest(ctx context.Context, v any) (*api.GetEventUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetEventUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetItemsRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetItemsRequest(ctx context.Context, v any) (*api.GetItemsRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetItemsRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchRequest(ctx context.Context, v any) (*api.GetMatchRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetMatchRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetMatchesRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchesRequest(ctx context.Context, v any) (*api.GetMatchesRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetMatchesRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetMatchmakingTicketRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingTicketRequest(ctx context.Context, v any) (*api.GetMatchmakingTicketRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetMatchmakingTicketRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetMatchmakingTicketsRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetMatchmakingTicketsRequest(ctx context.Context, v any) (*api.GetMatchmakingTicketsRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetMatchmakingTicketsRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetRecordsRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetRecordsRequest(ctx context.Context, v any) (*api.GetRecordsRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetRecordsRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetTasksRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTasksRequest(ctx context.Context, v any) (*api.GetTasksRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetTasksRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamRequest(ctx context.Context, v any) (*api.GetTeamRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetTeamRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetTeamsRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTeamsRequest(ctx context.Context, v any) (*api.GetTeamsRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetTeamsRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGetTournamentUsersRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐGetTournamentUsersRequest(ctx context.Context, v any) (*api.GetTournamentUsersRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGetTournamentUsersRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInt642ᚖint64(ctx context.Context, v any) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt642ᚖint64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) marshalOItem2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItem(ctx context.Context, sel ast.SelectionSet, v *api.Item) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Item(ctx, sel, v)
}

func (ec *executionContext) unmarshalOItemRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐItemRequest(ctx context.Context, v any) (*api.ItemRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputItemRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOJoinTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐJoinTeamRequest(ctx context.Context, v any) (*api.JoinTeamRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJoinTeamRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatch2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatch(ctx context.Context, sel ast.SelectionSet, v []*api.Match) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatch2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMatch2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatch(ctx context.Context, sel ast.SelectionSet, v *api.Match) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Match(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchRequest(ctx context.Context, v any) (*api.MatchRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMatchStatus2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchStatus(ctx context.Context, v any) ([]*model.MatchStatus, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.MatchStatus, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOMatchStatus2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMatchStatus2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchStatus(ctx context.Context, sel ast.SelectionSet, v []*model.MatchStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatchStatus2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalOMatchStatus2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchStatus(ctx context.Context, v any) (*model.MatchStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.MatchStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatchStatus2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchStatus(ctx context.Context, sel ast.SelectionSet, v *model.MatchStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOMatchmakingTicket2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicket(ctx context.Context, sel ast.SelectionSet, v []*api.MatchmakingTicket) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatchmakingTicket2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMatchmakingTicket2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicket(ctx context.Context, sel ast.SelectionSet, v *api.MatchmakingTicket) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MatchmakingTicket(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMatchmakingTicketRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingTicketRequest(ctx context.Context, v any) (*api.MatchmakingTicketRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchmakingTicketRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMatchmakingTicketStatus2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchmakingTicketStatus(ctx context.Context, v any) ([]*model.MatchmakingTicketStatus, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.MatchmakingTicketStatus, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOMatchmakingTicketStatus2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchmakingTicketStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMatchmakingTicketStatus2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchmakingTicketStatus(ctx context.Context, sel ast.SelectionSet, v []*model.MatchmakingTicketStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatchmakingTicketStatus2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchmakingTicketStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalOMatchmakingTicketStatus2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchmakingTicketStatus(ctx context.Context, v any) (*model.MatchmakingTicketStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.MatchmakingTicketStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatchmakingTicketStatus2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋinternalᚋbffᚋmodelᚐMatchmakingTicketStatus(ctx context.Context, sel ast.SelectionSet, v *model.MatchmakingTicketStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOMatchmakingUser2ᚕᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUser(ctx context.Context, sel ast.SelectionSet, v []*api.MatchmakingUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatchmakingUser2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMatchmakingUser2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUser(ctx context.Context, sel ast.SelectionSet, v *api.MatchmakingUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MatchmakingUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐMatchmakingUserRequest(ctx context.Context, v any) (*api.MatchmakingUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchmakingUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONameUserId2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐNameUserId(ctx context.Context, v any) (*api.NameUserId, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNameUserId(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPagination2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐPagination(ctx context.Context, v any) (*api.Pagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPagination(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORecord2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRecord(ctx context.Context, sel ast.SelectionSet, v *api.Record) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Record(ctx, sel, v)
}

func (ec *executionContext) unmarshalORecordRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐRecordRequest(ctx context.Context, v any) (*api.RecordRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRecordRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchTeamsRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐSearchTeamsRequest(ctx context.Context, v any) (*api.SearchTeamsRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchTeamsRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSetMatchPrivateServerRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐSetMatchPrivateServerRequest(ctx context.Context, v any) (*api.SetMatchPrivateServerRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSetMatchPrivateServerRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOStartMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐStartMatchRequest(ctx context.Context, v any) (*api.StartMatchRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStartMatchRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx context.Context, v any) (*structpb.Struct, error) {
	if v == nil {
		return nil, nil
	}
	res, err := scalar.UnmarshalProtobufStruct(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStruct2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋstructpbᚐStruct(ctx context.Context, sel ast.SelectionSet, v *structpb.Struct) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := scalar.MarshalProtobufStruct(v)
	return res
}

func (ec *executionContext) marshalOTask2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTask(ctx context.Context, sel ast.SelectionSet, v *api.Task) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTaskRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTaskRequest(ctx context.Context, v any) (*api.TaskRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTaskRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTeam2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeam(ctx context.Context, sel ast.SelectionSet, v *api.Team) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Team(ctx, sel, v)
}

func (ec *executionContext) marshalOTeamMember2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamMember(ctx context.Context, sel ast.SelectionSet, v *api.TeamMember) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TeamMember(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTeamMemberRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamMemberRequest(ctx context.Context, v any) (*api.TeamMemberRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamMemberRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTeamRequest(ctx context.Context, v any) (*api.TeamRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTeamRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx context.Context, v any) (*timestamppb.Timestamp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := scalar.UnmarshalProtobufTimestamp(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTimestamp2ᚖgoogleᚗgolangᚗorgᚋprotobufᚋtypesᚋknownᚋtimestamppbᚐTimestamp(ctx context.Context, sel ast.SelectionSet, v *timestamppb.Timestamp) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := scalar.MarshalProtobufTimestamp(v)
	return res
}

func (ec *executionContext) unmarshalOTournamentIntervalUserId2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentIntervalUserId(ctx context.Context, v any) (*api.TournamentIntervalUserId, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTournamentIntervalUserId(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTournamentUser2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUser(ctx context.Context, sel ast.SelectionSet, v *api.TournamentUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TournamentUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTournamentUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐTournamentUserRequest(ctx context.Context, v any) (*api.TournamentUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTournamentUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUint322ᚖuint32(ctx context.Context, v any) (*uint32, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUint32(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint322ᚖuint32(ctx context.Context, sel ast.SelectionSet, v *uint32) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalUint32(*v)
	return res
}

func (ec *executionContext) unmarshalOUint642ᚕuint64ᚄ(ctx context.Context, v any) ([]uint64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]uint64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUint642uint64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUint642ᚕuint64ᚄ(ctx context.Context, sel ast.SelectionSet, v []uint64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNUint642uint64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUint642ᚖuint64(ctx context.Context, v any) (*uint64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUint64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint642ᚖuint64(ctx context.Context, sel ast.SelectionSet, v *uint64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalUint64(*v)
	return res
}

func (ec *executionContext) unmarshalOUpdateArenaRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateArenaRequest(ctx context.Context, v any) (*api.UpdateArenaRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateArenaRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateEventRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventRequest(ctx context.Context, v any) (*api.UpdateEventRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateEventRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateEventRoundRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventRoundRequest(ctx context.Context, v any) (*api.UpdateEventRoundRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateEventRoundRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateEventUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateEventUserRequest(ctx context.Context, v any) (*api.UpdateEventUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateEventUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateItemRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateItemRequest(ctx context.Context, v any) (*api.UpdateItemRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateItemRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateMatchRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchRequest(ctx context.Context, v any) (*api.UpdateMatchRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateMatchRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateMatchmakingTicketRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchmakingTicketRequest(ctx context.Context, v any) (*api.UpdateMatchmakingTicketRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateMatchmakingTicketRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateMatchmakingUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateMatchmakingUserRequest(ctx context.Context, v any) (*api.UpdateMatchmakingUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateMatchmakingUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateRecordRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateRecordRequest(ctx context.Context, v any) (*api.UpdateRecordRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateRecordRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateTaskRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTaskRequest(ctx context.Context, v any) (*api.UpdateTaskRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateTaskRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateTeamMemberRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTeamMemberRequest(ctx context.Context, v any) (*api.UpdateTeamMemberRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateTeamMemberRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateTeamRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTeamRequest(ctx context.Context, v any) (*api.UpdateTeamRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateTeamRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateTournamentUserRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐUpdateTournamentUserRequest(ctx context.Context, v any) (*api.UpdateTournamentUserRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateTournamentUserRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWebhookRequest2ᚖgithubᚗcomᚋMorhafAlshiblyᚋcoandaᚋapiᚐWebhookRequest(ctx context.Context, v any) (*api.WebhookRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWebhookRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
